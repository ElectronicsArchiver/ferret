#+title: Ferret Programmer's Manual
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport
#+SETUPFILE: org-mode.conf
#+OPTIONS: H:10 author:nil  

* Getting Started
** What Is Ferret

Ferret is a free software lisp implementation designed to be used in
real time embedded control systems. Ferret lisp compiles down to self
contained *C++11*. Generated code is portable between any Operating
System and/or Microcontroller that supports a *C++11* compliant
compiler. It has been verified to run on architectures ranging from
embedded systems with as little as *2KB of RAM* to general purpose
computers running Linux/Mac OS X/Windows.

 - General Purpose Computers
   - Clang on Mac OS X
   - GCC & Clang on Linux
 - Microcontrollers
   - Arduino 
     - Uno / Atmega328
     - Due / AT91SAM3X8E
     - 101 / Intel Curie
   - Teensy
     - 2.0 / 16 MHz AVR
     - 3.2 / Cortex-M4
     - 3.6 / Cortex-M4F
   - SparkFun SAMD21 Mini / ATSAMD21G18 - ARM Cortex-M0+
   - NodeMcu - ESP8266
 - [[Hardware / Operating System Support]]

** Features

 - Tailored for Real Time Control Applications. (Deterministic Execution.)
 - Immutable Data Structures
 - Functional
 - Macros
 - Easy FFI (Inline C,C++. See [[Accessing C,C++ Libraries]])
 - Easily Embeddable (i.e Ferret fns are just C++ functors.)
 - Memory Pooling (Ability to *run without heap memory*. See [[Memory Management]])
 - Destructuring
 - Module System

** Download

Ferret is available as prebuilt and source code distributions. See
[[Building From Sources]] for links to source distribution.

#+BEGIN_HTML
  <img src="https://badge.fury.io/gh/nakkaya%2Fferret.svg" style="float: left; padding-right: 1cm;">

  <a href="https://travis-ci.org/nakkaya/ferret/builds">
    <img src="https://travis-ci.org/nakkaya/ferret.svg?branch=master" style="margin-left: 0;">
  </a>
#+END_HTML

Platform independent builds (requires JVM),

   - [[https://ferret-lang.org/builds/ferret.jar][Standalone Jar]]
   - [[https://ferret-lang.org/builds/ferret][Executable]] (Requires Bash)

Supported package managers,

   - Debian/Ubuntu

#+begin_src sh :noweb yes :tangle no
  echo "deb [trusted=yes]\
   https://ferret-lang.org/debian-repo ferret-lisp main" >> /etc/apt/sources.list
  apt-get update
  apt-get install ferret-lisp
#+end_src 

   - Clojars - https://clojars.org/ferret

#+begin_src clojure :noweb yes :tangle no
  [ferret "<<ferret-version()>>"]
#+end_src 

** A glimpse of Ferret

On any system, we can just compile a program directly into an
executable. Here's a program that sums the first 5 positive numbers.

#+begin_src clojure
  ;;; lazy-sum.clj
  (defn positive-numbers
    ([]
     (positive-numbers 1))
    ([n]
     (cons n (lazy-seq (positive-numbers (inc n))))))

  (println (->> (positive-numbers)
                (take 5)
                (apply +)))
#+end_src

We can compile this program using *ferret*, creating an executable named
*lazy-sum*.

#+BEGIN_EXAMPLE
  $ ./ferret -i lazy-sum.clj
  $ g++ -std=c++11 -pthread lazy-sum.cpp -o lazy-sum
  $ ./lazy-sum
  15
#+END_EXAMPLE

Output will be placed in a a file called *lazy-sum.cpp*. When *-c*
flag is used ferret will call *g++* or if set *CXX* environment
variable on the resulting *cpp* file.

#+BEGIN_EXAMPLE
  $ ./ferret -i lazy-sum.clj -c
  $ ./lazy-sum
  15
#+END_EXAMPLE

Following shows a blink example for Arduino. (See section [[Arduino
Boards]] for more info on how to use Ferret lisp on Arduino boards.) 

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/embedded/blink/blink.clj
  ;;; blink.clj
  (require '[ferret.arduino :as gpio])

  (gpio/pin-mode 13 :output)

  (forever
   (gpio/digital-write 13 1)
   (sleep 500)
   (gpio/digital-write 13 0)
   (sleep 500))
#+end_src

#+BEGIN_EXAMPLE
  $ ./ferret -i blink.clj -o blink/blink.ino
#+END_EXAMPLE

Then upload as usual. Following is another example, showing the usage
of [[Memory Management][Memory Pooling]]. Program will blink two LEDs simultaneously at
different frequencies (Yellow LED at 5 hz Blue LED at 20 hz). It uses
a memory pool of 512 bytes allocated at compile time instead of
calling malloc/free at runtime.

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/embedded/blink-multi/blink-multi.clj
  (configure-runtime! FERRET_MEMORY_POOL_SIZE 512
                      FERRET_MEMORY_POOL_PAGE_TYPE byte)

  (require '[ferret.arduino :as gpio])

  (def yellow-led 13)
  (def blue-led   12)

  (gpio/pin-mode yellow-led :output)
  (gpio/pin-mode blue-led   :output)

  (defn make-led-toggler [pin]
    (fn []
      (->> (gpio/digital-read pin)
           (bit-xor 1)
           (gpio/digital-write pin))))

  (def job-one
    (fn-throttler (make-led-toggler yellow-led) 5 :second :non-blocking))

  (def job-two
    (fn-throttler (make-led-toggler blue-led)  20 :second :non-blocking))

  (forever
   (job-one)
   (job-two))
#+end_src

#+BEGIN_EXAMPLE
  $ ./ferret -i ferret-multi-led.clj -o ferret-multi-led/ferret-multi-led.ino
#+END_EXAMPLE

** Support

 - [[https://groups.google.com/forum/#!forum/ferret-lang][ferret-lang]] - Mailing List

** Examples
*** Articles

 - [[https://nakkaya.com/2017/06/24/ferret-lisp-ffi-notes/][Ferret Lisp FFI Notes]]
 - [[https://news.ycombinator.com/item?id=14951116][Hacker News Thread]] (2017)
 - [[https://news.ycombinator.com/item?id=17644580][Hacker News Thread]] (2018)

*** Projects

 - [[https://nakkaya.com/2017/02/15/bare-metal-lisp-rc-control-using-ferret/][Bare Metal Lisp - RC Control using Ferret]]
 - [[http://nakkaya.com/2016/06/10/ferret-a-hard-real-time-clojure-for-lisp-machines/][Ferret - A Hard Real-Time Clojure for Lisp Machines]] -
   Implementation of a line following robot in Ferret.
 - [[https://github.com/nakkaya/solarcar-tracker][solarcar-tracker]] - A Tracking device for the [[http://solarcar.neu.edu.tr][Ra27 solar car]]. (GPS,
   IMU etc.) (Raspberry Pi)
 - [[https://github.com/nakkaya/solarcar-turn-indicator][solarcar-turn-indicator]] - Controller for the turn indicator
   assembly on the [[http://solarcar.neu.edu.tr][Ra27 solar car]]. (Atmega MCU)
 - [[https://github.com/nakkaya/ferret-qt-hello-world][ferret-qt-hello-world]] - QT Hello World FFI Example in Ferret Lisp

*** Wrappers

 - [[https://github.com/nakkaya/ferret-L6470-AutoDriver][ferret-L6470-AutoDriver]] - Bindings for SparkFun AutoDriver -
   Stepper Motor Driver.
 - [[https://github.com/nakkaya/ferret-mosquitto][ferret-mosquitto]] - Ferret bindings for Mosquitto MQTT Client.
 - [[https://github.com/nakkaya/ferret-opencv][ferret-opencv]] - Ferret bindings for OpenCV.
 - [[https://github.com/nakkaya/ferret-genann][ferret-genann]] - Ferret bindings for [[https://codeplea.com/genann][genann]] - simple neural
   network library in ANSI C.
 - [[https://github.com/nakkaya/ferret-teensy-flight-sim][ferret-teensy-flight-sim]] - Wrapper for Teensy flight sim controls.
 - [[https://github.com/nakkaya/ferret-arduino-keypad][ferret-arduino-keypad]] - Arduino Keypad library bindings.
 - [[https://github.com/nakkaya/ferret-arduino-adafruit-pcd8544][ferret-arduino-adafruit-pcd8544]] - Adafruit Arduino PCD8544 screen
   library bindings most commonly found in Nokia 5110.
 - [[https://github.com/nakkaya/ferret-boost][ferret-boost]] - Boost bindings.
 - [[https://github.com/nakkaya/ferret-websocket][ferret-websocket]] - WebSocket++ bindigns.
 - [[https://github.com/nakkaya/ferret-logging][ferret-logging]] - easyloggingpp bindigns.
 - [[https://github.com/nakkaya/ferret-great-circle-navigation][ferret-great-circle-navigation]] - Utils for great circle
   navigation.

** License

BSD 2-Clause License

Copyright (c) 2017, Nurullah Akkaya
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

- Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

* Overview

Ferret is a functional, lazy language designed to be used in real time
embedded control systems. It is heavily inspired by Clojure both
syntactically and semantically.  Functions / Macros that are present
in both Ferret and Clojure should mimic their Clojure counter
parts. If they don't it is considered a bug. (or not possible to
implement with the current implementation.)

This document is not intended to be a full lisp tutorial. It is a
specification of the subset of lisp implemented by Ferret, and the
particular workings of the [[*Runtime][Runtime]] and [[*Core][Core]] library. Any getting
started guide for Clojure should get you upto speed on Ferret.

** Documentation Structure

This is a literate program, inspired by Donald Knuth (Knuth, Donald
“Literate Programming (1984)” Literate Programming CSLI, p99). It is
intended to be read like a novel from cover to cover. The ideas are
expressed clearly but they are grounded in the actual source code.

The compiler and the C++ runtime needed is split into three sections.

 - [[*Compiler][Compiler]]
 - [[*Runtime][Runtime]]
 - [[*Core][Core]]

[[*Compiler][Compiler]] section contains the actual compiler written in Clojure. It
takes the Ferret code and converts it to a Intermediate
representation by taking the Ferret form and running it [[Compilation][through some
transformations]]. This IR is then run through [[Code Generation]] module to
create C++ code. [[*Runtime][Runtime]] contains the C++ runtime needed to support
Ferret such as [[Object System]], [[Memory Pool][Memory Pooling]], [[Reference Counting][Garbage Collection]]. It
is written in a mixture of C++ and Ferret DSL. [[*Core][Core]] is the standard
library of Ferret, provides a ton of general-purpose functionality for
writing robust, maintainable embedded applications.

** Hardware / Operating System Support

Ferret does not depend on any external dependencies (Including the C++
Standard Library). Unit tests are run on Mac OS X and Linux, any
operating system with a C++11 compiler is supported. When running on a
microcontroller ferret will check if it is a supported platform during
compile time and enable hardware specific features. (Currently only
UART is hardware specific.) If running on an unknown hardware it
will run in *safe mode* (UART disabled.). Everything else is supported
in safe mode. Like operating system support any embedded system with a
C++11 compiler is supported. See [[What Is Ferret]] for a list of
currently supported microcontrollers.

*** Arduino Boards

Ferret standard library has built in support for Arduino library. *Any
board* that Arduino IDE supports should work with Ferret lisp. 

*Post Arduino 1.5.0*, Ferret compiler can upload directly to a Arduino
board by adding the following build command to the top of the file,

#+begin_src clojure
  (configure-ferret! :command "~/apps/arduino-1.8.0/arduino \\
                                 --board arduino:sam:arduino_due_x_dbg \\
                                 --port /dev/ttyACM0 \\
                                 --upload ./blink.cpp")
#+end_src

When *-c* option is passed Ferret will execute the above command and
upload the solution to the board. (See [[https://github.com/arduino/Arduino/blob/master/build/shared/manpage.adoc][ARDUINO(1) Manual Page]] for
details.)

#+BEGIN_EXAMPLE
  $ ./ferret -i blink.clj -c
#+END_EXAMPLE

Sample Makefile for automating compilation and upload on an Arduino,

#+begin_src makefile
  FERRET  = ferret
  INPUT   = core.clj
  OUTPUT  = core.ino
  ARDUINO = ~/arduino-1.8.5/arduino
  BOARD   = arduino:sam:arduino_due_x_dbg
  PORT    = /dev/ttyACM0
  RM      = rm -f

  .PHONY: verify upload clean

  default: verify

  core: core.clj
          $(FERRET) -o $(OUTPUT)

  verify: core
          $(ARDUINO) --board $(BOARD) --verify $(OUTPUT)

  upload: core
          $(ARDUINO) --board $(BOARD) --port $(PORT) --upload $(OUTPUT)

  clean:
          $(RM) $(OUTPUT)
#+end_src

*Pre Arduino 1.5.0*, recommended way is to go to preferences and set
Arduino IDE to use an External Editor. This way when Ferret recompiles
the sketch changes will be automatically picked up by the IDE ready to
be uploaded. To automatically rename the *cpp* file to *ino* or *pde*
use the following option,

#+begin_src clojure
  (configure-ferret! :command "mv blink.cpp blink.ino")
#+end_src

Then compile with,

#+BEGIN_EXAMPLE
  $ ./ferret -i blink.clj -c
#+END_EXAMPLE

Result will be *blink.ino* ready to be uploaded. Any changes to the
*clj* file should be picked up by the IDE.

*** Yocto

    Install [[https://wiki.yoctoproject.org/wiki/Building_your_own_recipes_from_first_principles][Yocto]] and create a package for your application. A sample
    recipe for a simple Ferret application is given below.

#+BEGIN_EXAMPLE
  recipes-example/
  └── core
      ├── core-0.1
      │   └── core.clj
      └── core_0.1.bb
#+END_EXAMPLE

#+begin_src clojure
  ;; core.clj
  (println "Hello World!")
#+end_src

#+begin_src fundamental
  # core_0.1.bb
  SUMMARY = "Simple Ferret application"
  SECTION = "examples"
  LICENSE = "MIT"
  LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"

  SRC_URI = "file://core.cpp"

  S = "${WORKDIR}"

  do_compile() {
           ferret -i ./core.clj
           ${CXX} -std=c++11 core.cpp -o core
  }

  do_install() {
           install -d ${D}${bindir}
           install -m 0755 core ${D}${bindir}
  }
#+end_src

Finally add the application to your =layer.conf=.

#+BEGIN_EXAMPLE
  IMAGE_INSTALL_append = " core"
#+END_EXAMPLE

*** Raspberry Pi

Clone required layers,

#+BEGIN_EXAMPLE
  git clone -b jethro git://git.yoctoproject.org/meta-raspberrypi
#+END_EXAMPLE

Add =meta-raspberrypi= to =BBLAYERS= in =build/conf/bblayers.conf=,
and and Select your machine type in =build/conf/local.conf=. See
[[http://meta-raspberrypi.readthedocs.io/en/latest/layer-contents.html#supported-machines][Supported Machines]] for =MACHINE= type. Build the image,

#+BEGIN_EXAMPLE
  bitbake rpi-basic-image
#+END_EXAMPLE

Write the image,

#+BEGIN_EXAMPLE
  dd if=tmp/deploy/images/raspberrypi2/rpi-basic-image-raspberrypi2.rpi-sdimg of=/dev/mmcblk0
#+END_EXAMPLE

** Building From Sources

All source code for the project is kept in a single =org-mode= file
named =ferret.org=. =emacs= is used to extract the sources and
documentation.

#+BEGIN_HTML
  <img src="https://img.shields.io/github/last-commit/nakkaya/ferret.svg" style="float: left; padding-right: 0.5cm;">
  <img src="https://img.shields.io/github/issues/nakkaya/ferret.svg" style="margin-left: 0;">
#+END_HTML

The latest sources are available at,

  - [[https://github.com/nakkaya/ferret][Github]]

Dependencies,

 - make
 - Java
 - Emacs (>= 24.5)
 - Leiningen

Assuming all of the above is in your path just run,

#+BEGIN_EXAMPLE
  make
#+END_EXAMPLE

This will extract the source from =ferret.org= file to =src/= directory and
build the =jar= and =executable= distributions to =bin/=
directory. =Makefile= assumes it is running on a =*NIX= based system
if not, open =ferret.org= file using =emacs= and run,

#+BEGIN_EXAMPLE
  M-x org-babel-tangle
#+END_EXAMPLE

that will extract the source code then you can threat it as any other
Clojure/Lein project. Documentation can be built using,

#+BEGIN_EXAMPLE
  make docs
#+END_EXAMPLE

Unit tests can be run using,

#+BEGIN_EXAMPLE
  make test
#+END_EXAMPLE

A release can be made by running,

#+BEGIN_EXAMPLE
  make docker-release
#+END_EXAMPLE

This will compile =ferret= run unit tests against all supported
compilers/frameworks and generate a =release/= folder containing
deployment files.

* Compiler

Ferret has a similar architecture to other modern compilers,

#+CAPTION: Ferret Compiler Architecture
#+NAME:   fig:compiler_architecture
[[./ferret-styles/graphs/compiler_arch.png]]

First, an input file containing Ferret code is loaded from the
command line. From there a series of source-to-source transformations
are performed on the AST to expand macros, perform optimizations, and
make the code easier to compile to C++. (Optionally these intermediate
representations (IR) can be printed out in a readable format to aid
debugging.) The final AST is then output as a .cpp file and the C++
compiler is invoked to create the final executable or object file.

** Compilation

Ferret (or any other Lisp) has features not provided by C++ such as
automatic memory management i.e. garbage collection (GC), closures
etc. Source-to-source transformations are used to add constructs
required by C++, restructure Ferret forms in preparation to generate
C++ code. Final intermediate representation can be directly compiled
to C++. Any Ferret form go through nine transformations before they
are passed to the code generation phase. Each transformation makes a
separate pass over the form, this makes the compiler easier to
maintain.

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (defn compile [form options]
    (->> (ferret-runtime options form)
         (remove-assertions options)
         (expand-macros)
         (let->fn)
         (do->fn)
         (fn->lift)
         (fn->inline options)
         (escape-analysis)
         (symbol-conversion)))
#+end_src

*** Modules

Supported =require= forms for importing modules,

#+BEGIN_SRC clojure :tangle no
  (require 'package.io)

  (require '[package.io :as io])

  (require '[package.io :as io]
           '[package.udp :as udp])
#+END_SRC

Helper functions or variables in modules that should not be exposed
outside the namespace can be defined using the following form,

#+BEGIN_SRC clojure :tangle no
  (def ^{:private true}  helper-var :value)

  (defn ^{:private true} helper-fn [] 42)
#+END_SRC

If a file named =deps.clj= is found on the same path as the input
file. Modules listed in it can be downloaded using =--deps= CLI
argument.

#+BEGIN_SRC clojure :tangle no
  ;;deps.clj
  (git :url    "https://github.com/nakkaya/ferret-opencv.git")

  (git :url    "https://github.com/nakkaya/ferret-mosquitto.git"
       :commit "8c8c0890194a0b98130a3d4d78b71c99b833b12a")
#+END_SRC

#+name: core-compiler-checkout-deps
#+begin_src clojure :tangle no
  (defn checkout-deps [path]
    (when (io/file-exists (str path "/deps.clj"))
      (let [deps (-> (read-clojure-file "deps.clj")
                     (parser/peek (parser/form? 'git)))
            deps (map (fn [[_ & kvs]] (apply hash-map kvs)) deps)]
        (doseq [{url :url commit :commit} deps]
          (let [folder (str path (jgit-util/name-from-uri url))]
            (info "dep =>" url)
            (when (io/file-exists folder)
              (org.apache.commons.io.FileUtils/deleteDirectory
               (java.io.File. folder)))
            (let [repo (jgit/git-clone-full
                        url (org.apache.commons.io.FilenameUtils/normalize folder))]
              (jgit/git-checkout (:repo repo)
                                 (if commit
                                   commit
                                   "master"))))))))
#+end_src

Compiler will look for a file under current working directory called,
=package/io.clj= all expression in the that file will be added to the
front of the current form with symbols renamed from =some-fn= to
=io/some-function=.

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn import-modules-select-require [form]
    (let [norm-require (fn [f]
                         (if (symbol? f)
                           [f :as f]
                           f))]
      (->> (parser/peek form (parser/form? 'require))
           (reduce (fn[h v]
                     (if (= 2 (count v))
                       ;; require single module
                       (conj h (norm-require (->> v last last)))
                       ;; require multiple modules
                       (concat h (map #(norm-require (last %)) (rest v))))) [])
           (map (fn [[mod _ as]] [mod as]))
           (reduce (fn[h [mod as]]
                     (if (h mod)
                       (assoc h mod (conj (h mod) as))
                       (assoc h mod [as]))) {}))))
#+end_src

Extract the list of packages and aliases from the form. Returns a map
of =mod / aliases= pairs.

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn import-modules-load-modules [package-list options]
    (->> package-list
         (reduce (fn[h [m aliases]]
                   (let [file-name      (str (.replace (str m) "." "/") ".clj")
                         mod            (-> (if (clojure.java.io/resource file-name)
                                              file-name
                                              (str (:path options) file-name))
                                            (read-clojure-file)
                                            (parser/drop (parser/form? 'configure-runtime!))
                                            (parser/drop (parser/form? 'configure-ferret!)))
                         macro-symbols  (->> (parser/peek mod (parser/form? 'defmacro))
                                             (map second)
                                             (into #{}))
                         def-symbols    (->> (parser/peek (expand-macros mod) (parser/form? 'def))
                                             (map second)
                                             (into #{}))
                         replace?       (set/union macro-symbols def-symbols)
                         mod            (parser/transform
                                         mod
                                         #(and (symbol? %)
                                               (replace? %))
                                         #(parser/new-symbol m "_" %))]
                     (reduce (fn [h v] (conj h v)) h mod)))
                 [])
         lazy-seq))
#+end_src

Loads all modules listed in the package list. When a module is loaded
all its symbols are replaced with its module name except =core=
functions. Module names acts as namespaces. Returns a form that the is
concatenation of all modules listed in form.

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn import-modules-convert-alias-to-module [package-list form]
    (let [alias-to-mod (reduce (fn[h [mod aliases]]
                                 (reduce (fn[h v] (assoc h v mod)) h aliases))
                               {} package-list)]
      (parser/transform form symbol?
                        (fn [f]
                          (if-let [[_ alias fn] (re-find #"(.*?)/(.*)" (str f))]
                            (if-let [mod-sym (alias-to-mod (symbol alias))]
                              (parser/new-symbol mod-sym "_" fn)
                              f)
                            f)))))
#+end_src

Convert all aliased symbols in the form to their fully qualified
modules names. So =helper-a= defined in module =util.db= becomes
=util_db_helper-a=.

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn import-modules [form options]
    (let [package-list (import-modules-select-require form)
          form         (parser/drop form (parser/form? 'require))
          modules      (import-modules-load-modules package-list options)
          non-public?  (->> modules
                            (reduce (fn[private-symbols mod]
                                      (-> mod
                                          (parser/peek #(and (symbol? %)
                                                             (-> % meta :private)))
                                          (concat private-symbols))) [])
                            (into #{}))
          form         (import-modules-convert-alias-to-module package-list form)
          violations   (parser/peek form #(non-public? %) #(zip/node (zip/up %)))]
      (when (not (empty? violations))
        (doseq [v violations]
          (warn "non-public-access =>" v))
        (io/exit-failure))
      (shake-concat modules form)))

  (defn import-modules-all [form options]
    (loop [f form]
      (let [expanded (import-modules f options)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

Generates the required runtime for the form by importing the required
modules and concatenate the required runtime from [[*Core][Core]].

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn ferret-runtime [options form]
    (->> (-> form
             (import-modules-all options)
             (expand-reader-macros))
         (shake-concat (read-clojure-file "ferret/runtime.clj"))
         ;; tag form with the build info
         (cons `(~'native-define ~(try
                                    (let [version (io/read-file-from-url "build.info")]
                                      (str "// ferret-lisp " version))
                                    (catch Exception e
                                      (str "// ferret-lisp")))))))
#+end_src

*** Macros

Process some supported reader macros, =@= and =#(some-fn)= and convert
=map= reader forms to Ferret =d-list=.  Maps are zero or more
key/value pairs enclosed in braces: ={:a 1 :b 2}=.

#+name: core-compiler-macro-expansion
#+begin_src clojure :tangle no
  (defn expand-reader-macros [form]
    (-> form
        (parser/transform
         (parser/form? 'clojure.core/deref)
         (fn [f] (cons 'deref (rest f))))
        (parser/transform
         map?
         (fn [x] (cons 'fir-new-map (-> x seq flatten))))))
#+end_src

Prepare form =f= for macro expansion,

#+name: core-compiler-macro-expansion
#+begin_src clojure :tangle no
  (defn macro-normalize [f]
    (parser/transform f
                      (parser/form? 'let)
                      (fn [[_ bindings & body]]
                        `(~'let* ~(apply list bindings) ~@body))))
#+end_src

Macro expansion is done by reading all the macros present in
=src/ferret/runtime.clj= and combining them with user defined macros. They
are evaluated in a temporary namespace, using =parser/transform= we iterate
all the macros used in the code that we are compiling and expand them
in the temporary namespace then the node is replaced with its expanded
form.

#+name: core-compiler-macro-expansion
#+begin_src clojure :tangle no
  (defn expand-macros-single [form]
    (let [core-macros (->> (read-clojure-file "ferret/runtime.clj")
                           (filter (parser/form? 'defmacro)))
          core-macro-symbols (into #{} (map second core-macros))
          form-macros (->> (filter (parser/form? 'defmacro) form)
                           (filter (fn [[_ name]]
                                     (not (core-macro-symbols name)))))
          form-macro-symbols (map second form-macros)
          form (parser/drop form (parser/form? 'defmacro))
          temp-ns (gensym)
          macro-symbols (concat core-macro-symbols form-macro-symbols)]
      
      (create-ns temp-ns)
      (binding [*ns* (the-ns temp-ns)]
        (refer 'clojure.core :exclude (concat macro-symbols ['fn 'def]))
        (use '[ferret.io :only [exit-failure]])
        (use '[ferret.core :only [symbol-conversion]])
        (use '[ferret.parser :only [new-fir-fn]])
        
        (doseq [m (concat core-macros form-macros)]
          (eval m)))

      (let [form (-> form
                     (macro-normalize)
                     (expand-reader-macros)
                     (parser/transform
                      (fn [f]
                        (some true? (map #(parser/form? % f) macro-symbols)))
                      (fn [f]
                        (binding [*ns* (the-ns temp-ns)]
                          (-> (walk/macroexpand-all f)
                              ;;strip ns from symbols
                              (parser/transform symbol? #(-> % name symbol)))))))]
        (remove-ns temp-ns)
        form)))

  (defn expand-macros-aux [form]
    (loop [f form]
      (let [expanded (expand-macros-single f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))

  (def expand-macros (memoize expand-macros-aux))
#+end_src

*** let->fn

=let= forms are transformed into nested functions which are then
called immediately, bindings are setup in the outer function,
expressions are placed in the inner function which takes the bindings
as arguments.

So following form,

#+begin_src clojure :tangle no
  (let->fn '(let* [a 1
                   b 2]
              (+ a b)))
#+end_src

after transformation becomes,

#+begin_src clojure :tangle no
  ((fn* [a__1548] ((fn* [b__1549] (+ a__1548 b__1549)) 2)) 1)
#+end_src

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn let-closure [bindings body]
    (if (empty? bindings)
      `((~'fir-let-fn () ~@body))
      (apply
       (fn close [[arg val] & more]
         (if (empty? more)
           `((~'fir-let-fn [~arg] ~@body) ~val)
           `((~'fir-let-fn [~arg] ~(apply close more)) ~val)))
       (partition 2 bindings))))

  (defn let-assert [bindings body]
    (when (odd? (count bindings))
      (warn
       (str "let requires an even number of forms in binding vector => " bindings))
      (io/exit-failure)))

  (defn let->fn [form]
    (-> form

        (parser/transform (parser/form? 'let*)
                          (fn [[_ bindings & body]]
                            (let-assert bindings body)
                            (let-closure bindings body)))

        (parser/transform (parser/form? 'fir-let-fn)
                          (fn [[_ args & body]]
                            (parser/new-fir-fn :args args :body body)))))
#+end_src

*** do->fn

A similar method is used for the do form, expressions are wrapped in a fn
that takes no parameters and executed in place.

#+begin_src clojure :tangle no
  (do->fn '(do (+ 1 1)))
#+end_src

#+begin_src clojure :tangle no
  ((fn [] (+ 1 1)))
#+end_src

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn do->fn [form]
    (parser/transform form
                      (parser/form? 'do)
                      (fn [f] `(~(parser/new-fir-fn :body (rest f))))))
#+end_src

*** fn->lift

=fn->lift= handles the problem of free variables. Free
variables passed to a nested function must be captured in a closure so
they can be referenced at runtime. The closure conversion
transformation modifies function definitions as necessary to create new
closures.

#+begin_src clojure :tangle no
  (defn make-adder [x]
    (fn [n] (+ x n)))
#+end_src

in the above snippet =x= is a free variable, when the function
=make-adder= returns, it needs to have a way of referencing that
variable when it is used. The way Ferret handles this is that, every
function will pass its arguments to inner functions (if any) it
contains.

#+begin_src clojure :tangle no
  (fn->lift '(fn* [x]
                  (fn* [n] (+ x n))))
#+end_src

Above form will be converted to,

#+begin_src clojure :tangle no
  (fir-defn-heap G__1333  (x) (n)  (+ x n))
  (fir-defn-heap G__1334  ()  (x)  (fir-fn-heap G__1333 x))
  (fir-fn-heap G__1334)
#+end_src

What this means is, define a functor named =G__3154= that holds a
reference to =x=, and another functor =G__1334= that has no
state. When we create an instance of =G__1333= we pass =x= to its
constructor. Since every thing is already converted to fns this
mechanism allows variables to be referenced down the line and solves
the free variable problem.

#+name: core-compiler-transformations 
#+begin_src clojure :tangle no
  (defn fn-defined? [fns env args body]
    (if-let [fn-name (@fns (concat [env args] body))]
      (apply list 'fir-fn-heap fn-name env)))

  (defn define-fn [fns env name args body]
    (let [n (if name
              name
              (gensym "FN__"))]
      (swap! fns assoc (concat [env args] body) n)
      (apply list 'fir-fn-heap n env)))

  (defn fn->lift
    ([form]
     (let [fns  (atom (ordered-map/ordered-map))
           form (fn->lift form fns)
           fns  (map (fn [[body name]] (concat ['fir-defn-heap name] body)) @fns)]
       (concat fns form)))
    ([form fns & [env]]
     (parser/transform
      form
      (parser/form? 'fn*)
      (fn [sig]
        (let [[name args body] (parser/split-fn sig)
              ;; transform named recursion in body
              body (if name
                     (parser/transform
                      body
                      (parser/form? name)
                      (fn [[_ & args]]
                        (cons
                         (apply list 'fir-fn-heap name env)
                         args)))
                     body)
              body (fn->lift body fns (concat args env))
              symbols (parser/symbol-set body)
              env  (->> (set/intersection
                         symbols
                         (into #{} (flatten env)))
                        (into ()))

              args (if (parser/ffi-fn?
                        (filter #(not (parser/form? 'native-declare %)) body))
                     args
                     (parser/transform args
                                       symbol?
                                       (fn [v]
                                         (if (or (not (parser/fn-arg-symbol? v))
                                                 (symbols v))
                                           v '_))))]
          (if-let [n (fn-defined? fns env args body)]
            n
            (define-fn fns env name args body)))))))
#+end_src

*** Symbol Conversion

Some symbols valid in lisp are not valid C++ identifiers. This
transformation converts all symbols that are not legal C++ identifiers
into legal ones.

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn escape-cpp-symbol [s]
    (clojure.string/escape
     (str s)
     {\- \_ \* "_star_" \+ "_plus_" \/ "_slash_"
      \< "_lt_" \> "_gt_" \= "_eq_" \? "_QMARK_"
      \! "_BANG_" \# "_"}))

  (defn symbol-conversion [form]
    (let [c (comp #(symbol (escape-cpp-symbol %))
                  #(cond (= 'not %) '_not_
                         :default %))]
      (parser/transform form symbol? c)))
#+end_src

*** Remove Assertions

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn remove-assertions [options form]
    (if (:release options)
      (do (info "option => release mode")
          (parser/drop form (parser/form? 'assert)))
      form))
#+end_src

*** Optimizations
**** Inline Functions

This optimization trades memory for performance. When a global
variable pointing to a function is defined, memory for that function
is allocated at the start of the program and never released until
program exits even if the said function is called only once in the
program. In order to keep the memory usage low Ferret will replace all
functions calls with new function objects. So every time a function is
called a new function object is created used and released. If
performance is more important than memory usage this optimization can
be disabled using compiler option =--global-functions=. This
optimization can be turned of on a per =def= basis by setting the
metadata of the object to =:volatile= =true=,

#+BEGIN_SRC clojure :tangle no
  (defn ^{:volatile true} no-inline [] 42)
#+END_SRC

#+name: core-compiler-transformations
#+begin_src clojure :tangle no
  (defn inline-defn? [f]
    (and (parser/form? 'def f)
         (-> f second meta :volatile not)
         (parser/form? 'fir-fn-heap
                       (->> f (drop 2) first))))

  (defn fn->inline [options form]
    (if (:global-functions options)
      form
      (let [defns      (->> (parser/peek form inline-defn?)
                            (filter #(= 2 (-> % last count))))
            fn-table   (map (fn [[_ name [_ gensym]]] [name gensym]) defns)
            impl-table (apply hash-map (flatten fn-table))
            defn?      (fn [f]
                         (and (inline-defn? f)
                              (impl-table (second f))))
            invoke     #(if-let [imp (impl-table %)]
                          (list 'fir-fn-heap imp)
                          %)
            no-defn    (reduce (fn[h v] (parser/drop h defn?)) form defns)
            inlined    (reduce (fn[h [name gensym]]
                                 (parser/transform h
                                                   #(or (parser/form? name %)
                                                        (parser/form? 'def %))
                                                   (fn [f] (map invoke f))))
                               no-defn fn-table)]
        (reduce (fn[h [name gensym]]
                  (parser/transform h #(and (symbol? %)
                                            (= % gensym))
                                    (fn [_] (identity name))))
                inlined fn-table))))
#+end_src

**** Tree Shaking

Concats two forms. Shakes the first form by removing any symbols not
present in second form.

In order to keep the generated C++ code compact only the functions used
will be present in the generated source file. Which means if you don't
use =println= anywhere in the code it won't be defined in the final
C++ file, but if you use it, it and everything it uses will be
defined, in the case of =println= it will pull =apply=, =print= and
=newline= with it.

#+name: core-compiler-tree-shaking
#+begin_src clojure
  (defn shake-concat
    ([header form]
     (let [shakeable? (fn [f]
                        (or (parser/form? 'defn f)
                            (parser/form? 'defnative f)))
           header-symbols (->> (parser/peek header seq?)
                               (parser/symbol-set))
           header-fns (->> (parser/peek header shakeable?)
                           (map #(vector (second %) %))
                           (into {}))
           header-non-shakeable (parser/drop header shakeable?)
           form-expanded (expand-macros (concat header-non-shakeable form))
           fns (atom #{})
           _ (shake-concat form-expanded header-fns fns header-non-shakeable)
           header-shaked (parser/drop header (fn [f]
                                               (and (shakeable? f)
                                                    (not (@fns (second f))))))]
       (concat header-shaked form)))
    ([form built-in fns non-shakeable]
     (parser/transform form symbol?
                       #(do
                          (if-let [f (built-in %)]
                            (when (not (@fns %))
                              (swap! fns conj %)
                              (shake-concat (expand-macros (concat non-shakeable f))
                                            built-in fns non-shakeable))) %))))
#+end_src

**** Escape Analysis


     Determines that a certain allocation never escapes the local
     function. This means that allocation can be done on the stack.

#+name: core-compiler-transformations
#+begin_src clojure
  (defn escape-analysis [form]
    (->> (escape-fn-calls form)
         (escape-fn-dispatch)
         (escape-fns)))
#+end_src

***** Function Calls

By default Ferret assumes all functions can escape their scope and
they are allocated on the heap. Functions proven to not escape their
scope are replaced with stack allocated functions.

#+name: core-compiler-escape-analysis
#+begin_src clojure
  (defn escape-fn-calls [form]
    (parser/transform form
                      (fn [f]
                        (and (seq? f)
                             (parser/form? 'fir-fn-heap (first f))))
                      (fn [f]
                        (let [[[_ & fn] & args] f]
                          `((~'fir-fn-stack ~@fn) ~@args)))))
#+end_src

***** Dispatch Functions

User programs has no access to dispatch functions used by multi-arity
functions. They can be safely escaped and replaced by the stack
allocated versions.

#+name: core-compiler-escape-analysis
#+begin_src clojure
  (defn escape-fn-dispatch [form]
    (parser/transform
     form
     (parser/form? 'fir-defn-arity)
     (fn [f]
       (parser/transform f
                         (parser/form? 'fir-fn-heap)
                         (fn [[_ & f]]
                           `(~'fir-fn-stack ~@f))))))
#+end_src

***** Function Classes

Each Ferret =fn= generates a corresponding C++ class that extends a
Ferret Object. If a function can be proven to be only allocated on the
stack in all uses of the said function, it can be replaced with a C++
POD type. This saves program space since said function does not need
to inherit from a Ferret Object.

#+name: core-compiler-escape-analysis
#+begin_src clojure
  (defn escape-fns [form]
    (let [heap-fns (->> (parser/peek form (parser/form? 'fir-fn-heap))
                        (map second)
                        (into #{}))
          stack-fns (->> (parser/peek form (parser/form? 'fir-fn-stack))
                         (map second)
                         (into #{}))
          escapeable-fns (set/difference stack-fns heap-fns)]
      (parser/transform form
                        (fn [f]
                          (and (seq? f)
                               (= (first f) 'fir-defn-heap)
                               (escapeable-fns (second f))))
                        (fn [[_ & f]]
                          `(~'fir-defn-stack ~@f)))))
#+end_src

*** Parser

Ferret programs are read using the Clojure reader via =read-string=,

#+name: core-file-io
#+begin_src clojure :tangle no
  (defn read-clojure-file [f]
    (let [ns (gensym)
          ns-str (str ns)]
      (create-ns ns)
      (binding [*ns* (the-ns ns)]
        (refer 'clojure.core)
        (-> (read-string (str \( (io/read-file f) \)))
            (parser/transform
             symbol?
             #(if (= (namespace %) ns-str)
                (-> % name symbol)
                %))
            ;;replace clojure.core/fn with fn
            ;;replace clojure.core/while with while
            (parser/transform
             (fn [x]
               (and (parser/form? 'quote x)
                    (or (= 'clojure.core/fn    (second x))
                        (= 'clojure.core/defn  (second x))
                        (= 'clojure.core/while (second x)))))
             (fn [[_ s]] `'~(-> s name symbol)))))))
#+end_src

Each transformation happens by walking over the program form. Forms
are selected using =form?= function.

#+begin_src clojure :tangle no
  (form? 'fn* '(fn* [n] (+ x n)))
  ;; true
#+end_src

#+name: core-compiler-parser
#+begin_src clojure :tangle no
  (defn form?
    ([s]
     #(form? s %))
    ([s f]
     (and (seq? f)
          (= (first f) s))))
#+end_src

Returns the set of symbols used in the form.

#+name: core-compiler-parser
#+begin_src clojure :tangle no
  (defn symbol-set [form]
    (->> form flatten (filter symbol?) (into #{})))
#+end_src

Splits a function form into compnents.

#+name: core-compiler-parser
#+begin_src clojure :tangle no
  (defn split-fn [sig]
    (let [name (if (symbol? (second sig)) (second sig) nil)
          sig  (if name (clojure.core/drop 2 sig) (rest sig))
          [args & body] sig]
      [name args body]))
#+end_src

Predicate for checking if function body is a FFI call or not.

#+name: core-compiler-parser
#+begin_src clojure :tangle no
  (defn ffi-fn? [body]
    (and (not (nil? body))
         (not (empty? body))
         (->> (map string? body)
              (every? true?))))
#+end_src

Predicate for checking if a symbol in =fn= arguments is a valid symbol
or not.

#+name: core-compiler-parser
#+begin_src clojure :tangle no
  (defn fn-arg-symbol? [s]
    (and (symbol? s)
         (not= s '&)
         (not= s '_)
         (not= s 'fir-destructure-associative)))
#+end_src

During each pass we iterate over the nodes in the form using one of
three functions, =transform= , =drop= and =peek=. They
all take a s-expression and a predicate. If the predicate returns
true, =transform= will call =f= passing the current node as an argument
and replace that node with =f= 's return value, =drop= on the
other hand does what its name suggests and removes the node when
predicate returns true. =peek= is used to peek at sections of
the form, does not alter the form only returns the list of nodes
matching the predicate.

#+name: core-compiler-parser
#+begin_src clojure :tangle no
  (defn transform [tree pred f]
    (walk/prewalk (fn [form]
                    (if (pred form)
                      (let [new-form (f form)
                            meta (meta form)]
                        (if (and (instance? clojure.lang.IMeta form)
                                 (instance? clojure.lang.IMeta new-form))
                          (with-meta new-form meta)
                          new-form))
                      form))
                  tree))

  (defn drop [tree pred]
    (if (every? true? (map #(pred %) tree))
      (list )
      (loop [loc (zip/seq-zip tree)]
        (if (zip/end? loc)
          (zip/root loc)
          (recur
           (zip/next
            (if (pred (zip/node loc))
              (zip/remove loc)
              loc)))))))

  (defn peek [tree pred & [node-fn]]
    (let [node-fn (if node-fn
                    node-fn
                    #(zip/node %))]
      (loop [loc (zip/seq-zip tree)
             nodes []]
        (if (zip/end? loc)
          nodes
          (recur
           (zip/next loc)
           (if (pred (zip/node loc))
             (conj nodes (node-fn loc))
             nodes))))))
#+end_src

Takes a *fn* form and converts all argument symbols with their unique
replacements. This is needed because most lisp forms are represented
as =fn='s and some forms such as =let= need to be able to shadow
already defined variable names.

#+begin_src clojure
  (fn [a b] (list a b))
  ;;becomes
  (fn [a__1510 b__1511] (list a__1510 b__1511))
#+end_src

#+name: core-compiler-parser
#+begin_src clojure :tangle no
  (defn new-symbol [& parts]
    (let [parts (map #(.replace (str %) "." "_") parts)]
      (symbol (apply str parts))))

  (defn fn-make-unique [args body]
    (if (string?  (->> body
                       (filter #(not (form? 'native-declare %)))
                       first))
      [args body]
      (let [unique-args (->> args
                             flatten
                             (filter fn-arg-symbol?)
                             (map #(new-symbol % (gensym "__"))))
            replace? (->> (interleave (->> args
                                           flatten
                                           (filter fn-arg-symbol?))
                                      unique-args)
                          (apply hash-map))
            body      (transform body #(replace? %) #(replace? %))
            replace?  (merge replace? {'fir-new-map 'fir-destructure-associative})
            args      (transform args #(replace? %) #(replace? %))]
        [args body])))

  (defn new-fir-fn
    ([& {:keys [name args body escape] :or {escape  true
                                            args    []}}]
     (let [name-unique (if name
                         (new-symbol name (gensym "__")))
           [args body] (if escape
                         (fn-make-unique args body)
                         [args body])
           body        (if name-unique
                         (transform body #(= % name) (fn [_] name-unique))
                         body)]
       (if name-unique
         `(fn* ~name-unique ~args ~@body)
         `(fn* ~args ~@body)))))
#+end_src

** Code Generation

The compiler's code generation phase takes a single pass over the
transformed lisp code and outputs C++ code. All Ferret modules and
the program code is amalgamated in to a single source file which
allows the generated code to be compiled as a single translation
unit.This allows many compilers to do optimization's that would not be
possible if the files were compiled separately. Code generation is
done by running =emit= on the final intermediate representation.

#+begin_src clojure :tangle no
  (emit options '(list 1 2 3) (ref {}))
  ;;"run(list,obj<number>(1),obj<number>(2),obj<number>(3))"

  (emit options '(+ 1 2) (ref {}))
  ;;"run(+,obj<number>(1),obj<number>(2))"

  (emit options '(if (< a b)
                   b a)
                (ref {}))
  ;;"((<,b,a) ? a : b)"
#+end_src

#+name: core-compiler-emitter
#+begin_src clojure :tangle no  
  (defmulti emit (fn [_ f _]
                   (cond (parser/form? '(fir_fn_stack list) f)   'fir_inline_list
                         (parser/form? '(fir_fn_stack first) f)  'fir_inline_first
                         (parser/form? '(fir_fn_stack rest) f)   'fir_inline_rest
                         (parser/form? 'fir_defn_heap f)   'fir_defn_heap
                         (parser/form? 'fir_defn_stack f)  'fir_defn_stack
                         (parser/form? 'fir_defn_arity f)  'fir_defn_arity
                         (parser/form? 'fir_fn_heap f)     'fir_fn_heap
                         (parser/form? 'fir_fn_stack f)    'fir_fn_stack
                         (parser/form? 'defobject f)       'defobject
                         (parser/form? 'make_matrix f)     'make_matrix
                         (parser/form? 'native_header f)   'native_header
                         (parser/form? 'native_declare f)  'native_declare
                         (parser/form? 'native_define f)   'native_define
                         (parser/form? 'if f)              'if
                         (parser/form? 'def f)             'def
                         (parser/form? 'fir_new_map f)     'fir_new_map
                         (symbol? f)                 :symbol
                         (keyword? f)                :keyword
                         (number? f)                 :number
                         (nil? f)                    :nil
                         (char? f)                   :char
                         (string? f)                 :string
                         (instance?
                          java.util.regex.Pattern f) :regex-pattern
                         (or (true? f) (false? f))   :boolean
                         (seq? f)                    :invoke-fn
                         :default                    :unsupported-form)))

  (defmethod emit :unsupported-form [_ form _]
    (warn "unsupported form =>" form)
    (io/exit-failure))

  (defn emit-ast [options ast state]
    (reduce (fn[h v] (conj h (emit options v state))) [] ast))
#+end_src

Code generation for a Ferret program is done by running =emit= on all
nodes of the program AST.

#+name: core-compiler-helpers
#+begin_src clojure :tangle no
  (defn append-to! [r ks v]
    (let [cv (reduce (fn[h v] (v h)) @r ks)]
      (swap! r assoc-in ks (conj cv v))
      ""))
#+end_src

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (defn emit-source [form options]
    (let [state (atom {:native-headers []
                       :native-declarations []
                       :objects []
                       :symbol-table #{}
                       :lambdas []
                       :native-defines []})
          ast (compile form options)
          body (emit-ast options ast state)]
      (when (:ast options)
        (pprint/pprint ast))
      (assoc @state :body body)))
#+end_src

*** Object Types

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (defmethod emit :symbol [_ form state] (str form))

  (defmethod emit :string [_ form state]
    (str "obj<string>(\"" (io/escape-string form) "\"," (count form) ")"))

  (defmethod emit :boolean [_ form state]
    (if (true? form)
      (str "cached::true_o")
      (str "cached::false_o")))

  (defmethod emit :nil [_ form state] "nil()")

  (defmethod emit :keyword [_ form _]
    (str "obj<keyword>(" (reduce (fn[h v] (+ h (int v))) 0 (str form)) ")"))

  (defmethod emit :char [_ form state] (str "obj<number>(" (int form) ")"))

  (defmethod emit :number [_ form state] (str "obj<number>(" (double form) ")"))

  (defmethod emit 'fir_new_map [options [_ & kvs] state]
    (let [kvs (partition 2 kvs)
          keys (->> (map first kvs)
                    (map #(emit options % state))
                    (interpose \,))
          vals (->> (map second kvs)
                    (map #(emit options % state))
                    (interpose \,))]
      (str "obj<map_t>("
           "runtime::list(" (apply str keys) "),"
           "runtime::list(" (apply str vals) "))")))

  (defmethod emit :regex-pattern [options regex state]
    (emit options
          (org.apache.commons.lang.StringEscapeUtils/unescapeJava
           (str regex))
          state))
#+end_src

*** Special Forms

Special forms have evaluation rules that differ from standard Ferret
evaluation rules and are understood directly by the compiler. Most
special forms define control structures or perform variable
bindings—things which functions cannot do.

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (defmethod emit 'def [options [_ name & form] state]
    (append-to! state [:symbol-table] name)
    (str "(" name " = " (apply str (emit-ast options form state)) ")"))

  (defmethod emit 'if [options [_ cond t f] state]
    (let [cond (emit options cond state)
          t (emit options t state)
          f (if (nil? f) "nil()" (emit options f state))]
      (apply str "(" cond " ? " t " : " f ")")))

  (defn defobject [name f options]
    (let [def (io/read-file (first f) options)]
      (render-template
       "#ifndef FERRET_OBJECT_$guard$
        #define FERRET_OBJECT_$guard$
         $body$
        #endif"
       :guard       (.toUpperCase (str name))
       :body        def)))

  (defmethod emit 'defobject [options [_ name & spec] state]
    (append-to! state [:objects] (defobject name spec options)))

  (defmethod emit 'make_matrix [options [_ elements] state]
    (let [rows (count elements)
          cols (-> elements first count)
          elements (apply concat elements)
          elements (emit-ast options elements state)
          elements (map #(str "number::to<real_t>(" % ")") elements)
          elements (apply str (interpose \, elements))
          matrix-t (str rows "," cols "," elements)
          matrix-decl (str "obj<matrix_t>(" matrix-t ")")]
      matrix-decl))

  (defmethod emit 'native_header [_ [_ & declarations] state]
    (append-to! state [:native-headers] declarations))

  (defmethod emit 'native_declare [_ [_ declaration] state]
    (append-to! state [:native-declarations] declaration))

  (defmethod emit 'native_define [_ [_ define] state]
    (append-to! state [:native-defines] define))
#+end_src

Inline primitive sequence operations. Some sequence operations such as
=first= / =rest= are implemented as native C++ functions instead of
executing a Ferret =fn= for these operations, these can be replaced
with calls to native implementations resulting in much smaller code.

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (defmethod emit 'fir_inline_list [options [_ & args] state]
    (str "runtime::list(" (apply str (interpose \, (emit-ast options args state))) ")"))

  (defmethod emit 'fir_inline_first [options [_ & seq] state]
    (str "runtime::first(" (apply str (emit-ast options seq state)) ")"))

  (defmethod emit 'fir_inline_rest [options [_ & seq] state]
    (str "runtime::rest(" (apply str (emit-ast options seq state)) ")"))
#+end_src

*** Functions

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (defn norm-fn-env [env]
    (->> env
         (flatten)
         (filter #(and (not (= '& %))
                       (not (= '_ %))
                       (not (= :as %))))))

  (defn new-fn-heap [l]
    (let [n (second l)
          e (norm-fn-env (drop 2 l))]
      (if (empty? e)
        (str "obj<" n ">()")
        (str "obj<" n ">(" (apply str (interpose \, e)) ")"))))

  (defn new-fn-stack [l]
    (let [n (second l)
          e (norm-fn-env (drop 2 l))]
      (if (empty? e)
        (str n "()")
        (str n "(" (apply str (interpose \, e)) ")"))))

  (defn invoke-fn [n args]
    (if (empty? args)
      (str "run(" n ")")
      (str "run(" n ","  (apply str (interpose \, args))")")))
#+end_src

Initialize function arguments. Clojure style sequential destructuring
is supported.

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (declare destructure-arguments)

  (defn destructure-nth-rest [parent pos]
    (reduce (fn[h v] (str v "(" h ")")) parent (repeat pos "runtime::rest")))

  (defn destructure-nth [parent pos]
    (str "runtime::first(" (destructure-nth-rest parent pos) ")"))

  (defn destructure-get [name parent key]
    (str "ref " name " = "
         parent ".cast<map_t>()->val_at(runtime::list(" (emit nil key nil) "));"))

  (defn new-fn-arg [name parent pos]
    (let [value (destructure-nth parent pos)
          tag   (-> name meta :tag)]
      (condp = tag
        'bool_t     (str "bool " name " = " "bool(" value ")")
        'real_t     (str "real_t " name " = " "number::to<real_t>(" value ")")
        'number_t   (str "number_t " name " = " "number::to<number_t>(" value ")")
        'byte       (str "byte " name " = " "number::to<byte>(" value ")")
        'std_string (str "std::string " name " = " "string::to<std::string>(" value ")")
        'matrix     (str "matrix &" name " = " "value<matrix>::to_reference(" value ")")
        (str "ref " name " = " value))))

  (defn new-fn-var-arg [name parent pos]
    (str "ref " name " = " (destructure-nth-rest parent pos)))

  (defn destructure-associative [name parent pos]
    (let [tmp-name (gensym)]
      [(new-fn-arg tmp-name parent pos)
       (map (fn [[s k]] (destructure-get s tmp-name k)) name)]))

  (defn destructure-sequential [args parent]
    (reduce
     (fn [h [pos name]]
       (let [name (cond
                    (symbol? name)
                    (new-fn-arg name parent pos)
                    
                    (parser/form? 'fir_destructure_associative name)
                    (let [[_ & args ] name
                          args (->> args
                                    (partition 2)
                                    (remove #(= (first %) '_))
                                    flatten
                                    (apply hash-map))]
                      (destructure-associative args parent pos))
                    
                    (coll?   name)
                    (destructure-arguments name (destructure-nth parent pos)))]
         (conj h name))) [] args))

  (defn destructure-var-args [name parent pos]
    (cond (nil?     name)  []
          (symbol?  name)  (new-fn-var-arg name parent pos)
          (coll?    name)  (let [tmp-name (gensym)]
                             [(new-fn-var-arg tmp-name parent pos)
                              (destructure-arguments name tmp-name)])))

  (defn destructure-as-arg [name parent]
    (if (symbol?     name)
      (new-fn-var-arg name parent 0)
      []))

  (defn destructure-arguments
    ([args]
     (->> (destructure-arguments args "_args_") flatten))
    ([args parent]
     (let [t-args         args
           args           (take-while #(and (not= % '&) (not= % :as)) t-args)
           var-args       (->> t-args (drop-while #(not= % '&)) second)
           as-arg         (->> t-args (drop-while #(not= % :as)) second)
           args-indexed   (->>  args
                                (map-indexed (fn [p v] [p v]))
                                (filter #(not= (second %) '_)))
           as-arg         (destructure-as-arg as-arg parent)
           var-args       (destructure-var-args var-args parent (count args))
           args           (destructure-sequential args-indexed parent)]
       [args var-args as-arg])))
#+end_src

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (defmethod emit :invoke-fn [options [fn & args] state]
    (invoke-fn (emit options fn state) (emit-ast options args state)))

  (defmethod emit 'fir_fn_heap [_ f state]
    (new-fn-heap f))

  (defmethod emit 'fir_fn_stack [_ f state]
    (new-fn-stack f))

  (defn emit-lambda [options name env args body state]
    (let [native-declarations (filter (parser/form? 'native_declare) body)
          return (fn [b] (conj (pop b) (str "return " (last b))))
          body (filter #(not (parser/form? 'native_declare %)) body)
          body (cond  (empty? body)
                      ["return nil()"]
                      ;; multi arity dispacth
                      (parser/form? 'fir_defn_arity (first body))
                      (return
                       (emit options (first body) state))
                      ;; ffi call
                      (parser/ffi-fn? body)
                      (let [buffer (StringBuilder.)]
                        (doseq [b body]
                          (.append buffer b))
                        (let [body (.toString buffer)]
                          (cond (.contains body "__result")
                                ["var __result" body "return __result"]
                                (.contains body "return")
                                [body]
                                :default [body "return nil()"])))
                      ;; s-expression
                      :default (return
                                (emit-ast options body state)))
          env  (norm-fn-env env)
          vars (destructure-arguments args)]
      (doseq [dec native-declarations] 
        (emit options dec state))
      {:name name :env env :args args :vars vars :body body}))

  (defmethod emit 'fir_defn_heap [options [_ name env args & body] state]
    (append-to! state [:lambdas] (emit-lambda options name env args body state)))

  (defmethod emit 'fir_defn_stack [options [_ name env args & body] state]
    (append-to! state [:lambdas] (-> (emit-lambda options name env args body state)
                                     (assoc :stack true))))
#+end_src

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (defmethod emit 'fir_defn_arity [_ [_ switch default] state]
    (let [default (if default
                    (str (new-fn-stack default) ".invoke(_args_)")
                    "nil()")
          switch  (render-template
                   "switch(runtime::count(_args_)) {
                    $fns: {fn|
                      case $fn.case$ :
                         return $fn.fn$.invoke(_args_); };separator=\"\n\"$
                    }"
                   :fns (map (fn [[s f]] {:fn (new-fn-stack f) :case s}) switch))]
      [switch default]))
#+end_src

#+name: core-compiler-emitter
#+begin_src clojure :tangle no
  (defn lambda-definitions [fns]
    (render-template
     "$fns: {fn|
        $if(!fn.stack)$
         class $fn.name$ final : public lambda_i{
        $else$
         class $fn.name$  \\{
        $endif$
          $fn.env:{const var $it$;} ;separator=\"\n\"$
        public:
          $if(fn.env)$
            explicit $fn.name$ ($fn.env:{ref $it$} ;separator=\",\"$) :
              $fn.env:{$it$($it$)} ;separator=\",\"$ { }
          $endif$

          var invoke (ref _args_) const $if(!fn.stack)$ final $endif$ ;
        };};separator=\"\n\n\"$"
     :fns fns))

  (defn lambda-implementations [fns]
    (render-template
     "$fns: {fn|
        inline var $fn.name$::invoke (ref _args_) const {
          (void)(_args_);
          $fn.vars:{$it$;} ;separator=\"\n\"$
     
          $fn.body:{$it$;} ;separator=\"\n\"$
        }
       };separator=\"\n\n\"$"
     :fns fns))
#+end_src

*** Program

Generated C++ code has the following structure, (All Ferret code is
defined within =ferret= namespace, all Ferret macros starts with
=FERRET_=, all user defined functions are defined in file name
namespace.)

 - Detect Hardware
 - Include files
 - Ferret Header (src/ferret/runtime.h)
 - Ferret Native Runtime Prototypes (runtime::first, runtime::rest
   etc.)
 - Native Declarations
 - Object Definitions
 - Symbol Definitions
 - Native Runtime Implementations
 - Lambda Prototypes
 - Lambda Implementations
 - Ferret Main
 - Hardware Dependent Main Functions

#+name: core-compiler-emitter
#+begin_src clojure :tangle no :noweb yes
  (defn program-template [source options]
    (let [{:keys [body lambdas symbol-table native-headers objects
                  native-declarations native-defines]} source
          native-headers (->> native-headers flatten (into #{}))
          file-ns        (-> options :base-name escape-cpp-symbol)
          main           (render-template
                          (io/read-file "ferret/main.cpp")
                          :file       file-ns)]
      (render-template
       "
          $native_defines:{$it$} ;separator=\"\n\"$
          $native_headers:{#include \"$it$\"} ;separator=\"\n\"$

          #ifndef FERRET_RUNTIME_H
          #define FERRET_RUNTIME_H
           $ferret_h$
          #endif

          // Objects
          namespace ferret{
           $objects:{$it$} ;separator=\"\n\"$
          }

          // Symbols
          namespace $file${
           using namespace ferret;

           #if defined(ARDUINO)
             typedef ferret::boolean boolean;
           #endif

           $symbols:{var $it$;} ;separator=\"\n\"$
          }

          $native_declarations:{$it$} ;separator=\"\n\"$

          // Runtime Implementations
          #ifndef FERRET_RUNTIME_CPP
          #define FERRET_RUNTIME_CPP
           $ferret_cpp$
          #endif

          // Lambda Prototypes
          namespace $file${
            $lambda_classes:{$it$} ;separator=\"\n\"$
          }

          // Command Line Arguments
          #if defined(FERRET_STD_LIB) &&               \\
              !defined(FERRET_DISABLE_CLI_ARGS) &&     \\
              !defined(FERRET_DISABLE_STD_MAIN)
            ferret::var _star_command_line_args_star_;
          #endif

          // Lambda Implementations
          namespace $file${
            $lambda_bodies:{$it$} ;separator=\"\n\"$
          }

          // Program Run
          namespace $file${
           void main(){
            $body:{$it$;} ;separator=\"\n\"$ 
           }
          }

          $ferret_main$"
       :file                 file-ns
       :native_defines       native-defines
       :ferret_h             (io/read-file "ferret/runtime.h")
       :native_headers       native-headers
       :objects              objects
       :symbols              symbol-table
       :native_declarations  native-declarations
       :ferret_cpp           (io/read-file "ferret/runtime.cpp")
       :lambda_classes       (lambda-definitions lambdas)
       :lambda_bodies        (lambda-implementations lambdas)
       :body                 (filter #(not (empty? %)) body)
       :ferret_main          main)))
#+end_src

** Main
*** Options

   Default compile options, 

  #+name: core-compiler-main
  #+begin_src clojure
    (defn compile-options [& [options]]
      (merge {:compiler "g++"
              :compiler-options ["-std=c++11"]
              :source-extension io/extension-cpp
              :base-name "solution"
              :binary-file "solution"}
             options))

    (defn file-name [options]
      (str (:base-name options) "." (:source-extension options)))

    (defn cpp-file-name [options]
      (str (:output-path options) (file-name options)))
  #+end_src

   Read the /cpp/ file parse build options embedded in
   it. =configure-ferret!= macro can embed build options into C++
   files. These can be used later when build the binary.

  #+name: core-compiler-main
  #+begin_src clojure
    (defn compile-options-parse-source [file]
      (try
        (let [program (slurp file)
              options (->> program
                           (re-seq #"(?s)build-conf-begin.*?//(.*?)// build-conf-end")
                           (map second)
                           (map #(.replaceAll % "//" ""))
                           (map #(.replaceAll % "\n" " "))
                           (map read-string))
              keys (->> options
                        (map #(keys %))
                        flatten
                        (into #{})
                        (into []))
              combine (fn [key]
                        (->> options
                             (reduce (fn[h v]
                                       (if (nil? (key v))
                                         h
                                         (apply merge (flatten [h (key v)])))) #{})
                             (into [])))]
          (compile-options
           (reduce (fn[h v]
                     (assoc h v (combine v))) {} keys)))
        (catch Exception e
          (compile-options {}))))
  #+end_src

   Takes the compiler CLI arguments and a file name, returns a map of
   build options.

  #+name: core-compiler-main
  #+begin_src clojure
    (defn build-specs [input args]
      (fn []
        (let [args             (fn [k]
                                 (->> args :options k))
              output           (if (args :output)
                                 (args :output)
                                 input)
              output-path      (io/file-path output)
              output-extension (if (args :output) 
                                 (io/file-extension (args :output))
                                 io/extension-cpp)
              base-name        (io/file-base-name output)
              input-path       (io/file-path input)
              output-file      (io/make-file output-path base-name output-extension)
              binary-file      (if (args :binary) 
                                 (args :binary)
                                 base-name)
              default-options  (compile-options-parse-source output-file)]
          (-> default-options
              (assoc :input-file         input)
              (assoc :base-name          base-name)
              (assoc :path               input-path)
              (assoc :output-path        output-path)
              (assoc :source-extension   output-extension)
              (assoc :binary-file        binary-file)
              (assoc :ast                (args :ast))
              (assoc :compile-program    (args :compile))
              (assoc :release            (args :release))
              (assoc :format-code        (not (args :disable-formatting)))
              (assoc :global-functions   (args :global-functions))
              (assoc :extra-source-files
                     (cond (not (empty? (:arguments args)))
                           (:arguments args)
                           (not (empty? (:extra-source-files default-options)))
                           (:extra-source-files default-options)
                           :default []))))))
  #+end_src

*** Compile to C++

   Compile the form to C++,

  #+name: core-compiler-main
  #+begin_src clojure
    (defn compile->cpp [form options]
      (let [file-name (cpp-file-name options)
            source    (emit-source form options)
            program   (program-template source options)]
        (io/write-to-file file-name program)
        (info "compiled" "=>" file-name)
        true))
  #+end_src

*** Compile to Binary

    Pick compiler to use. If set, use the value of =CXX= environment
    variable, if not set use the default compiler =gcc=,

  #+name: core-compiler-main
  #+begin_src clojure
    (defn cxx-compiler [options]
      (let [compiler    (if (System/getenv "CXX")
                          (System/getenv "CXX")
                          (:compiler options))
            env-options (if (System/getenv "CXXFLAGS")
                          (seq (.split (System/getenv "CXXFLAGS") " ")))
            options     (->> (:compiler-options options) (map str))]
        [compiler (concat options env-options)]))
  #+end_src

    Compiler build command,

  #+name: core-compiler-main
  #+begin_src clojure
    (defn cxx-command [options]
      (if (:command options)
        (flatten ["/usr/bin/env" "sh" "-c" (:command options)])
        (let [[cxx cxx-options] (cxx-compiler options)
              source-files  (map #(let [extension (io/file-extension %)]
                                    [(cond (= extension "c") ["-x" "c"]
                                           (= extension "c++") ["-x" "c++"]
                                           :default "")
                                     %])
                                 (:extra-source-files options))]
          (flatten [cxx cxx-options source-files
                    ["-x" "c++"] (file-name options)
                    ["-o" (:binary-file options)]]))))
  #+end_src

   Run the compiler on the generated source and create the binary,

  #+name: core-compiler-main
  #+begin_src clojure
    (defn compile->binary [options]
      (let [command (cxx-command options)]
        (info "building" "=>" (apply str (interpose " " command)))
        (let [build-dir (:output-path options)
              ret (try
                    (with-sh-dir build-dir
                      (apply sh command))
                    (catch Exception e
                      (warn (str "error executing C++ compiler."))
                      (warn (str "" (.getMessage e)))
                      (io/exit-failure)))]
          (if (not= 0 (:exit ret))
            (do (warn "build error")
                (warn (:err ret))
                (io/exit-failure)))
          true)))
  #+end_src

*** Build Solution

    Compile and build program,

   #+name: core-compiler-main
   #+begin_src clojure
     (defn clang-format [options]
       (let [file (cpp-file-name options)
             source (try (with-sh-dir "./"
                           (sh "clang-format" "-style" "{Standard: Cpp11}" file))
                         (catch Exception e nil))]
         (if source
           (do (info "formatting code")
               (io/write-to-file file (:out source))))))

     (defn build-solution [spec-fn]
       (let [{:keys [input-file compile-program format-code path]} (spec-fn)]
         (info "dir =>" path)
         (info "file =>" input-file)
         
         (compile->cpp (read-clojure-file input-file) (spec-fn))
         
         (when format-code
           (clang-format (spec-fn)))
         
         (when compile-program
           (compile->binary (spec-fn)))))
   #+end_src

*** Compiler Main

    Compiler options,

   #+name: core-compiler-main
   #+begin_src clojure
     (def program-options
       [["-i" "--input FILE"         "Input File" :default "./core.clj"]
        ["-o" "--output FILE"        "Output C++ File"]
        ["-b" "--binary FILE"        "Output Binary File"]
        ["-c" "--compile"            "Compile to Binary"]
        [nil  "--deps"               "Checkout Input Dependencies"]
        ["-w" "--watch-input"        "Automatically Recompile Input File on Change"]
        [nil  "--release"            "Compile in Release Mode. Strip Debug Information"]
        [nil  "--disable-formatting" "Disables Output File Formatting Using clang-format"]
        [nil  "--global-functions"   "Disables inline-global-fns Optimization"]
        [nil  "--ast"                "Print Intermediate AST"]
        ["-h" "--help"               "Print Help"]])
   #+end_src

   Compiler /main/,

   #+name: core-compiler-main
   #+begin_src clojure
     (defn -main [& args]
       (try
         (let [args (parse-opts args program-options)
               {:keys [help input deps watch-input]} (:options args)]

           (when help
             (try
               (let [version (io/read-file "build.info")]
                 (print "ferret-lisp" version))
               (catch Exception e
                 (print "ferret-lisp")))
             (println )
             (println )
             (println (:summary args))
             (io/exit-success))

           (when (not (io/file-exists input))
             (warn "no input file")
             (io/exit-failure))

           (let [specs (build-specs input args)]

             (when deps
               (try
                 (checkout-deps (:path (specs)))
                 (catch Exception e
                   (io/exit-failure)))
               (io/exit-success))
             
             (if (not watch-input)
               (build-solution specs)
               (do (watcher/watcher [input]
                                    (watcher/rate 1000)
                                    (watcher/on-change
                                     (fn [_] (build-solution specs))))
                   @(promise)))
             (shutdown-agents))
           (io/exit-success))
         (catch Exception e
           (stacktrace/print-stack-trace e 10))))
   #+end_src

** I/O

Common I/O operations.

#+name: core-main-io
#+begin_src clojure :tangle no
  (def extension-cpp "cpp")

  (defn os-name []
    (let [os (-> (System/getProperty "os.name") .toLowerCase)]
      (cond (.contains os "win")      :windows
            (.contains os "mac")      :mac
            (or (.contains os "nix")
                (.contains os "nux")
                (.contains os "aix")) :unix
            (.contains os "sunos")    :solaris)))

  (defn exit-failure []
    (System/exit 1))

  (defn exit-success []
    (System/exit 0))

  (defn read-file-from-url [f]
    (with-open [in (.getResourceAsStream (ClassLoader/getSystemClassLoader) f)
                rdr (BufferedReader. (InputStreamReader. in))]
      (apply str (interpose \newline (line-seq rdr)))))

  (defn read-file [f & [options]]
    (try
      (read-file-from-url f)
      (catch Exception e-url
        (try
          (if (nil? options)
            (FileUtils/readFileToString (file f))
            (FileUtils/readFileToString (file (str (:path options) f))))
          (catch Exception e-path
            (warn "error reading =>" f)
            (exit-failure))))))

  (defn write-to-file [f s]
    (FileUtils/writeStringToFile (file f) (.trim s)))

  (defn escape-string [s]
    (org.apache.commons.lang.StringEscapeUtils/escapeJava s))

  (defn file-path [file]
    (let [path (str (org.apache.commons.io.FilenameUtils/getPrefix file)
                    (org.apache.commons.io.FilenameUtils/getPath file))]
      (if (empty? path)
        "./"
        path)))

  (defn file-extension [f]
    (org.apache.commons.io.FilenameUtils/getExtension f))

  (defn file-base-name [f]
    (org.apache.commons.io.FilenameUtils/getBaseName f))

  (defn file-exists [f]
    (.exists (file f)))

  (defn make-file [p n e]
    (file (str p n "." e)))
#+end_src

* Runtime

Runtime needed to support [[*Core][Core]]. [[Object System][Object system]], [[*Memory%20Management][Memory Management]] etc.

** Object System
*** Base

All our types are derived from the base Object type. Which is a
=typedef= of =obj::base<FERRET_RC_POLICY,FERRET_ALLOCATOR>=. See
[[Reference Counting]] for available reference counting policies and
[[Memory Allocation]] for available allocation policies.

#+name: runtime-native-object
#+begin_src c++ :tangle no
  template<typename>
  void type_id(){}

  using type_id_t = void(*)();
  typedef type_id_t type_t;

  class var;
  typedef var const & ref;
  class seekable_i;

  template <typename rc>
  class object_i : public rc{
  public:
    object_i() { }
    virtual ~object_i() { };
    
    virtual type_t type() const = 0;
    
  #if !defined(FERRET_DISABLE_STD_OUT)
    virtual void stream_console() const {
      runtime::print("var#");
      const void* addr = this;
      runtime::print(addr);
    }
  #endif
    
    virtual bool equals(ref) const;

    virtual seekable_i* cast_seekable_i() { return nullptr; }

    void* operator new(size_t, void* ptr){ return ptr; }
    void  operator delete(void * ptr){ FERRET_ALLOCATOR::free(ptr); }
  };

  typedef object_i<FERRET_RC_POLICY> object;
#+end_src

A =pointer_t= holds a pointer to a Ferret object. Default =pointer_t=
does nothing and delegates all requests to a regular =object *=.  See
[[Pointers]] for rationale.

#+name: runtime-native-object
#+begin_src c++ :tangle no
#if !defined(FERRET_POINTER_T)
  #define FERRET_POINTER_T memory::pointer<object>
#endif

typedef FERRET_POINTER_T pointer_t;
#+end_src

A =var= holds a pointer to an object, everything is passed around as
=vars= it is responsible for incrementing/decrementing the reference
count, when it reaches zero it will automatically free the object.

#+name: runtime-native-object
#+begin_src c++ :tangle no
  class var{
  public:
    explicit inline var(object* o = nullptr) : obj(o) { inc_ref(); }
    inline var(ref o)   : obj(o.obj) { inc_ref(); }
    inline var(var&& o) : obj(o.detach()) { }
      
    ~var() { dec_ref(); }

    inline var& operator=(var&& other){
      if (this != &other){
        dec_ref();
        obj = other.detach();
      }
      return *this;
    }
    
    inline var& operator= (ref other){
      if (obj != other.obj){
        dec_ref();
        obj = other.obj;
        inc_ref();
      }
      return *this;
    }

    bool equals (ref) const;

    bool operator==(ref other) const { return equals(other); }

    bool operator!=(ref other) const { return !equals(other); }
    
    operator bool() const;

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const {
      if (obj != nullptr )
        obj->stream_console();
      else
        runtime::print("nil");
    }
  #endif
        
    inline object* get() const { return obj; }
    
    template<typename T>
    inline T* cast() const { return static_cast<T*>((object*)obj); }

    inline bool is_type(type_t type) const {
      if (obj)
        return (static_cast<object*>(obj)->type() == type);
      return false;
    }

    inline bool is_nil() const { return (obj == nullptr); }

  private:
    object* detach(){
      object* _obj = obj;
      obj = nullptr;
      return _obj;
    }
    
    inline void inc_ref(){
  #if !defined(FERRET_DISABLE_RC)
      // Only change if non-null
      if (obj) obj->inc_ref();
  #endif
    }
      
    inline void dec_ref(){
  #if !defined(FERRET_DISABLE_RC)
      // Only change if non-null
      if (obj){
        // Subtract and test if this was the last pointer.
        if (obj->dec_ref()){
          delete obj;
          obj = nullptr;
        }
      }
  #endif
    }
      
    pointer_t obj;
  };

  template<>
  inline seekable_i* var::cast<seekable_i>() const { return obj->cast_seekable_i(); }

  template <typename rc>
  bool object_i<rc>::equals(ref o) const {
    return (this == o.get());
  }

  #ifdef FERRET_STD_LIB
  std::ostream &operator<<(std::ostream &os, var const &v) {
    v.stream_console();
    return os;
  }
  #endif
#+end_src

All object allocations are done using =obj= function. It will return a
new =var= containing a pointer to an [[Object System][Object]]. =nil= is represented as a
=var= pointing to =nullptr=.

#+begin_src c++ :tangle no
  var two = obj<number>(2);
  var some_nil = nil();
#+end_src

#+name: runtime-native-object
#+begin_src c++ :tangle no
  template<typename FT, typename... Args>
  inline var obj(Args... args) {
    void * storage = FERRET_ALLOCATOR::allocate<FT>();
    return var(new(storage) FT(args...));
  }

  inline var nil(){
    return var();
  }
#+end_src

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn identity [x] x)
#+end_src

*** Objects
**** Boolean

The boolean type has two values, false and true, which represent the
traditional boolean values.

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject boolean "ferret/obj/boolean_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/boolean_o.h
  class boolean final : public object {
    const bool value;
  public:

    type_t type() const final { return type_id<boolean>; }

    bool equals(ref o) const final {
      return (value == o.cast<boolean>()->container());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      if (value)
        runtime::print("true");
      else
        runtime::print("false");
    }
  #endif

    explicit boolean(bool b) : value(b) {} 

    bool container() const {
      return value;
    }
  };

  namespace cached{
    const var true_o = obj<::ferret::boolean>(true);
    const var false_o = obj<::ferret::boolean>(false);
  }

  var::operator bool() const {
    if (obj == nullptr)
      return false;
    else if (obj->type() == (type_t)type_id<boolean>)
      return cast<boolean>()->container();
    else
      return true;
  }

  bool var::equals (ref other) const {
    if (get() == other.get())
      return true;

    if (!is_nil() && !other.is_nil()){

      if (runtime::is_seqable(*this) && runtime::is_seqable(other))
        return get()->equals(other);
      else if (obj->type() != other.get()->type())
        return false;
      else
        return get()->equals(other);
    
    }else
      return false;
  }
#+end_src

**** Pointer / Value

A =pointer= object keeps a reference to a C++ pointer.

#+begin_src c++
  var num = obj<pointer>(new int(42));
  int *ptr = pointer::to_pointer<int>(ptr);
#+end_src

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject pointer "ferret/obj/pointer_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/pointer_o.h
  class pointer final : public object {
    void * _payload;
  public:


    type_t type() const final { return type_id<pointer>; }

    bool equals(ref o) const final {
      return (_payload == o.cast<pointer>()->payload());
    }

    explicit pointer(void* p) : _payload(p) {} 

    void* payload() const {
      return _payload;
    }
    template<typename T> static T* to_pointer(ref v){
      return ((T *) v.cast<pointer>()->payload());
    }
    template<typename T> static T& to_reference(ref v){
      return (*(pointer::to_pointer<T>(v)));
    }
  };
#+end_src

A =value= object keeps a native object. Useful when working with
modern C++ libraries that use smart pointers for memory management.

#+name: value-test-helpers
#+begin_src clojure :tangle no
  (native-declare "class data{ 
                     int x;
                   public: 
                      
                     explicit data(int _x) : x(_x) {} 

                     int  content() { return x; }
                     void inc() { x++; }
                   };")

  (defn make-data [x]
    "return obj<value<data>>(number::to<number_t>(x))")

  (defn get-data [x]
    "return obj<number>((number_t) value<data>::to_value(x).content());")

  (defn inc-data [x]
    "data & d = value<data>::to_reference(x);
     d.inc();")
#+end_src

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject value "ferret/obj/value_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/value_o.h
  template <typename T>
  class value final : public object {
    T _value;
   public:

    type_t type() const final { return type_id<value>; }

    template <typename... Args>
    explicit value(Args&&... args) : _value(static_cast<Args&&>(args)...) { } 

    T to_value() const {
      return _value;
    }
    
    static T to_value(ref v){
      return v.cast<value<T>>()->to_value();
    }

    T & to_reference() {
      return _value;
    }
    
    static T & to_reference(ref v) {
      return v.cast<value<T>>()->to_reference();
    }  
  };

  typedef value<matrix> matrix_t;
#+end_src

**** Number

The number type represents real (double-precision floating-point)
numbers. Ferret has no integer type. On systems without hardware
support for floating point Ferret programs can be configured to use
fixed point numbers. (See [[Numeric%20Tower][Numeric Tower]] runtime.)

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject number "ferret/obj/number_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/number_o.h
  class number final : public object {
    const real_t n;
  public:

    type_t type() const final { return type_id<number>; }

    bool equals(ref o) const final {
      return (runtime::abs(n - number::to<real_t>(o)) < real_epsilon);
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      runtime::print(n);
    }
  #endif

    template<typename T> explicit number(T x) : n(real_t(x)) {} 

    template<typename T> static T to(ref v){
      return (T)v.cast<number>()->n;
    }
  };
#+end_src

**** Sequence

Sequences are collections. They implement the seekable interface
directly. count is O(n). conj puts the item at the front of the list.

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject empty_sequence "ferret/obj/empty_sequence_o.h")
  (defobject sequence "ferret/obj/sequence_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/empty_sequence_o.h
  class empty_sequence final : public object {

    type_t type() const final { return type_id<empty_sequence>; }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      runtime::print("()");
    }
  #endif
  };

  namespace cached{
    const var empty_sequence_o = obj<::ferret::empty_sequence>();
  }
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/sequence_o.h
  class sequence final : public object, public seekable_i {
    const var next;
    const var data;
  public:

    type_t type() const final { return type_id<sequence>; }

    bool equals(ref o) const final {
      return seekable_i::equals(var((object*)this), o);
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      runtime::print("(");
      data.stream_console();
      for_each(i, next){
        runtime::print(" ");
        i.stream_console();
      }
      runtime::print(")");
    }
  #endif

    explicit sequence(ref d = nil(), ref n = nil()) : next(n), data(d) {} 

    virtual seekable_i* cast_seekable_i() { return this; }

    var cons(ref x) final {
      return obj<sequence>(x, var(this));
    }
    var first() final {
      return data;
    }
    var rest() final {
      return next;
    }
    template <typename T>
    static T to(ref){
      T::unimplemented_function;
    }
    template <typename T>
    static var from(T){
      T::unimplemented_function; return nil();
    }

  };
  namespace runtime {
    inline var list() { 
      return cached::empty_sequence_o;
    }
    inline var list(ref v) { 
      return obj<sequence>(v,cached::empty_sequence_o);
    }
                      
    template <typename... Args>
    inline var list(ref first, Args const & ... args) { 
      return obj<sequence>(first, list(args...));
    }
  }

  #ifdef FERRET_STD_LIB
  typedef ::std::vector<var>  std_vector;

  template <> std_vector sequence::to(ref v) { 
    std_vector ret;
    for_each(i, v)
      ret.push_back(i);
    return ret;
  }

  template <> var sequence::from(std_vector v) { 
    var ret;
    std::vector<var>::reverse_iterator rit;
    // cppcheck-suppress postfixOperator
    for(rit = v.rbegin(); rit != v.rend(); rit++)
      ret = runtime::cons(*rit,ret);
    return ret;
  }
  #endif
#+end_src

**** Lazy Sequence

Ferret supports lazily evaluated sequences. This means that sequence
elements are not available ahead of time and produced as the result of
a computation. The computation is performed as needed when lazy
sequence is iterated. By default Ferret =lazy_sequence=s does not
cache their values unless forced using [[doall]].

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject lazy_sequence "ferret/obj/lazy_sequence_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/lazy_sequence_o.h
  class lazy_sequence final : public object, public seekable_i {
    mutex lock;
    bool cache;
    var thunk;
    var data;
    var seq;

  public:

    type_t type() const final { return type_id<lazy_sequence>; }

    bool equals(ref o) const final {
      return seekable_i::equals(var((object*)this), o);
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      var seq = var((object*)this);
      var tail = runtime::rest(seq);

      runtime::print("(");
      if (tail)
        runtime::first(seq).stream_console();

      for_each(i, tail){
        runtime::print(" ");
        i.stream_console();
      }
      runtime::print(")");
    }
  #endif

    explicit lazy_sequence(ref t, bool c = false) : cache(c), thunk(t) {} 
    explicit lazy_sequence(ref d, ref t, bool c = false) : cache(c), thunk(t), data(d) {} 

    virtual seekable_i* cast_seekable_i() { return this; }

    var cons(ref x) final {
      lock_guard guard(lock);

      if (data.is_nil())
        return obj<lazy_sequence>(x, thunk, cache);

      return obj<sequence>(x, var((object*)this));
    }

    var first() final {
      lock_guard guard(lock);

      if (cache){
        if (data.is_nil()){
          seq = run(thunk);
          data = runtime::first(seq);
          seq = runtime::rest(seq);
        }

        return data;
      }else{
        if (data.is_nil())
          return runtime::first(run(thunk));

        return data;
      }
    }
    
    var rest() final {
      lock_guard guard(lock);

      if (cache){
        if (seq.is_nil())
          seq = run(thunk);

        if (seq.is_nil())
          seq = runtime::list();

        return seq;
      }else{
        var seq = run(thunk);

        if (data.is_nil())
          return runtime::rest(seq);

        if (seq.is_nil())
          return runtime::list();

        return seq;
      }
    }
  };
#+end_src

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defn new-lazy-seq [f]
    "return obj<lazy_sequence>(f);")

  (defmacro lazy-seq [& body]
    `(new-lazy-seq (fn [] ~@body)))
#+end_src

**** D-List

D-List, or Detached List, analogous to an A-List or a P-List are  more
suited to embedded systems. For quite small values of n it is more
efficient in terms of time and space than more sophisticated
strategies such as hash tables.

A D-list is a cons of a list of keys and a list of values, i.e.:

#+BEGIN_EXAMPLE
  ((key1 key2 ...) val1 val2 ...)
#+END_EXAMPLE

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject d-list "ferret/obj/d_list_o.h")

  (defn new-d-list-aux [keys vals]
    "return obj<d_list>(keys, vals);")

  (defmacro new-d-list [& args]
    (let [kvs (partition 2 args)
          keys (map first kvs)
          vals (map second kvs)]
      `(new-d-list-aux
        (list ~@keys) (list ~@vals))))

  (defn assoc [m k v]
    "return m.cast<map_t>()->assoc(k,v);")

  (defn dissoc [m k]
    "return m.cast<map_t>()->dissoc(k);")

  (defn get [m & args]
    "return m.cast<map_t>()->val_at(args);")

  (defn vals [m]
    "return m.cast<map_t>()->vals();")

  (defn keys [m]
    "return m.cast<map_t>()->keys();")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/d_list_o.h
  class d_list final : public lambda_i, public seekable_i {

    var data;

    var dissoc_aux(ref k) const {
      ref keys = runtime::first(data);
      var values = runtime::rest(data);

      var new_keys;
      var new_values;
      
      for_each(i, keys){
        if ( i == k)
          continue;
        new_keys = runtime::cons(i, new_keys);
        new_values = runtime::cons(runtime::first(values), new_values);
        values = runtime::rest(values);
      }
        
      return runtime::cons(new_keys,new_values);
    }
    
   public:

    type_t type() const final { return type_id<d_list>; }

    bool equals(ref o) const final {
      return seekable_i::equals(var((object*)this), o);
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      data.stream_console();
    }
  #endif

    explicit d_list() : data(runtime::list(runtime::list())) { }
    explicit d_list(ref l) : data(l) { }
    
    var assoc(ref k, ref v) const {
      ref map = dissoc_aux(k);
      ref keys = runtime::first(map);
      ref values = runtime::rest(map);

      return obj<d_list>(runtime::cons(runtime::cons(k,keys),
                                       runtime::cons(v,values)));
    }

    var dissoc(ref k) const {
      return obj<d_list>(dissoc_aux(k));
    }
    
    var val_at(ref args) const {
      ref key = runtime::first(args);
      ref not_found = runtime::first(runtime::rest(args));

      ref keys = runtime::first(data);
      var values = runtime::rest(data);

      for_each(i, keys){
        if (key == i)
          return runtime::first(values);

        values = runtime::rest(values);
      }
      
      if (!not_found.is_nil()){
        return not_found;
      }else{
        return nil();  
      }
    }

    var invoke(ref args) const final {
      return val_at(args);
    }

    var vals () const { return runtime::rest(data);}
    var keys () const { return runtime::first(data);}

    virtual seekable_i* cast_seekable_i() { return this; }
    
    var cons(ref v) final {
      return runtime::list(v,data);
    }
    
    var first() final {
      ref keys = runtime::first(data);
      ref values = runtime::rest(data);
      return runtime::list(runtime::first(keys),runtime::first(values));
    }
    
    var rest() final {
      ref keys = runtime::first(data);
      ref values = runtime::rest(data);

      if(runtime::rest(keys).is_type(type_id<empty_sequence>))
        return runtime::list();
      
      return obj<d_list>(runtime::cons(runtime::rest(keys),runtime::rest(values)));
    }
  };

  template<>
  inline var obj<d_list>(var keys, var vals) {
    void * storage = FERRET_ALLOCATOR::allocate<d_list>();
    return var(new(storage) d_list(runtime::cons(keys,vals)));
  }

  #if !defined(FERRET_MAP_TYPE)
  typedef d_list map_t;
  #endif

#+end_src

**** Keyword

Keywords are symbolic identifiers that evaluate to themselves. They
provide very fast equality tests. A =keyword= holds a simple hash of
the keyword as =number_t=.

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject keyword "ferret/obj/keyword_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/keyword_o.h
class keyword final : public lambda_i {
  const number_t hash;

  static constexpr number_t hash_key(const char * key){
    return *key ? (number_t)*key + hash_key(key + 1) : 0;
  }
  
public:

  type_t type() const final { return type_id<keyword>; }

  bool equals(ref o) const final {
    return (hash == keyword::to<number_t>(o));
  }

#if !defined(FERRET_DISABLE_STD_OUT)
  void stream_console() const final {
    runtime::print("keyword#");
    runtime::print(hash);
  }
#endif

  explicit keyword(number_t w) : hash(w) {} 
  explicit keyword(const char * str): hash(hash_key(str)) { }

  var invoke(ref args) const {
    ref map = runtime::first(args);
    ref map_args = runtime::cons(var((object*)this), runtime::rest(args));

    if (map.is_type(type_id<map_t>)){
      return map.cast<map_t>()->val_at(map_args);
    }

    return nil();
  }

  template<typename T> static T to(ref v){
    return (T)v.cast<keyword>()->hash;
  }
};
#+end_src

**** String

Ferret strings are represented as a [[Sequence]] of numbers each
representing a character in the string. This scheme uses more memory
but provides low memory fragmentation and ability to use sequence
operations on strings.

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject string "ferret/obj/string_o.h")
#+end_src

Defines a function that returns a given string. Can be used to return
strings from functions. Due to the way FFI interface is designed
strings can not be returned from functions because they are
interpreted as FFI calls.

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defn new-string
    ([& ss]
     ((fn [s] "return obj<string>(s);")
      (reduce (fn [h v] (concat h v)) ss))))
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/string_o.h
  class string final : public object, public seekable_i {
    var data;

    void from_char_pointer(const char * str, int length){
      for (int i = --length; i >= 0; i--)
        data = runtime::cons(obj<number>((number_t)str[i]),data);
    }
    
  public:

    type_t type() const final { return type_id<string>; }

    bool equals(ref other) const final {
      return (container() == other.cast<string>()->container());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      for_each(it, data)
        runtime::print(number::to<char>(it));
    }
  #endif

    explicit string() : data(nullptr) {} 

    explicit string(ref s) : data(s) {}

    explicit string(const char * str) {
      int length = 0;
      for (length = 0; str[length] != '\0'; ++length);
      from_char_pointer(str,length);
    }

    explicit string(const char * str,number_t length) { from_char_pointer(str,length); }

    var container() const {
      return data;
    }

    virtual seekable_i* cast_seekable_i() { return this; }

    var cons(ref x) final {
      return obj<string>(runtime::cons(x,data));
    }

    var first() final {
      return runtime::first(data);
    }

    var rest() final {
      ref r = runtime::rest(data);

      if (!r.is_type(type_id<empty_sequence>))
        return obj<string>(r);

      return runtime::list();
    }

    template <typename T>
    static T to(ref){
      T::unimplemented_function;
    }

    static size_t into(ref str, char buff[]){
      size_t i = 0;

      for_each(c, str){
        buff[i] = number::to<char>(c);
        i++;
      }

      buff[i] = '\0';

      return i;
    }
  };

  #ifdef FERRET_STD_LIB
  template<>
  inline var obj<string>(std::string s) {
    void * storage = FERRET_ALLOCATOR::allocate<string>();
    return var(new(storage) string(s.c_str(), (number_t)s.size()));
  }

  template <> ::std::string string::to(ref v) { 
    ::std::stringstream ss;
    for_each(it, v.cast<string>()->container())
      ss << number::to<byte>(it);
    return ss.str();
  }
  #endif
#+end_src

**** Atom

Atoms provide a way to manage shared, synchronous, independent state.
The intended use of atom is to hold one of Ferret’s immutable data
structures.  You create an atom with =atom=, and can access its state
with =deref/@=.  To change the value of an atom, you can use =swap!=
or =reset!=. Changes to atoms are always free of race conditions.

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject atomic "ferret/obj/atomic_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/atomic_o.h
  class atomic final : public deref_i {
    mutex lock;
    var data;
    public:


    type_t type() const final { return type_id<atomic>; }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      runtime::print("atom<");
      data.stream_console();
      runtime::print(">");
    }
  #endif

    explicit atomic(ref d) : data(d) {} 

    var swap(ref f, ref args){
      lock_guard guard(lock);
      data = f.cast<lambda_i>()->invoke(runtime::cons(data, args));
      return data;
    }

    var reset(ref newval){
      lock_guard guard(lock);
      data = newval;
      return data;
    }
    
    var deref() {
      lock_guard guard(lock);
      return data;
    }
  };
#+end_src


Operations on =atoms=

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defn atom [x]
    "return obj<atomic>(x)")

  (defn swap! [a f & args]
    "return a.cast<atomic>()->swap(f,args);")

  (defn reset! [a newval]
    "return a.cast<atomic>()->reset(newval);")
#+end_src

**** Future

Takes a body of expressions and yields a future object that will
invoke the body in another thread, and will cache the result and
return it on all subsequent calls to =deref=. If the computation has
not yet finished, calls to =deref= will block.

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject async "ferret/obj/async_o.h")

  (defmacro future [& body]
    `(_future_ (fn [] ~@body)))

  (defn _future_ [f] "return obj<async>(f);")

  (defn future-done? [f]
    "if (f.cast<async>()->is_ready())
       return cached::true_o;
     else
       return cached::false_o;")
#+end_src

Divert *depricated* thread macro which runs the given lambda in a
thread to =future=,

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn thread [f]
    "return obj<async>(f);")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/async_o.h
  #ifdef FERRET_STD_LIB
  class async final : public deref_i {
    mutex lock;
    bool cached;
    var value;
    var fn;
    std::future<var> task;

    class rc_guard{
      object *obj;
    public:
      explicit rc_guard(const rc_guard &) = delete;
      explicit rc_guard(object *o) : obj(o) { };
      ~rc_guard() { obj->dec_ref(); }
    };

    var exec() {
      rc_guard g(this);
      return run(fn);
    }
    
    public:

    explicit async(ref f) :
      cached(false), value(nil()), fn(f), 
      task(std::async(std::launch::async, [this](){ return exec(); })){ inc_ref(); }

    type_t type() const final { return type_id<async>; }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      runtime::print("future<");
      fn.stream_console();
      runtime::print(">");
    }
  #endif

    bool is_ready(){
      lock_guard guard(lock);
      if (cached)
        return true;
      return task.wait_for(std::chrono::seconds(0)) == std::future_status::ready;
    }

    void get(){
      if (!cached){
        value = task.get();
        cached = true;
      }
    }

    var deref() {
      lock_guard guard(lock);
      get();
      return value;
    }
  };
  #endif
#+end_src

**** Delay

Takes a body of expressions and yields a Delay object that will invoke
the body only the first time it is forced (with =force= or =deref=),
and will cache the result and return it on all subsequent force
calls.

#+name: runtime-clojure-objects
#+begin_src clojure :tangle no
  (defobject delayed "ferret/obj/delayed_o.h")

  (defn _delay_ [f]
    "return obj<delayed>(f)")

  (defmacro delay [& body]
    `(_delay_ (fn [] ~@body)))

  (defn delay? [d]
    "if (d.is_type(type_id<delayed>))
       return cached::true_o;
     else
       return cached::false_o;")

  (defn force [d] @d)
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/delayed_o.h
  class delayed final : public deref_i {
    mutex lock;
    var fn;
    var val;
    
    public:

    type_t type() const final { return type_id<delayed>; }

    explicit delayed(ref f) : fn(f) {} 
    
    var deref() {
      lock_guard guard(lock);
      if (!fn.is_nil()){
        val = fn.cast<lambda_i>()->invoke(nil());
        fn = nil();
      }
      return val;
    }
  };
#+end_src

*** Interfaces

Just like Clojure, Ferret is written in terms of
abstractions. Currently there are abstractions for sequences,
collections and callability.

**** Seekable

All sequence functions (first, second, rest etc.) use this interface
to iterate seekable containers.

#+name: runtime-clojure-interfaces
#+begin_src clojure :tangle no
  (defobject seekable_i "ferret/obj/seekable_i.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/seekable_i.h
  class seekable_i {
  public:

    virtual var cons(ref x) = 0;
    virtual var first() = 0;
    virtual var rest() = 0;

    static bool equals(var lhs, var rhs) {

      for(;;lhs = runtime::rest(lhs), rhs = runtime::rest(rhs)){

        ref lf = runtime::first(lhs);
        ref rf = runtime::first(rhs);

        if (lf.is_nil() && rf.is_nil())
          return true;
        
        if (lf != rf)
          return false;
      }
    }
  };
#+end_src

C++ API for the interface,

#+name: runtime-native-prototypes
#+begin_src c++ :tangle no
  namespace runtime {
    var list(ref v);
    template <typename... Args>
    var list(ref first, Args const & ... args);

    var first(ref coll);
    var rest(ref coll);
    var cons(ref x, ref seq);
    var nth(ref seq, number_t index);
    var nthrest(ref seq, number_t index);
    size_t count(ref seq);
    var doall(ref coll);
    bool is_seqable(ref seq);
  }

#define for_each(x,xs) for(var _tail_ = runtime::rest(xs), x = runtime::first(xs);     \
                           !_tail_.is_nil();                                           \
                           x = runtime::first(_tail_), _tail_ = runtime::rest(_tail_))
#+end_src

Implementations for the C++ Seekable API,

#+name: runtime-native-implementations
#+begin_src c++ :tangle no
  namespace runtime{
    var first(ref coll){
      if (coll.is_nil() || coll.is_type(type_id<empty_sequence>))
        return nil();
      return coll.cast<seekable_i>()->first();
    }

    var rest(ref coll){
      if (coll.is_nil() || coll.is_type(type_id<empty_sequence>))
        return nil();
      return coll.cast<seekable_i>()->rest();
    }

    var cons(ref x, ref coll){
      if (coll.is_nil() || coll.is_type(type_id<empty_sequence>))
        return runtime::list(x);
      return coll.cast<seekable_i>()->cons(x);
    }

    var nth(ref seq, number_t n_index){
      number_t index = 0;
      
      for_each(i, seq){
       if (n_index == index)
         return i;
       index++;
      }

      return nil();
    }

    var nthrest(ref seq, number_t index){
      var ret = seq;
      for(number_t i = 0; i < index; i++)
        ret = runtime::rest(ret);

      if (ret.is_nil())
        return runtime::list(); 

      return ret;
    }
    
    size_t count(ref seq){
      size_t acc = 0;

      for_each(v, seq){
        (void)v;
        acc++;
      }
      return acc;
    }

    var doall(ref coll){
      class walk : public lambda_i {
        var seq;
      public:
        explicit walk(ref s) : seq(s) { }
        var invoke(ref) const {
          if (seq.is_nil() || seq.is_type(type_id<empty_sequence>))
            return nil();
          
          var tail = obj<lazy_sequence>(obj<walk>(runtime::rest(seq)), true);
          return runtime::cons(runtime::first(seq), tail);
        }
      };

      return run(obj<walk>(coll));
    }
    
    bool is_seqable(ref seq){
      if(seq.cast<seekable_i>())
        return true;
      else
        return false;
    }
  }
#+end_src

**** Lambda

Every lambda object implements the =lambda_i= interface. All lambdas are
executed via =invoke= method that takes a sequence of vars as argument
or =nil()= if there are non, this allows us to execute them in a
uniform fashion.

#+name: runtime-clojure-interfaces
#+begin_src clojure :tangle no
  (defobject lambda_i "ferret/obj/lambda_i.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/lambda_i.h
  struct lambda_i : public object {
    virtual var invoke(ref args) const = 0;
    type_t type() const { return type_id<lambda_i>; }
  };
#+end_src

Function invocation,

#+name: runtime-native-prototypes
#+begin_src c++ :tangle no
  template<typename T, typename... Args>
  inline var run(T const & fn, Args const & ... args);
        
  template<typename T>
  inline var run(T const & fn);

  template<>
  inline var run(ref);

  namespace runtime{
    inline var apply(ref fn, ref argv);
  }
#+end_src

#+name: runtime-native-implementations
#+begin_src c++ :tangle no
  template<typename T, typename... Args>
  inline var run(T const & fn, Args const & ... args) {
    return fn.invoke(runtime::list(args...));
  }

  template<typename T>
  inline var run(T const & fn) {
    return fn.invoke(nil());
  }

  template<>
  inline var run(ref fn) {
    return fn.cast<lambda_i>()->invoke(nil());
  }

  template<typename... Args>
  inline var run(ref fn, Args const & ... args) {
    return fn.cast<lambda_i>()->invoke(runtime::list(args...));
  }

  namespace runtime {
    inline var apply(ref f, ref argv){
      if (runtime::rest(argv).is_type(type_id<empty_sequence>))
        return f.cast<lambda_i>()->invoke(runtime::first(argv));

      struct{
        var operator()(ref seq) const {
          ref head = runtime::first(seq);

          if (head.is_nil())
            return cached::empty_sequence_o;
  
          if (head.cast<seekable_i>())
            return head;

          return runtime::cons(head, (*this)(runtime::rest(seq)));
        }
      } spread;
      
      return f.cast<lambda_i>()->invoke(spread(argv));
    }
  }
#+end_src

**** Deref

#+name: runtime-clojure-interfaces
#+begin_src clojure :tangle no
  (defobject deref_i "ferret/obj/deref_i.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/deref_i.h
  class deref_i : public object {
   public:

    virtual var deref() = 0;
  };
#+end_src

Operations on =deref_i=

#+name: runtime-clojure-interfaces
#+begin_src clojure :tangle no
  (defn deref [a]
    "return a.cast<deref_i>()->deref();")
#+end_src

** Memory Management

Ferret is designed to be used on embedded systems which means,

 - Latency is more important then through put.
 - Can't have unpredictable GC pauses when running.

So the default memory management is done using reference
counting. Unlike other lisp implementations, Ferret supports various
memory management schemes,

 - *malloc/free* - Allocations are handled by the system
   implementation. (Default memory management.)
 - *Memory Pooling* - On memory constraint systems such as
   microcontrollers Ferret can use a memory pool to avoid heap
   fragmentation and calling malloc/free. Effectively running with
   no heap, allocating all memory at compile time on the stack.
 - *Third party allocators* (i.e tcmalloc)
 - *Third party garbage collectors* (i.e The Boehm-Demers-Weiser
   conservative garbage collector.) - All memory is managed by a third
   party GC disables reference counting.

To enable memory pooling,

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_MEMORY_POOL_SIZE 256)
#+END_EXAMPLE

This will create a pool object as a global variable that holds an
array of =256= =size_t=s. By default page size is
=sizeof(size_t)=. This can be changed using,

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_MEMORY_POOL_PAGE_TYPE byte)
#+END_EXAMPLE

Memory pooling is intended for embedded systems where calling
malloc/free is not desired.

Steps for using *tcmalloc* on Mac OS X, install dependencies, 

#+BEGIN_EXAMPLE
  brew install google-perftools
#+END_EXAMPLE

Then from your program you can link to it using,

#+begin_src clojure
  (configure-ferret! :compiler-options ["-std=c++11"
                                        "-L/usr/local/Cellar/gperftools/2.4/lib/"
                                        "-ltcmalloc"])
#+end_src

Steps for using *Boehm garbage collector* on Linux, install dependencies,

#+BEGIN_EXAMPLE
  apt-get install libgc-dev
#+END_EXAMPLE

Enable and configure GC

#+begin_src clojure
  (configure-runtime! FERRET_MEMORY_BOEHM_GC TRUE)
  (configure-ferret! :command "g++ -std=c++11 core.cpp -lgc")
#+end_src

*** Pointers

Each =var= holds a reference to a Ferret object using one of the
pointer types below. Default =pointer_t= does nothing and delegates
all requests to a regular =object *=. Using this scheme allows
optional use of tagged pointers on systems that support them.

#+name: runtime-native-pointers
#+begin_src c++ :tangle no
namespace memory {
  template <typename T>
  class pointer{
    T *ptr;

  public:

    inline explicit pointer(T *p = nullptr) : ptr(p){ }
    inline operator T* () const { return ptr; }

    inline pointer& operator= (T *other){
      ptr = other;
      return *this;
    }

    inline T *operator->() const { return ptr; }
  };
}
#+end_src

*** Allocators
**** Pool

When =FERRET_MEMORY_POOL_SIZE= is defined Ferret programs will use a
memory pool called =memory::allocator::program_memory= instead of
=mallac=, =free= for memory allocation, depending on the pool size
Ferret will allocate =N= bytes of memory on stack and all memory
allocation happens in this memory pool useful when working with very
limited amount of memory, such as micro controllers where you want
complete control over the memory and you need deterministic timing
requirements.

This allocator uses a bit-map to keep track of the used and unused
memory locations for its book-keeping purposes. This allocator will
make use of 1 single bit to keep track of whether it has been
allocated or not. A bit 0 indicates free, while 1 indicates
allocated. This has been done so that you can easily check a
collection of bits for a free block. This kind of Bitmapped strategy
works best for single object allocations ,we do not need to choose any
size for the block which will be represented by a single bit. This
will be the size of the parameter around which the allocator has been
parameterized. Thus, close to optimal performance will result.

#+name: runtime-native-allocator-pool
#+begin_src c++ :tangle no
  #if defined(FERRET_MEMORY_POOL_SIZE) && !defined(FERRET_ALLOCATOR)

   #define FERRET_ALLOCATOR memory::allocator::pool

   #if !defined(FERRET_MEMORY_POOL_PAGE_TYPE)
    #define FERRET_MEMORY_POOL_PAGE_TYPE size_t
   #endif

  namespace memory{
    namespace allocator{

      memory_pool<FERRET_MEMORY_POOL_PAGE_TYPE, FERRET_MEMORY_POOL_SIZE> program_memory;

      class pool{
      public:

        static void init(){ }
        
        static inline void*  allocate(size_t s){
          return program_memory.allocate(s);
        }

        template<typename FT>
        static inline void* allocate(){ return allocate(sizeof(FT)); }
        
        static inline void   free(void * ptr){ program_memory.free(ptr); }
      };
    }
  }
  #endif
#+end_src 

Pool allocator uses circular first-fit strategy, when =allocate= is
called the pool will scan the memory pool using the =used= bit array
to find a block of memory big enough to satisfy the request. If found,
it will the mark the region as used and return a pointer from =pool=
array to the user which points to the memory block.

When a =free= request is received, we resolve the pointer in to the
memory pool read the book keeping information on how much memory
is allocated to this pointer and set these pages to unused.

Memory pool has several advantages, it will avoid fragmentation,
function related to each other will always keep their data close
to each other in the array which improves data locality.

#+name: runtime-native-allocator-pool-implementation
#+begin_src c++ :tangle no
  #ifdef FERRET_MEMORY_POOL_SIZE
  namespace memory{
    namespace allocator{
      template<typename page_t, size_t pool_size,
               typename bitset_word_t = FERRET_BITSET_WORD_TYPE>
      struct memory_pool {
        bitset<pool_size, bitset_word_t> used;
        page_t pool[pool_size];
        size_t next_ptr;

        memory_pool() : pool{0}, next_ptr(0) { }

        inline size_t scan(size_t n_pages, size_t from_page = 0) const {
          for(;;){
            size_t begin = used.ffr(from_page);
            size_t end   = begin + n_pages;

            if (end > pool_size)
              return pool_size;

            if (used.ffs(begin, end) >= end)
              return begin;

            from_page = end;
          }
        }

        void *allocate(size_t req_size){
          req_size = align_of(req_size, sizeof(page_t)) + sizeof(page_t);
          size_t n_pages = req_size / sizeof(page_t);
          size_t page   = scan(n_pages, next_ptr);

          if (page == pool_size){
            page = scan(n_pages);
            if (page == pool_size)
              return nullptr;
          }

          pool[page] = (page_t)n_pages;
          next_ptr = page + n_pages;
          used.flip(page, next_ptr);

          return &pool[++page];
        }

        void free(void *p){
          ptrdiff_t begin = (static_cast<page_t *>(p) - pool) - 1;
          ptrdiff_t end = begin + (ptrdiff_t)pool[begin];
          used.flip((size_t)begin, (size_t)end);
        }
      };
    }
  }
  #endif
#+end_src

**** LibGC

When =FERRET_MEMORY_BOEHM_GC= is defined Ferret programs will use
Boehm-Demers-Weiser's GC is a garbage collecting storage
allocator. The collector automatically recycles memory when it
determines that it can no longer be used. 

Code must be linked against the GC library. On most UNIX platforms,
depending on how the collector is built, this will be gc.a or
libgc.{a,so}.

#+name: runtime-native-allocators
#+begin_src c++ :tangle no
  #ifdef FERRET_MEMORY_BOEHM_GC

  #define FERRET_ALLOCATOR memory::allocator::gc
  #define FERRET_DISABLE_RC true

  #include <gc.h>

  namespace memory{
    namespace allocator{
      
      class gc{
      public:

        static void init(){ GC_INIT(); }
        
        static inline void* allocate(size_t s){
  #ifdef FERRET_DISABLE_MULTI_THREADING
          return GC_MALLOC(s);
  #else
          return GC_MALLOC_ATOMIC(s);
  #endif
        }

        template<typename FT>
        static inline void* allocate(){ return allocate(sizeof(FT)); }
      
        static inline void  free(void * ptr){ }
      };
    }
  }
  #endif
#+end_src 

**** System

[[Object]]s are allocated from system implementation. (Default memory
allocator used.)

#+name: runtime-native-allocators
#+begin_src c++ :tangle no
  #if !defined(FERRET_ALLOCATOR)

  #define FERRET_ALLOCATOR memory::allocator::system

  namespace memory{
    namespace allocator{

      class system{
      public:

        static void init(){ }

        static inline void* allocate(size_t s){ return ::malloc(s); }

        template<typename FT>
        static inline void* allocate(){ return allocate(sizeof(FT)); }

        static inline void  free(void * ptr){ ::free(ptr); } 
      };
    }
  }
  #endif
#+end_src 

**** Synchronized

Synchronizes access to other allocators.

#+name: runtime-native-allocators
#+begin_src c++ :tangle no
  namespace memory{
    namespace allocator{
      class synchronized{
        static mutex lock;
      public:

        static void init(){ FERRET_ALLOCATOR::init(); }

        static inline void* allocate(size_t s){
          lock_guard guard(lock);
          return FERRET_ALLOCATOR::allocate(s);
        }

        template<typename FT>
        static inline void* allocate(){ return allocate(sizeof(FT)); }

        static inline void  free(void * ptr){
          lock_guard guard(lock);
          FERRET_ALLOCATOR::free(ptr);
        }
      };
    }
  }
#+end_src 

Enable synchronized access,

#+name: runtime-native-allocators
#+begin_src c++ :tangle no
  #if  !defined(FERRET_DISABLE_MULTI_THREADING)

    #if defined(FERRET_MEMORY_POOL_SIZE) || defined(FERRET_HARDWARE_ARDUINO)
      mutex memory::allocator::synchronized::lock;
      #undef  FERRET_ALLOCATOR
      #define FERRET_ALLOCATOR memory::allocator::synchronized
    #endif

  #endif
#+end_src 

**** Allocator API

User defined allocators are supported. A Ferret allocator is a class
with three static functions,

 - =init()= - Initializes the allocator.
 - =allocate<T>()= - Allocates Ferret object T.
 - =free(void*)= - Frees the memory.

Allocators are defined seperately in header files. They can then be
used by including the header files.

#+begin_src c++ :mkdirp yes :tangle src/test/core/allocator_user.h
  #include <stdlib.h>

  struct allocator_user{
    static bool loaded;

    static void init(){ loaded = true; }

    static inline void* allocate(size_t s){ return ::malloc(s); }

    template<typename FT>
    static inline void* allocate(){ return allocate(sizeof(FT)); }

    static inline void  free(void * ptr){ ::free(ptr); } 
  };

  bool allocator_user::loaded = false;

  #define FERRET_ALLOCATOR allocator_user
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/core/allocator_api.clj
  (native-header "allocator_user.h")

  (assert (cxx "__result = obj<boolean>(allocator_user::loaded)"))
#+end_src 

Helper functions for user defined allocators.

#+name: runtime-native-allocator-helpers
#+begin_src c++ :tangle no
  namespace memory{
    inline size_t align_of(uintptr_t size, size_t align){
      return (size + align - 1) & ~(align - 1);
    }

    template<class T>
    size_t align_of(const void * ptr) {
      return align_of(reinterpret_cast<uintptr_t>(ptr), sizeof(T));
    }
      
    inline size_t align_req(uintptr_t size, size_t align){
      size_t adjust = align - (size & (align - 1));
        
      if(adjust == align)
        return 0;
      return adjust;
    }

    template<class T>
    size_t align_req(const void * ptr) {
      return align_req(reinterpret_cast<uintptr_t>(ptr), sizeof(T));
    }

    template <typename... Ts>
    constexpr size_t max_sizeof() {
      return runtime::max(sizeof(Ts)...);
    }
  }
#+end_src 

**** Alloca

=alloca= is a special allocator used by the *compiler*. If a variable
can be proven to not escape its scope, storage for it can be allocated
on the *stack* instead of the heap.

#+name: runtime-native-allocator-alloca
#+begin_src c++ :tangle no
#undef alloca

template<typename T>
class alloca {

  byte memory [sizeof(T)];
  
public:
  
  template<typename... Args>
  inline explicit alloca(Args... args) {
    (new(memory) T(args...))->inc_ref();
  }

  inline operator object*() {
    return (object*)memory;
  }
};

#+end_src

*** Reference Counting

Garbage collection is handled by reference counting. Reference count
is kept within the [[Base][obj::base]] using one of the following reference
counting policies.

 - =atomic_rc= - Atomic reference counting. (using =std::atomic<unsigned int>=)
 - =rc= - Non Atomic reference counting. (using =unsigned int=)
 - =no_rc= - No reference counting.

#+name: runtime-native-reference-counting
#+begin_src c++ :tangle no
  #if !defined(FERRET_RC_POLICY)
  namespace memory {
    namespace gc {

  #if !defined(FERRET_RC_TYPE)
    #define FERRET_RC_TYPE unsigned int
  #endif
      
  #if defined(FERRET_DISABLE_RC)

  #define FERRET_RC_POLICY memory::gc::no_rc
      
      class no_rc{
      public:

        inline void inc_ref() { }
        inline bool dec_ref() { return false; }
      };

  #else

      template<typename T>
      class rc{
      public:
        rc() : ref_count(0) {}

        inline void inc_ref() { ref_count++; }
        inline bool dec_ref() { return (--ref_count == 0); }
      
      private:
        T ref_count;
      };    

      #if defined(FERRET_DISABLE_MULTI_THREADING) || !defined(FERRET_STD_LIB)
        #define FERRET_RC_POLICY memory::gc::rc<FERRET_RC_TYPE>
      #endif
      
      #if defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_MULTI_THREADING)
        #define FERRET_RC_POLICY memory::gc::rc<::std::atomic<FERRET_RC_TYPE>>
      #endif
  #endif
    }
  }
  #endif
#+end_src 

** Numeric Tower

In the interest of simplicity Ferret supports only one type of number:
floating point numbers. By default these are double precision floating
point numbers. However Ferret programs can easily be recompiled to
support any real number type the system supports.

#+name: runtime-native-number-config-macros
#+begin_src c++ :tangle no
  #if !defined(FERRET_NUMBER_TYPE)
     #define FERRET_NUMBER_TYPE int
  #endif

  #if !defined(FERRET_REAL_TYPE)
     #define FERRET_REAL_TYPE   double
  #endif

  #if !defined(FERRET_REAL_EPSILON)
     #define FERRET_REAL_EPSILON   0.0001
  #endif

    int req_real_precision(double t) {
      return ((-1 * (int)log10(t)));
    }

    typedef FERRET_NUMBER_TYPE  number_t;                   // Whole number Container.
    typedef FERRET_REAL_TYPE    real_t;                     // Real number Container.
    const   real_t              real_epsilon(FERRET_REAL_EPSILON);
    const   int                 real_precision = req_real_precision(FERRET_REAL_EPSILON);
#+end_src

*** Math

Math functions.

#+name: runtime-native-math
#+begin_src c++ :tangle no
  namespace runtime{
    #undef min
    #undef max
    #undef abs

    template <typename T>
    static constexpr T max(T a, T b) {
      return a < b ? b : a;
    }

    template <typename T, typename... Ts>
    static constexpr T max(T a, Ts... bs) {
      return max(a, max(bs...));
    }
    
    template<typename T>
    constexpr T min(T a, T b){
      return ((a) < (b) ? (a) : (b));
    }

    template <typename T, typename... Ts>
    static constexpr T min(T a, Ts... bs) {
      return min(a, min(bs...));
    }

    template<typename T>
    constexpr T abs(T a){
      return ((a) < (T)0 ? -(a) : (a));
    }
  }
#+end_src

*** Fixed Point Math

A fixed point number, like a floating point number, is an approximate
representation of a rational number. Unlike floating point numbers
exponent in a fixed point numbers is constant, this allows fixed point
numbers to be represented internally as integers and the operations on
fixed point numbers can be performed using integer arithmetic. This
can often improve the speed of arithmetic operation on embedded
systems without a built in FPU.

Fixed point numbers can be enabled by overriding the
=FERRET_REAL_TYPE= definition. Following defines fixed point numbers
as 32 bit integers with 8 bits used as fractional part.

#+begin_src clojure
  (configure-runtime! FERRET_REAL_TYPE "ferret::fixed_real<32,8>")
#+end_src

or you can automatically calculate required fraction bits using a
literal. Following defines a 32 bit =fixed_real= with 0.01 fractional
accuracy using 6 bits for fraction.

#+begin_src clojure
  (configure-runtime! FERRET_REAL_TYPE "ferret::fixed_real<32,0.01_QN>")
#+end_src

#+name: runtime-native-fixed-point-real
#+begin_src c++ :tangle no
  #if !defined(__clang__)
  constexpr auto operator "" _QN(long double x) -> int {
    return (int)::floor(::log(1.0/(double)x)/::log(2));
  }
  #endif

  template<int bits> struct fixed_real_container;
  template<> struct fixed_real_container<8>  { typedef int8_t  base_type;
                                               typedef int16_t next_type; };
  template<> struct fixed_real_container<16> { typedef int16_t base_type;
                                               typedef int24_t next_type; };
  template<> struct fixed_real_container<24> { typedef int24_t base_type;
                                               typedef int32_t next_type; };
  template<> struct fixed_real_container<32> { typedef int32_t base_type;
                                               typedef int64_t next_type; };
  template<> struct fixed_real_container<64> { typedef int64_t base_type;
                                               typedef int64_t next_type; };

  #pragma pack(push, 1)
  template<int bits, int exp>
  class fixed_real {
    typedef fixed_real fixed;
    typedef typename fixed_real_container<bits>::base_type base;
    typedef typename fixed_real_container<bits>::next_type next;

    base m;
    static const int N      = (exp - 1);
    static const int factor = 1 << N;

    template<typename T>
    inline base from(T d) const { return (base)(d * factor); }

    template<typename T>
    inline T to_rational() const { return T(m) / factor; }

    template<typename T>
    inline T to_whole() const { return (T)(m >> N); }
      
  public:

    //from types
    explicit fixed_real( )           : m(0) { }
    template<typename T>
    explicit fixed_real(T v)         : m(from<T>(v)) {}

    template<typename T>
    fixed& operator=(T v)        { m = from<T>(v); return *this; }
      
    //to types
    template<typename T>
    operator T()           const { return to_whole<T>();    }
    operator double()      const { return to_rational<double>(); }
      
    // operations
    fixed& operator+= (const fixed& x) { m += x.m; return *this; }
    fixed& operator-= (const fixed& x) { m -= x.m; return *this; }
    fixed& operator*= (const fixed& x) { m = (base)(((next)m * (next)x.m) >> N); return *this; }
    fixed& operator/= (const fixed& x) { m = (base)(((next)m * factor) / x.m); return *this; }
    fixed& operator*= (int x)          { m *= x; return *this; }
    fixed& operator/= (int x)          { m /= x; return *this; }
    fixed  operator-  ( )              { return fixed(-m); }
      
    // friend functions
    friend fixed operator+ (fixed x, const fixed& y) { return x += y; }
    friend fixed operator- (fixed x, const fixed& y) { return x -= y; }
    friend fixed operator* (fixed x, const fixed& y) { return x *= y; }
    friend fixed operator/ (fixed x, const fixed& y) { return x /= y; }
      
    // comparison operators
    friend bool operator== (const fixed& x, const fixed& y) { return x.m == y.m; }
    friend bool operator!= (const fixed& x, const fixed& y) { return x.m != y.m; }
    friend bool operator>  (const fixed& x, const fixed& y) { return x.m > y.m; }
    friend bool operator<  (const fixed& x, const fixed& y) { return x.m < y.m; }
    friend bool operator>= (const fixed& x, const fixed& y) { return x.m >= y.m; }
    friend bool operator<= (const fixed& x, const fixed& y) { return x.m <= y.m; }

  #if defined(FERRET_STD_LIB)
    friend std::ostream& operator<< (std::ostream& stream, const fixed& x) {
      stream << (double)x;
      return stream;
    }
  #endif
  };
  #pragma pack(pop)
#+end_src

*** Matrices

A matrix is a two-dimensional array often used for linear algebra.

#+name: runtime-native-matrix-test
#+begin_src c++ :tangle no
//initializers
assert((matrix::zeros(2,2)  == matrix::into<2,2>(0,0,0,0)));
assert((matrix::ones(2,2)   == matrix::into<2,2>(1,1,1,1)));
assert((matrix::eye(2)      == matrix::into<2,2>(1,0,0,1)));
assert((matrix::full(2,2,4) == matrix::into<2,2>(4,4,4,4)));

//shape
assert((matrix::row_count(matrix::zeros(2,3))    == 2));
assert((matrix::column_count(matrix::zeros(2,3)) == 3));

//operations
matrix ones  = matrix::ones(2,2);
matrix zeros = matrix::zeros(2,2);
matrix twos  = matrix::full(2,2,2);

assert((ones - ones == zeros));
assert((ones + ones == twos));
assert((ones * 2    == twos));

auto v3d = matrix::into<1,3>(0, 10, 0);

assert((matrix::norm_euclidean(v3d) == 10));
assert((matrix::normalise(v3d)      == matrix::into<1,3>(0, 1, 0)));
#+end_src

#+name: runtime-native-matrix
#+begin_src c++ :tangle no
class matrix {
  size_t  rows{0};
  size_t  cols{0};
  //row-major
  real_t* data {nullptr};

  void fill(real_t val) {
    for(size_t i = 0; i < rows * cols; i++)
      data[i] = val;
  }

  size_t n_data() const { return rows * cols; }

  static void into_aux(matrix &){ }

  template<typename... Args>
  static void into_aux(matrix &m, real_t first, Args... rest){
    m.data[m.n_data() - sizeof...(rest) - 1] = first;
    into_aux(m, rest...);
  }

public:
  matrix(size_t r = 0, size_t c = 0) :
    rows(r) , cols(c),
    data((real_t *)FERRET_ALLOCATOR::allocate
         (rows * cols * sizeof(real_t))) { }

  template<typename... Args>
  inline matrix(size_t rows, size_t cols, Args... elements)
    : matrix(rows,cols) {
    into_aux(*this, elements...);
  }

  inline matrix(matrix&& o) :
    rows(o.rows), cols(o.cols),
    data(o.data) { o.data = nullptr; }

  inline matrix(matrix& o)
    : matrix(o.rows,o.cols){
    for(size_t i = 0; i < n_data(); i++)
      data[i] = o.data[i];
  }

  matrix operator+ (const matrix& m) {
    matrix sum(rows,cols);
    for(size_t i = 0; i < n_data(); i++)
      sum.data[i] = data[i] + m.data[i];
    return sum;
  }

  matrix operator- (const matrix& m) {
    matrix diff(rows,cols);
    for(size_t i = 0; i < n_data(); i++)
      diff.data[i] = data[i] - m.data[i];
    return diff;
  }

  matrix operator* (const matrix& m) {
    matrix mul(rows, m.cols);
    mul.fill(real_t(0));

    if (cols != m.rows)
      return mul;

    for (size_t i = 0; i < rows; i++) {
      for (size_t j = 0; j < m.cols; j++) {
        for (size_t k = 0; k < m.rows; k++) {
          mul(i,j, mul(i,j) + operator()(i,k) * m(k,j));
        }
      }
    }

    return mul;
  }

  matrix operator* (const real_t& r) {
    matrix mul(rows,cols);
    for(size_t i = 0; i < n_data(); i++)
      mul.data[i] = data[i] * r;
    return mul;
  }

  real_t operator()(size_t row, size_t col) const {
    return data[row * cols + col];
  }

  void operator()(size_t row, size_t col, real_t val) {
    data[row * cols + col] = val;
  }

  matrix& operator=(matrix&& x){
    rows = x.rows;
    cols = x.cols;
    data = x.data;
    x.data = nullptr;
    return *this;
  }

  bool operator ==(const matrix& m) const {
    for (unsigned i = 0; i < n_data(); i++)
      if (data[i] != m.data[i])
        return false;
    return true;
  }

#if defined(FERRET_STD_LIB)
  friend std::ostream& operator<< (std::ostream& stream, const matrix& x) {
    stream << "[";
    for (size_t r = 0; r < x.rows; r++){
      stream << "[";
      stream << x(r, 0);
      for (size_t c = 1; c < x.cols; c++)
        stream << " " << x(r,c);
      stream << "]";
    }
    return stream << "]";
  }
#endif

  ~matrix(){
    FERRET_ALLOCATOR::free(data);
  }

  static matrix empty(size_t r = 0, size_t c = 0) {
    return matrix(r,c);
  }

  static matrix zeros(size_t r = 0, size_t c = 0) {
    matrix m(r,c);
    m.fill(real_t(0));
    return m;
  }

  static matrix ones(size_t r = 0, size_t c = 0) {
    matrix m(r,c);
    m.fill(real_t(1));
    return m;
  }

  static matrix full(size_t r = 0, size_t c = 0, real_t v = real_t(0)) {
    matrix m(r,c);
    m.fill(v);
    return m;
  }

  static matrix eye(size_t n = 1){
    matrix m(n,n);
    m.fill(real_t(0));

    for(size_t r = 0; r < m.rows; r++)
      m(r,r,real_t(1));

    return m;
  }

  template<size_t rows, size_t cols, typename... Args>
  static matrix into(Args... rest){
    matrix m(rows, cols);
    into_aux(m, rest...);
    return m;
  }

  static size_t row_count(const matrix& m){
    return m.rows;
  }

  static size_t column_count(const matrix& m){
    return m.cols;
  }

  static real_t norm_euclidean(const matrix& m){
    real_t norm = real_t(0);

    for(size_t i = 0; i < m.n_data(); i++){
      norm += m.data[i] * m.data[i];
    }

    return real_t(sqrt(norm));
  }

  static matrix normalise(const matrix& m){
    real_t mag = matrix::norm_euclidean(m);
    matrix norm = matrix::zeros(m.rows,m.cols);

    if (mag == real_t(0))
      return norm;

    for(size_t i = 0; i < m.n_data(); i++)
      norm.data[i] = m.data[i] / mag;

    return norm;
  }
};
#+end_src

*** Literals

Math related string literals.

#+name: runtime-native-number-literals
#+begin_src c++ :tangle no
  constexpr auto operator "" _MB( unsigned long long const x ) -> long {
    return 1024L * 1024L * (long)x;
  }
    
  constexpr auto operator "" _KB( unsigned long long const x ) -> long {
    return 1024L * (long)x;
  }
    
  constexpr auto operator "" _pi(long double x) -> double {
    return 3.14159265358979323846 * (double)x;
  }

  constexpr auto operator "" _pi(unsigned long long int  x) -> double {
    return 1.0_pi * (double)x;
  }

  constexpr auto operator "" _deg(long double x) -> double {
    return (1.0_pi * (double)x) / 180;
  }

  constexpr auto operator "" _deg(unsigned long long int  x) -> double {
    return 1.0_deg * (double)x;
  }
#+end_src

** Native Types

C++ types used by the Ferret runtime. Most embedded systems does
not provide standard types such as =std::array= so Ferret
provides its own types that are portable across architectures.

*** byte

=byte= is a collection of bits.

#+name: runtime-native-type
#+begin_src c++ :tangle no
  typedef uint8_t byte;
#+end_src

*** int24_ t

24 bit *Little-endian* integer type.

#+name: runtime-native-type
#+begin_src c++ :tangle no
  #pragma pack(push, 1)
  class int24_t {
  protected:
    byte word[3];
  public:
    int24_t(){ }

    template<typename T>
    explicit int24_t( T const & val ) {
      ,*this   = (int32_t)val;
    }

    int24_t( const int24_t& val ) {
      ,*this   = val;
    }

    operator int32_t() const {
      if (word[2] & 0x80) { // negative? - then sign extend.
        return
          (int32_t)(((uint32_t)0xff    << 24) |
                    ((uint32_t)word[2] << 16) |
                    ((uint32_t)word[1] << 8)  |
                    ((uint32_t)word[0] << 0));
      }else{
        return
          (int32_t)(((uint32_t)word[2] << 16) |
                    ((uint32_t)word[1] << 8)  |
                    ((uint32_t)word[0] << 0));
      }
    }

    int24_t& operator =( const int24_t& input ) {
      word[0]   = input.word[0];
      word[1]   = input.word[1];
      word[2]   = input.word[2];

      return *this;
    }

    int24_t& operator =( const int32_t input ) {
      word[0]   = ((byte*)&input)[0];
      word[1]   = ((byte*)&input)[1];
      word[2]   = ((byte*)&input)[2];

      return *this;
    }

    int24_t operator +( const int24_t& val ) const {
      return int24_t( (int32_t)*this + (int32_t)val );
    }

    int24_t operator -( const int24_t& val ) const {
      return int24_t( (int32_t)*this - (int32_t)val );
    }

    int24_t operator *( const int24_t& val ) const {
      return int24_t( (int32_t)*this * (int32_t)val );
    }

    int24_t operator /( const int24_t& val ) const {
      return int24_t( (int32_t)*this / (int32_t)val );
    }

    int24_t& operator +=( const int24_t& val ) {
      ,*this   = *this + val;
      return *this;
    }

    int24_t& operator -=( const int24_t& val ) {
      ,*this   = *this - val;
      return *this;
    }

    int24_t& operator *=( const int24_t& val ) {
      ,*this   = *this * val;
      return *this;
    }

    int24_t& operator /=( const int24_t& val ) {
      ,*this   = *this / val;
      return *this;
    }

    int24_t operator -() {
      return int24_t( -(int32_t)*this );
    }

    bool operator ==( const int24_t& val ) const {
      return (int32_t)*this == (int32_t)val;
    }

    bool operator !=( const int24_t& val ) const {
      return (int32_t)*this != (int32_t)val;
    }

    bool operator >=( const int24_t& val ) const {
      return (int32_t)*this >= (int32_t)val;
    }

    bool operator <=( const int24_t& val ) const {
      return (int32_t)*this <= (int32_t)val;
    }

    bool operator >( const int24_t& val ) const {
      return (int32_t)*this > (int32_t)val;
    }

    bool operator <( const int24_t& val ) const {
      return (int32_t)*this < (int32_t)val;
    }
  };
  #pragma pack(pop)
#+end_src

*** array

=array= is a container that encapsulates fixed size arrays.

#+name: runtime-native-containers
#+begin_src c++ :tangle no
  template<class Type>
  struct array_seq {
    Type* p;
    explicit array_seq(Type* p) : p(p) {}
    bool operator!=(array_seq rhs) {return p != rhs.p;}
    Type& operator*() {return *p;}
    void operator++() {++p;}
  };
   
  template<class T, size_t S>
  struct array {
    T data[S];
        
    T& operator [](int idx)      { return data[idx]; }
    T operator [](int idx) const { return data[idx]; }
      
    array_seq<T> begin() { return array_seq<T>(data);      }
    array_seq<T> end()   { return array_seq<T>(data + S);  }
    size_t       size()  { return S;                       }
  };
#+end_src

*** bitset

=bitset= represents a fixed-size sequence of N bits.

#+name: runtime-native-containers
#+begin_src c++ :tangle no
#undef bit

#if !defined(FERRET_BITSET_WORD_TYPE)
  #define FERRET_BITSET_WORD_TYPE unsigned int
  #if defined(__clang__) || defined(__GNUG__)
    #define FERRET_BITSET_USE_COMPILER_INTRINSICS true
  #endif
#endif

template<size_t S, typename word_t = FERRET_BITSET_WORD_TYPE>
class bitset {
  static const size_t bits_per_word = sizeof(word_t) * 8;
  static const size_t n_words = S / bits_per_word;

  static_assert((S % bits_per_word) == 0, "bitset size must be a multiple of word_t");

  word_t bits[n_words];

  inline size_t word (size_t i) const { return i / bits_per_word; }
  inline size_t bit  (size_t i) const { return i % bits_per_word; }

public:
  bitset() : bits{ word_t(0x00) } { }

  inline void set   (size_t b){
    bits[word(b)] = (word_t)(bits[word(b)] |  (word_t(1) << (bit(b))));
  }

  inline void set (size_t b, size_t e){
    size_t word_ptr = word(b);
    size_t n_bits = e - b;

    bits[word_ptr] = (word_t)(bits[word_ptr] | bit_block(bit(b), n_bits));

    n_bits -= bits_per_word - bit(b);
    word_ptr++;
    size_t last_word = (word(e) == n_words) ? n_words : word(e) + 1;
    for (; word_ptr < last_word; word_ptr++){
      bits[word_ptr] = (word_t)(bits[word_ptr] | bit_block(0, n_bits));
      n_bits -= bits_per_word;
    }
  }

  inline void reset (size_t b){
    bits[word(b)] = (word_t)(bits[word(b)] & ~(word_t(1) << (bit(b))));
  }

  inline void reset (size_t b, size_t e){
    size_t word_ptr = word(b);
    size_t n_bits = e - b;

    bits[word_ptr] = (word_t)(bits[word_ptr] & ~bit_block(bit(b), n_bits));

    n_bits -= bits_per_word - bit(b);
    word_ptr++;
    size_t last_word = (word(e) == n_words) ? n_words : word(e) + 1;
    for (; word_ptr < last_word; word_ptr++){
      bits[word_ptr] = (word_t)(bits[word_ptr] & ~bit_block(0, n_bits));
      n_bits -= bits_per_word;
    }
  }

  inline void flip (size_t b){
    bits[word(b)] = (word_t)(bits[word(b)] ^  (word_t(1) << (bit(b))));
  }

  inline void flip (size_t b, size_t e){
    size_t word_ptr = word(b);
    size_t n_bits = e - b;

    bits[word_ptr] = (word_t)(bits[word_ptr] ^ bit_block(bit(b), n_bits));

    n_bits -= bits_per_word - bit(b);
    word_ptr++;
    size_t last_word = (word(e) == n_words) ? n_words : word(e) + 1;
    for (; word_ptr < last_word; word_ptr++){
      bits[word_ptr] = (word_t)(bits[word_ptr] ^ bit_block(0, n_bits));
      n_bits -= bits_per_word;
    }
  }

  inline bool test  (size_t b) const {
    return (bits[word(b)] & (word_t(1) << (bit(b))));
  }

  inline size_t ffs(size_t b = 0, size_t e = S) const {
#if defined(FERRET_BITSET_USE_COMPILER_INTRINSICS)
      // search first word
      size_t word_ptr = word(b);
      word_t this_word = bits[word_ptr];

      // mask off bits below bound
      this_word &= (~static_cast<word_t>(0)) << bit(b);
      
      if (this_word != static_cast<word_t>(0))
	return ((word_ptr * bits_per_word) + (size_t) __builtin_ctz(this_word));

      // check subsequent words
      word_ptr++;
      size_t last_word = (word(e) == n_words) ? n_words : word(e) + 1;
      for (; word_ptr < last_word; word_ptr++){
        this_word = bits[word_ptr];
        if (this_word != static_cast<word_t>(0))
          return ((word_ptr * bits_per_word) + (size_t) __builtin_ctz(this_word));
      }
#else
      for(size_t i = b; i < e; i++)
        if (test(i))
          return i;
#endif
    return S;
  }

  inline size_t ffr(size_t b = 0, size_t e = S) const {
#if defined(FERRET_BITSET_USE_COMPILER_INTRINSICS)
      // same as ffs but complements word before counting
      size_t word_ptr = word(b);
      word_t this_word = ~bits[word_ptr];

      this_word &= (~static_cast<word_t>(0)) << bit(b);
      
      if (this_word != static_cast<word_t>(0))
	return ((word_ptr * bits_per_word) + (size_t) __builtin_ctz(this_word));

      word_ptr++;
      size_t last_word = (word(e) == n_words) ? n_words : word(e) + 1;
      for (; word_ptr < last_word; word_ptr++){
        this_word = ~bits[word_ptr];
        if (this_word != static_cast<word_t>(0))
          return ((word_ptr * bits_per_word) + (size_t) __builtin_ctz(this_word));
      }
#else
      for(size_t i = b; i < e; i++)
        if (!test(i))
          return i;
#endif
    return S;
  }

  // Return word with length-n bit block starting at bit p set.
  // Both p and n are effectively taken modulo bits_per_word.
  static inline word_t bit_block(size_t p, size_t n){
    if (n >= bits_per_word)
      return (word_t)(word_t(-1) << p);

    word_t x = (word_t)((word_t(1) << n) - word_t(1));
    return  (word_t)(x << p);
  }

#if defined(FERRET_STD_LIB)
  friend std::ostream& operator<< (std::ostream& stream, bitset& x) {
    for(size_t i = 0; i < S; i++)
      stream << x.test(i);
    return stream;
  }
#endif
};
#+end_src

*** mutex

Locking abstractions for various platforms. They are disabled when
running single threaded or on an embedded platform. (=FERRET_STD_LIB=
not defined.)

#+name: runtime-native-hardware-concurrency
#+begin_src c++ :tangle no
  #if defined(FERRET_DISABLE_MULTI_THREADING)
    class mutex {
    public:
      void lock()   {} 
      void unlock() {} 
    };
  #else
    #if defined(FERRET_STD_LIB)
      class mutex {
        ::std::mutex m;
      public:
        void lock()   { m.lock();   } 
        void unlock() { m.unlock(); }
      };
    #endif

    #if defined(FERRET_HARDWARE_ARDUINO)
      class mutex {
      public:
        void lock()   { noInterrupts(); } 
        void unlock() { interrupts();   }
      };
    #endif
  #endif

  class lock_guard{
    mutex & _ref;
  public:
    explicit lock_guard(const lock_guard &) = delete;
    explicit lock_guard(mutex & mutex) : _ref(mutex) { _ref.lock(); };
    ~lock_guard() { _ref.unlock(); }
  };
#+end_src

** Initialization
*** Detect Hardware

Check for supported hardware or platform. If running on a known
hardware or platform break out of *Safe Mode* and set a flag
indicating platform.

#+name: runtime-native-hardware-setup
#+begin_src c++ :tangle no
  # define FERRET_CONFIG_SAFE_MODE TRUE

  #if !defined(FERRET_SAFE_MODE)
    #if defined(__APPLE__) ||                       \
      defined(_WIN32) ||                            \
      defined(__linux__) ||                         \
      defined(__unix__) ||                          \
      defined(_POSIX_VERSION)
    
      # undef  FERRET_CONFIG_SAFE_MODE
      # define FERRET_STD_LIB TRUE
    #endif
    
    #if defined(ARDUINO)

      # define FERRET_HARDWARE_ARDUINO TRUE

      #if !defined(FERRET_HARDWARE_ARDUINO_UART_PORT)
        # define FERRET_HARDWARE_ARDUINO_UART_PORT Serial
      #endif
    #endif
    
    #if defined(FERRET_HARDWARE_ARDUINO)
      # undef  FERRET_CONFIG_SAFE_MODE
      # define FERRET_DISABLE_STD_MAIN TRUE
    #endif
  #endif

  #if defined(FERRET_CONFIG_SAFE_MODE)
    # define FERRET_DISABLE_MULTI_THREADING TRUE
    # define FERRET_DISABLE_STD_OUT TRUE
  #endif
#+end_src

*** Import libraries

#+name: runtime-native-hardware-setup
#+begin_src c++ :tangle no
  #ifdef FERRET_STD_LIB
   #include <iostream>
   #include <iomanip>
   #include <sstream>
   #include <cstdio>
   #include <cstdlib>
   #include <cstddef>
   #include <cmath>
   #include <vector>
   #include <algorithm>
   #include <chrono>
   #include <atomic>
   #include <mutex>
   #include <thread>
   #include <future>
  #endif

  #ifdef FERRET_HARDWARE_ARDUINO
   #include <Arduino.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <stdint.h>
  #endif

  #ifdef FERRET_CONFIG_SAFE_MODE
   #include <stdio.h>
   #include <stdlib.h>
   #include <stdint.h>
   #include <math.h>
  #endif
#+end_src

*** Initialize Hardware

Default UART rate (if supported),

#+name: runtime-native-hardware-initialize
#+begin_src c++ :tangle no
  #if !defined(FERRET_UART_RATE)
    # define FERRET_UART_RATE 9600
  #endif
#+end_src

Default stream size, represents the number of characters transferred
in an I/O operation or the size of an I/O buffer.

#+name: runtime-native-hardware-initialize
#+begin_src c++ :tangle no
  #if !defined(FERRET_IO_STREAM_SIZE)
    # define FERRET_IO_STREAM_SIZE 80
  #endif
#+end_src

Setup dummy IO,

#+name: runtime-native-hardware-initialize
#+begin_src c++ :tangle no
  #if defined(FERRET_DISABLE_STD_OUT)
     namespace runtime{
       void init(){ }
      
       template <typename T>
       void print(T){ }
     }
  #endif
#+end_src

Setup IO for general purpose OS,

#+name: runtime-native-hardware-initialize
#+begin_src c++ :tangle no
  #if defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_STD_OUT)
    namespace runtime{
      void init(){}
      
      template <typename T>
      void print(const T & t){ std::cout << t; }

      template <>
      void print(const real_t & n){
        std::cout << std::fixed << std::setprecision(real_precision) << n;
      }

      void read_line(char *buff, std::streamsize len){
        std::cin.getline(buff, len);
      }
    }
  #endif
#+end_src

Setup IO for Arduino boards,

#+name: runtime-native-hardware-initialize
#+begin_src c++ :tangle no
  #if defined(FERRET_HARDWARE_ARDUINO) && !defined(FERRET_DISABLE_STD_OUT) 
    namespace runtime{
      void init(){ FERRET_HARDWARE_ARDUINO_UART_PORT.begin(FERRET_UART_RATE); }

      template <typename T>
      void print(const T t){ FERRET_HARDWARE_ARDUINO_UART_PORT.print(t); }

      template <>
      // cppcheck-suppress passedByValue
      void print(const real_t d){
        FERRET_HARDWARE_ARDUINO_UART_PORT.print(double(d), real_precision);
      }
      
      template <>
      void print(void *p){
        FERRET_HARDWARE_ARDUINO_UART_PORT.print((size_t)p,HEX);
      }

      template <> void print(const void * const p){
        FERRET_HARDWARE_ARDUINO_UART_PORT.print((size_t)p, HEX);
      }

      void read_line(char *buff, size_t len){
        byte idx = 0;
        char c;
        do{
          while (FERRET_HARDWARE_ARDUINO_UART_PORT.available() == 0);
          c = FERRET_HARDWARE_ARDUINO_UART_PORT.read();
          buff[idx++] = c;
        }while (c != '\n');
        buff[--idx] = 0x00;
      }
     }
  #endif
#+end_src

Prints data to the output stream as human-readable ASCII text followed
by a newline character (=ASCII 10=, or =\n=).

#+name: runtime-native-hardware-initialize
#+begin_src c++ :tangle no
  #if !defined(FERRET_DISABLE_STD_OUT)
     namespace runtime{
       template <typename T>
       void println(T t){
         print(t);
         print((char)0xA);
       }
     }
  #endif
#+end_src

*** Program Run

Unless =FERRET_DISABLE_STD_MAIN= is *defined* a =main= function is
defined which is the designated start of the
program. =program::main()= function contains all compiled
code. Executing this function has equivalent semantics to loading the
source file into a virgin interpreter and then terminating its
execution. If =FERRET_PROGRAM_MAIN= is defined, it will be called
right after =program::main()=.

#+name: runtime-native-program-run-std-main
#+begin_src c++ :tangle no
  #if !defined(FERRET_DISABLE_STD_MAIN)
   #if defined(FERRET_DISABLE_CLI_ARGS) || !defined(FERRET_STD_LIB)
    int main()
   #else
    int main(int argc, char* argv[])
   #endif
    {     
      using namespace ferret;
      FERRET_ALLOCATOR::init();
      runtime::init();

     #if defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_CLI_ARGS)
      for (int i = argc - 1; i > -1 ; i--)
        _star_command_line_args_star_ =  runtime::cons(obj<string>(argv[i]),_star_command_line_args_star_);
     #endif

      $file$::main();

     #if defined(FERRET_PROGRAM_MAIN)
      run(FERRET_PROGRAM_MAIN);
     #endif
       
      return 0;
    }
  #endif
#+end_src

When a supported Arduino board is [[Detect Hardware][detected]]. Instead of using a
standard =main= function, Ferret uses Arduino compatible boot
procedure. 

#+name: runtime-native-program-arduino
#+begin_src c++ :tangle no
  #if defined(FERRET_HARDWARE_ARDUINO)
    void setup(){
      using namespace ferret;
      FERRET_ALLOCATOR::init();
      runtime::init();

      #if defined(FERRET_PROGRAM_MAIN)
        $file$::main();
      #endif
    }

    void loop(){
      using namespace ferret;
      #if !defined(FERRET_PROGRAM_MAIN)
        $file$::main();
      #endif          

      #if defined(FERRET_PROGRAM_MAIN)
        run(FERRET_PROGRAM_MAIN);
      #endif
    }
  #endif
#+end_src

** Configuration

Ferret defaults to running in safe mode, which means 

  - Multi threading is disabled.
  - Console output is disabled.

Safe mode only requires a C++11 compiler, no third party library is
required including the C++ standard library. Following options can be
configured using =#define= directives, or using =native-define= or
=configure-runtime!= from program code. Unless these options are
overridden in source file, they are auto configured during compilation
on supported platforms. (i.e Multi threading will be enabled on
Linux or Mac OS X.) On unsupported platforms Ferret defaults to
running in safe mode.

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_DISABLE_STD_OUT true)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  |------------------------------------+--------------+----------------------------------------------------------|
  | Define                             | Defult Value | Description                                              |
  |------------------------------------+--------------+----------------------------------------------------------|
  | FERRET_SAFE_MODE                   | false        | Force Safe Mode.                                         |
  | FERRET_DISABLE_CLI_ARGS            | false        | Disable command line arguments.                          |
  | FERRET_DISABLE_STD_OUT             | false        | Disables output stream. (Reduces code size.)             |
  | FERRET_DISABLE_MULTI_THREADING     | false        | Disable atomic reference counting.                       |
  | FERRET_DISABLE_STD_MAIN            | false        | Disables auto execution of program::main()               |
  | FERRET_DISABLE_RC                  | Not Defined  | Disable reference counting. (When using third party GCs) |
  | FERRET_RC_TYPE                     | unsigned int | Type to use to hold the object reference count.          |
  | FERRET_PROGRAM_MAIN                | Not Defined  | A function to execute after program::main()              |
  | FERRET_UART_RATE                   | 9600         | Set default UART rate.                                   |
  | FERRET_HARDWARE_ARDUINO_UART_PORT  | Serial       | Set default UART port.                                   |
  | FERRET_NUMBER_TYPE                 | int          | Default number_t type.                                   |
  | FERRET_REAL_TYPE                   | double       | Default real_t type.                                     |
  | FERRET_REAL_EPSILON                | 0.0001       | Least significant digit representable.                   |
  |------------------------------------+--------------+----------------------------------------------------------|
#+END_EXAMPLE

** Accessing C,C++ Libraries

Ferret provides the ability to embed C++ language source code within a
Ferret program. A Ferret function can contain a short program written
in C++ language, which is executed whenever this funtion is executed.
Ferret's FFI is modeled after Gambit scheme. Whereas Gambit scheme
lets you embed C into Scheme, Ferret lets you embed C or C++ into
lisp.

Native headers can be imported using,

#+begin_src clojure
  (native-header "thirt_party_header.h")
#+end_src

Top level statements can be declared using,

#+begin_src clojure
  (native-declare "int i = 0;")
#+end_src

Ferret objects can be created using the =obj= function. If a function
only contains a string such as, 

#+begin_src clojure
  (defn inc-int [] "__result =  obj<number>(i++);")
#+end_src

It is assumed to be a native function string, it is taken as C++
code. You can then use it like any other ferret function.

#+begin_src clojure
  (while (< (inc-int) 10)
    (print 1))
#+end_src

Another option is to use the =cxx= macro,

#+begin_src clojure
  (def dac-0 (cxx "__result =  obj<number>(DAC0);"))
#+end_src

Ferret objects can be converted to/from their native counter parts,
i.e a Ferret sequence can be converted to =std::vector= to be sorted
by =std::sort= using a Ferret function,

#+name: ffi-test-helper
#+begin_src clojure
  (defn my-sort [f seq]
    "std_vector vec = sequence::to<std_vector>(seq);
     std::sort(vec.begin(), vec.end(), [f](var a, var b) { return run(f,a,b); });
     __result = sequence::from<std_vector>(vec);")
#+end_src

#+begin_src clojure
  (my-sort > (list 1 3 2)) ;; (1.0000 2.0000 3.0000)
  (my-sort < (list 1 3 2)) ;; (3.0000 2.0000 1.0000)
#+end_src

#+name: ffi-test-helper
#+begin_src clojure
  (defn my-find [item seq]
    "std_vector vec = sequence::to<std_vector>(seq);
     std_vector::iterator it = find (vec.begin(), vec.end(), item);

     if(it != vec.end())
       __result = cached::true_o;")
#+end_src

#+begin_src clojure
  (my-find (list 1 2) (list (list 1 2)
                            (list 2 3)
                            (list 4 5)))

  ;; true

  (my-find (list 5 5) (list (list 1 2)
                            (list 2 3)
                            (list 4 5)))

  ;; false
#+end_src

In addition to =defn= form there is also a =defnative= form which
allows you to define different function bodies for different =#define=
directives,

#+name: runtime-clojure-core
#+begin_src clojure
  (defnative get-char []
    (on "defined FERRET_STD_LIB"
        "return obj<number>(getchar());"))
#+end_src

This function when compiled on a system that defines =GNU_GCC= will
return the result of =getchar= as a =number= , on ANY other system it
will produce a compiler error. You can have multiple =on= blocks per
=defnative=,

#+name: runtime-clojure-core
#+begin_src clojure
  (defnative sleep [^number_t t]
    (on "defined FERRET_STD_LIB"
        "auto duration = ::std::chrono::milliseconds(t);
         ::std::this_thread::sleep_for(duration);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::delay(t);"))
#+end_src

This way a single function can be defined for multiple
systems. Reverse is also possible, since all built in data structures
are immutable you can freely call Ferret code from C++,

#+begin_src c++
  var alist = runtime::list(obj<number>(1),obj<number>(2),obj<number>(3));

  int sum = 0;
  for_each(it, alist){
    sum += number::to<number_t>(it);
  }

  ::std::cout << sum << ::std::endl;

  //or

  var res = _plus_().invoke(alist);
  res.stream_console();
  ::std::cout << ::std::endl;
#+end_src

* Core

The standard library of Ferret, provides a ton of general-purpose
functionality for writing robust, maintainable embedded
applications.

** Logic
*** true?

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn true? [x]
    "if (x)
       return cached::true_o;
     return cached::false_o;")
#+end_src

*** false?

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn false? [x]
    "if (!x)
       return cached::true_o;
     return cached::false_o;")
#+end_src

*** nil?

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
(defn nil? [x]
  "if (x.is_nil())
       return cached::true_o;
   return cached::false_o;")
#+end_src
*** not

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn not [x]
    "if (x)
       return cached::false_o;
     return cached::true_o;")
#+end_src

*** =

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn = [& args]
    "var curr = runtime::first(args);
     for_each(it, runtime::rest(args)){
      if (curr != it)
        return cached::false_o;
      curr = it;
     }
     return cached::true_o;")
#+end_src

*** not=

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defmacro not= [& test]
    `(not (= ~@test)))
#+end_src

*** identical?

Tests if 2 arguments are the same object.

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn identical? [x y]
    "if(x.get() == y.get())
      return cached::true_o;
     return cached::false_o;")
#+end_src

*** <

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
(defn < [& args]
  "var a = runtime::first(args);

   for_each(b, runtime::rest(args)){
    if (number::to<real_t>(a) >= number::to<real_t>(b))
      return cached::false_o;
    a = b;
   }

   return cached::true_o;")
#+end_src

*** >

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
(defn > [& args]
  "var a = runtime::first(args);

   for_each(b, runtime::rest(args)){
    if (number::to<real_t>(a) <= number::to<real_t>(b))
      return cached::false_o;
    a = b;
   }

   return cached::true_o;")
#+end_src

*** >=

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
(defn >= [& args]
  "var a = runtime::first(args);

   for_each(b, runtime::rest(args)){
    if (number::to<real_t>(a) < number::to<real_t>(b))
      return cached::false_o;
    a = b;
   }

   return cached::true_o;")
#+end_src

*** <=

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
(defn <= [& args]
  "var a = runtime::first(args);

   for_each(b, runtime::rest(args)){
    if (number::to<real_t>(a) > number::to<real_t>(b))
      return cached::false_o;
    a = b;
   }

   return cached::true_o;")
#+end_src

*** and

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     `(if ~x (and ~@next) false)))
#+end_src

*** or

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     `(if ~x ~x (or ~@next))))
#+end_src

** Flow
*** when

#+name: runtime-clojure-conditional-operators
#+begin_src clojure :tangle no
  (defmacro when [test & body]
    `(if ~test (do ~@body)))
#+end_src

*** cond

#+name: runtime-clojure-conditional-operators
#+begin_src clojure :tangle no
  (defmacro cond [& clauses]
    (when clauses
      `(if ~(first clauses)
         ~(if (next clauses)
            (second clauses)
            (throw (IllegalArgumentException.
                    "cond requires an even number of forms")))
         (cond ~@(next (next clauses))))))
#+end_src

*** while

Repeatedly executes =body= while =test= is true. Presumes some
side-effect will cause =test= to become =false/nil=. Returns =nil=.

#+name: runtime-clojure-conditional-operators
#+begin_src clojure :tangle no
  (defn _while_ [pred fn]
    "while(run(pred))
       run(fn);")

  (defmacro while [test & body]
    `(_while_ (fn [] ~test) (fn [] ~@body)))
#+end_src

*** while-let

Repeatedly executes body while test expression is true, evaluating the
body with binding-form bound to the value of test. 

#+name: runtime-clojure-conditional-operators
#+begin_src clojure :tangle no
  (defn _while-let_ [pred fn]
    "var v;
     while((v = run(pred)))
       run(fn,v);")

  (defmacro while-let
    [[form test] & body]
    `(_while-let_ (fn [] ~test) (fn [~form] ~@body)))
#+end_src

*** forever

#+name: runtime-clojure-conditional-operators
#+begin_src clojure :tangle no
  (defmacro forever [& body]
    `(while true ~@body))
#+end_src

*** if-let

#+name: runtime-clojure-conditional-operators
#+begin_src clojure :tangle no
  (defmacro if-let
    ([bindings then]
     `(if-let ~bindings ~then nil))
    ([bindings then else & oldform]
     (let [form (bindings 0) tst (bindings 1)]
       `(let* [temp# ~tst]
          (if temp#
            (let* [~form temp#]
              ~then)
            ~else)))))
#+end_src

*** when-let

When test is true, evaluates body with binding-form bound to the value of test.

#+name: runtime-clojure-conditional-operators
#+begin_src clojure :tangle no
  (defmacro when-let
    [bindings & body]
    (let [form (bindings 0) tst (bindings 1)]
      `(let* [temp# ~tst]
         (when temp#
           (let* [~form temp#]
             ~@body)))))
#+end_src

** Iteration
*** doseq

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defmacro doseq [binding & body]
    `(_doseq_ ~(second binding)
              (fn [~(first binding)] ~@body)))

  (defn _doseq_ [seq f] "for_each(it, seq) run(f,it);")
#+end_src

*** dotimes

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defmacro dotimes [binding & body]
    `(_dotimes_ ~(second binding)
                (fn [~(first binding)] ~@body)))

  (defn _dotimes_ [^number_t t f] "for(number_t i = 0; i < t; i++) run(f,obj<number>(i));")
#+end_src

** Sequential
*** list

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list [& xs] "if (xs.is_nil())
                       return runtime::list();
                     else
                       return xs;")
#+end_src

*** list?

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
(defn list? [x]
  "if (x.is_type(type_id<sequence>))
     return cached::true_o;
   return cached::false_o;")
#+end_src

*** empty?

Returns =true= if =seq= has no items.

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
(defn empty? [seq]
  "if(runtime::rest(seq).is_nil())
     return cached::true_o;
   return cached::false_o;")
#+end_src

*** cons

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn cons [x seq] "return runtime::cons(x, seq);")
#+end_src

*** first

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn first [x]
    "return runtime::first(x);")
#+end_src

*** second

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn second [x]
    "return runtime::first(runtime::rest(x));")
#+end_src

*** rest

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn rest [x] "return runtime::rest(x);")
#+end_src

*** nth

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn nth [coll ^number_t index] "return runtime::nth(coll,index);")
#+end_src

*** nthrest

Returns the nth rest of coll, coll when n is 0.

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn nthrest [coll ^number_t n]
    "return runtime::nthrest(coll,n);")
#+end_src

*** map

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn map
    ([f col]
     (if (not (empty? col))
       (cons (f (first col))
             (lazy-seq (map f (rest col))))))
    ([f s1 s2]
     (lazy-seq
      (when (and (not (empty? s1))
                 (not (empty? s2)))
        (cons (f (first s1) (first s2))
              (map f (rest s1) (rest s2)))))))
#+end_src

*** reduce

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn reduce
    ([f xs]
     (reduce f (first xs) (rest xs)))
    ([f acc coll]
     "__result = acc;
      for_each(i, coll)
       __result = run(f, __result, i);"))
#+end_src

*** range

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn range
    ([high]
     (range 0 high))
    ([low high]
     (if (< low high)
       (cons low (lazy-seq
                  (range (inc low) high))))))
#+end_src

*** take

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn take [n coll]
    (if (not (empty? coll))
      (if (> n 0)
        (cons (first coll)
              (lazy-seq (take (- n 1) (rest coll)))))))
#+end_src

*** take-while

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn take-while [pred s]
    (if (and (not (empty? s))
             (pred (first s)))
      (cons (first s) (lazy-seq (take-while pred (rest s))))))
#+end_src

*** drop

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn drop [n coll]
    (if (and (pos? n)
             (not (empty? coll)))
      (drop (dec n) (rest coll))
      coll))
#+end_src

*** drop-while

Returns a lazy sequence of the items in coll starting from the
first item for which (pred item) returns logical false.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn drop-while-aux [p c]
    "__result = c;
     while(run(p,__result))
       __result = runtime::rest(__result);")

  (defn drop-while [pred coll]
    (lazy-seq
     (drop-while-aux
         (fn [c]
           (and (not (empty? c))
                (pred (first c))))
       coll)))
#+end_src

*** concat

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn concat
    ([]
     (list))
    ([x]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x))))))
    ([x y]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x) y)))
       (concat y))))
#+end_src

*** apply

Applies fn =f= to the argument list formed by prepending intervening
arguments to =argv=.

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn apply [f & argv]
    "return runtime::apply(f,argv);")
#+end_src

*** conj

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn conj [coll & xs]
    (reduce (fn[h v] (cons v h)) (if (nil? coll) (list) coll) xs))
#+end_src

*** reverse

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn reverse [s]
    (reduce (fn[h v] (cons v h)) (list) s))
#+end_src

*** filter

Returns a lazy sequence of the items in =coll= for which =(pred item)=
returns logical =true=.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
(defn filter [pred coll]
  (lazy-seq
   (if (not (empty? coll))
     (let [[f & r] coll]
       (if (pred f)
         (cons f (filter pred r))
         (filter pred r))))))
#+end_src

*** repeatedly

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
(defn repeatedly
  ([f]   (lazy-seq (cons (f) (repeatedly f))))
  ([n f] (take n (repeatedly f))))
#+end_src

*** partition

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn partition
    ([n coll]
     (partition n n coll))
    ([n step coll]
     (lazy-seq
      (if (not (empty? coll))
        (let [p (take n coll)]
          (when (= n (count p))
            (cons p (partition n step (nthrest coll step))))))))
    ([n step pad coll]
     (lazy-seq
      (if (not (empty? coll))
        (let [p (take n coll)]
          (if (= n (count p))
            (cons p (partition n step pad (nthrest coll step)))
            (list (take n (concat p pad)))))))))
#+end_src

*** every?

Returns true if (pred x) is logical true for every x in coll, else
false.

#+name: runtime-clojure-core
#+begin_src clojure
  (defn every? [pred coll]
    "for_each(i, coll){
       if (!run(pred, i))
        return cached::false_o;
     }
     return cached::true_o;")
#+end_src

*** interleave

Returns a lazy seq of the first item in each coll, then the second etc.

#+name: runtime-clojure-core
#+begin_src clojure
  (defn interleave
    ([s1 s2]
     (lazy-seq
      (when (and (not (empty? s1))
                 (not (empty? s2)))
        (cons (first s1) (cons (first s2) 
                               (interleave (rest s1) (rest s2))))))))    
#+end_src

*** doall

When lazy sequences are produced via functions that have side effects,
any effects other than those needed to produce the first element in
the seq do not occur until the seq is consumed. doall can be used to
force any effects. Walks through the successive nexts of the seq, and
caches the result, thus causing the entire seq to reside in memory at
one time.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no :noweb yes
  (defn doall [s] "return runtime::doall(s)")
#+end_src

** Math
*** zero?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn zero? [x]
    (= x 0))
#+end_src

*** pos?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn pos? [x]
    (> x 0))
#+end_src

*** neg?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn neg? [x]
    (< x 0))
#+end_src

*** +

Returns the sum of nums. =(+ )= returns 0.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
(defn + [& args]
  "real_t value(0.0);

   for_each(i, args)
    value = value + number::to<real_t>(i);

   __result = obj<number>(value);")
#+end_src

*** -

Subtracts nums and returns the result.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
(defn - [& args]
  "__result = runtime::first(args);
   real_t value = number::to<real_t>(__result);
   size_t count = 1;

   for_each(i, runtime::rest(args)){
    value = (value - number::to<real_t>(i));
    count++;
   }

   if (count == 1)
    value = value * real_t(-1.0);

   __result = obj<number>(value);")
#+end_src

*** *

Returns the product of nums. =(* )= returns 1.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
(defn * [& args]
  "real_t value(1.0);

   for_each(i, args)
    value = (value * number::to<real_t>(i));

   __result = obj<number>(value);")
#+end_src

*** /

If no denominators are supplied, returns =1 / numerator=, else returns
numerator divided by all of the denominators.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
(defn / [& args]
  "__result = runtime::first(args);
   real_t value = number::to<real_t>(__result);
   size_t count = 1;

   for_each(i, runtime::rest(args)){
    value = (value / number::to<real_t>(i));
    count++;
   }

   if (count == 1)
    value = real_t(1.0) / value;

   __result = obj<number>(value);")
#+end_src

*** inc

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn inc [x]
    (+ x 1))
#+end_src

*** dec

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn dec [x]
    (- x 1))
#+end_src

*** count

Returns the number of items in the collection. (count nil) returns
0.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn count [s] "return obj<number>(runtime::count(s))")
#+end_src

*** min / max

Returns the least of the nums.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
(defn min [& args]
  "__result = runtime::first(args);
   for_each(i, runtime::rest(args))
    if (number::to<real_t>(__result) > number::to<real_t>(i))
     __result = i;")
#+end_src

Returns the greatest of the nums.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
(defn max [& args]
  "__result = runtime::first(args);
   for_each(i, runtime::rest(args))
    if (number::to<real_t>(__result) < number::to<real_t>(i))
     __result = i;")
#+end_src

*** rem

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn rem [^number_t num ^number_t div]
    "return obj<number>((num % div));")
#+end_src

*** mod

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn mod [num div] 
    (let [m (rem num div)] 
      (if (or (zero? m) (= (pos? num) (pos? div)))
        m 
        (+ m div))))
#+end_src

*** floor

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn floor [^number_t x] "return obj<number>(x);")
#+end_src

*** scale

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn scale [x in-min in-max out-min out-max]
    (+ (/ (* (- x in-min) (- out-max out-min)) (- in-max in-min)) out-min))
#+end_src

*** clamp

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn clamp [x min max]
    (cond
      (> x max) max
      (< x min) min
      true x))
#+end_src

*** bit-and

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-and [^number_t x ^number_t y] "return obj<number>((x & y));")
#+end_src

*** bit-not

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-not [^number_t x] "return obj<number>(~x);")
#+end_src

*** bit-or

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-or [^number_t x ^number_t y] "return obj<number>((x | y ));")
#+end_src

*** bit-xor

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-xor [^number_t x ^number_t y] "return obj<number>((x ^ y ));")
#+end_src

*** bit-shift-left

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-shift-left [^number_t x ^number_t n] "return obj<number>((x << n ));")
#+end_src

*** bit-shift-right

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-shift-right [^number_t x ^number_t n] "return obj<number>((x >> n ));")
#+end_src

*** bit-extract

From =x= extract =k= bits starting from position =p=.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-extract [^number_t x ^number_t p ^number_t k]
    "__result = obj<number>((x >> p) & ((1 << k) - 1));")
#+end_src

*** bit-override

Override =len= bits in =dst= starting from =pos= using bits from =src=.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-override [^number_t dst ^number_t src ^number_t pos ^number_t len]
    "number_t mask = (((number_t)1 << len) - 1) << pos;
     number_t num = (dst & ~mask) | (src & mask);
     return obj<number>(num);")
#+end_src

*** encode-int16

Split a number into bytes.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn encode-int16 [n] 
    "int16_t val = number::to<int16_t>(n);
     byte *p = (byte*)&val;
     for (int i = (sizeof(int16_t) -1); i >= 0; i--)
       __result = runtime::cons(obj<number>((number_t)p[i]),__result);")
#+end_src

*** decode-int16

Combine a list of bytes to a number.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn decode-int16 [s]
    "int16_t val = 0;
     byte *p = (byte*)&val; 

     size_t index = 0;
     for_each(i, s){
       p[index] = number::to<byte>(i);
       index++;
     }

     return obj<number>(val);")
#+end_src

*** encode-float

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn encode-float [n] 
    "static_assert(sizeof(float) == 4 * sizeof(byte), \"\");
     float val = number::to<float>(n);
     byte *p = (byte*)&val;
     for (int i = (sizeof(float) -1); i >= 0; i--)
       __result = runtime::cons(obj<number>(p[i]),__result);")
#+end_src

*** decode-float

Combine a list of bytes to a number.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn decode-float [s]
    "union {
      float f;
      byte b[4];
     } u;
     static_assert(sizeof(float) == 4 * sizeof(byte), \"\");

     size_t index = 0;
     for_each(i, s){
       if (index > 3)
        break;
       u.b[index] = number::to<byte>(i);
       index++;
     }

     return obj<number>(u.f);")
#+end_src

*** sqrt

Square root.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn sqrt [^real_t s]
    "return obj<number>(::sqrt(s));")
#+end_src

*** pow

Returns base raised to the power exponent:

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn pow [^real_t b ^real_t e]
    "return obj<number>(::pow(b, e));")
#+end_src

*** cos

Returns the cosine of an angle of x radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn cos [^real_t s]
    "return obj<number>(::cos(s));")
#+end_src

*** sin

Returns the sine of an angle of x radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn sin [^real_t s]
    "return obj<number>(::sin(s));")
#+end_src

*** asin

 Returns the principal value of the arc sine of x, expressed in radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn asin [^real_t x]
    "return obj<number>(::asin(x));")
#+end_src

*** atan2

Returns the principal value of the arc tangent of y/x, expressed in radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn atan2 [^real_t x ^real_t y]
    "return obj<number>(::atan2(x,y));")
#+end_src

*** log / log10

Returns the natural logarithm of x.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn log [^real_t x]
    "return obj<number>(::log(x));")
#+end_src

Returns the natural logarithm of x.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn log10 [^real_t x]
    "return obj<number>(::log10(x));")
#+end_src

*** to-degrees

Converts an angle measured in radians to an approximately equivalent
angle measured in degrees.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn to-degrees [^real_t x]
    "return obj<number>((x * 180.0 / 1_pi));")
#+end_src

*** to-radians

Converts an angle measured in degrees to an approximately equivalent
angle measured in radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn to-radians [^real_t x]
    "return obj<number>((x * 1_pi / 180.0));")
#+end_src

*** rand

Returns a random floating point number between 0 (inclusive) and n
(default 1) (exclusive).

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defnative rand-aux []
    (on "defined FERRET_STD_LIB"
        ("random")
        "::std::random_device ferret_random_device;
         ::std::mt19937_64 ferret_random_generator(ferret_random_device());
         ::std::uniform_real_distribution<ferret::real_t> ferret_random_distribution(0.0,1.0);"
        "return obj<number>(ferret_random_distribution(ferret_random_generator));"))

  (defn rand
    ([]
     (rand-aux))
    ([x]
     (* x (rand-aux))))
#+end_src

*** rand-int

Returns a random integer between 0 (inclusive) and n (exclusive).

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn rand-int
    [x]
    (floor (rand x)))
#+end_src

** Matrices

#+begin_src clojure
(require '[ferret.matrix :as m])

(def pi 3.1415)

(defn rot [turns]
  (let [a (* 2 pi turns)]
    (make-matrix
     [[   (cos a)  (sin a)]
      [(- (sin a)) (cos a)]])))

(->> (make-matrix [[3] [4]])
     (m/mmul (rot 1/8))
     (m/cout))

(println )
#+end_src

*** row-count

Returns the number of rows in a matrix.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn row-count [^matrix u]
  "return obj<number>(matrix::row_count(u));")
#+end_src

*** column-count

Returns the number of columns in a matrix.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn column-count [^matrix u]
  "return obj<number>(matrix::column_count(u));")
#+end_src

*** zeros

Constructs a new zero-filled numerical matrix with the given
dimensions.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn zeros [^number_t r, ^number_t c]
  "return obj<matrix_t>(matrix::zeros(r,c));")
#+end_src

*** ones

Constructs a new zero-filled numerical matrix with the given
dimensions.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn ones [^number_t r, ^number_t c]
  "return obj<matrix_t>(matrix::ones(r,c));")
#+end_src

*** full

Fills a matrix with a single scalar value.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn full [^number_t r, ^number_t c, ^number_t v]
  "return obj<matrix_t>(matrix::ones(r,c,v));")
#+end_src

*** eye

Identity matrix. Returns an n-by-n identity matrix with ones on the
main diagonal and zeros elsewhere.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn eye [^number_t n]
  "return obj<matrix_t>(matrix::eye(n));")
#+end_src

*** add

Performs element-wise addition on matrices.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn add [^matrix u ^matrix v]
  "return obj<matrix_t>(u + v);")
#+end_src

*** sub

Performs element-wise subtraction on matrices.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn sub [^matrix u ^matrix v]
  "return obj<matrix_t>(u - v);")
#+end_src

*** mul

Performs element-wise multipication with scalar on matrices.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn mul [^matrix u ^real_t s]
  "return obj<matrix_t>(u * s);")
#+end_src

*** mmul

Performs matrix multiplication on matrices.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn mmul [^matrix u ^matrix v]
  "return obj<matrix_t>(u * v);")
#+end_src

*** equals

Returns =true= if both matrices are numerically equal.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn equals [^matrix u ^matrix v]
  "if (u == v)
       return cached::true_o;
   else
       return cached::false_o;")
#+end_src

*** normalise

Normalises a matrix (scales to unit length). Returns a new normalised
matrix.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn normalise [^matrix u]
  "return obj<matrix_t>(matrix::normalise(u));")
#+end_src

*** norm

Calcualtes the Euclidean norm of matrix.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn norm [^matrix u]
  "return obj<number>(matrix::norm_euclidean(u));")
#+end_src

*** mset!

Mutates a scalar value in a matrix at the specified position.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn mset! [^matrix u ^number_t r ^number_t c ^number_t v]
  "u(r,c,v);")
#+end_src

*** mget

Gets a scalar value from a matrix at the specified position.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn mget [^matrix u ^number_t r ^number_t c]
  "return obj<number>(u(r,c));")
#+end_src

*** cout

Pretty-prints a matrix to =std::cout=.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn cout [^matrix u]
  "std::cout << u;")
#+end_src

*** seq

Converts =matrix= to a =lazy-seq=.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/matrix.clj
(defn seq [u]
  (map
   (fn [row]
     (map
      (fn [col]
        (mget u row col))
      (range (column-count u))))
   (range (row-count u))))
#+end_src

** Timing
*** millis

Return current time in milliseconds,

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defnative millis []
    (on "defined FERRET_STD_LIB"
        "auto now = ::std::chrono::system_clock::now();
         auto epoch = now.time_since_epoch();
         auto time = ::std::chrono::duration_cast<::std::chrono::milliseconds>(epoch).count();
         return obj<number>(time);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "return obj<number>(::millis());"))
#+end_src

*** micros

Return current time in microseconds,

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defnative micros []
    (on "defined FERRET_STD_LIB"
        "auto now = ::std::chrono::high_resolution_clock::now();
         auto epoch = now.time_since_epoch();
         auto time = ::std::chrono::duration_cast<::std::chrono::microseconds>(epoch).count();
         return obj<number>(time);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "return obj<number>(::micros());"))
#+end_src

*** sleep

Sleep current thread for *t* milliseconds,

*** sleep-micros

Sleep current thread for *t* microseconds,

#+name: runtime-clojure-core
#+begin_src clojure :tangle no :noweb yes
  (defnative sleep-micros [^number_t t]
    (on "defined FERRET_STD_LIB"
        "auto duration = ::std::chrono::microseconds(t);
         ::std::this_thread::sleep_for(duration);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::delayMicroseconds(t);"))
#+end_src

*** elapsed-micros

Port of Teensy elapsedMicros API,

#+name: runtime-clojure-core
#+begin_src clojure :tangle no :noweb yes
  (defobject elapsed_micros "ferret/obj/elapsed_micros_o.h")

  (defn new-elapsed-micros []
    "return obj<elapsed_micros>();")

  (defn elapsed-micros? [t ^real_t t]
    "if (t.cast<elapsed_micros>()->is_elapsed(t))
       return cached::true_o;
     return cached::false_o;")

  (defn elapsed-micros-now [t]
    "return obj<number>(t.cast<elapsed_micros>()->elapsed());")

  (defn elapsed-micros-reset [t]
    "t.cast<elapsed_micros>()->reset()")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/elapsed_micros_o.h
  #if !defined(FERRET_SAFE_MODE)
  class elapsed_micros : public object {
    mutex lock;
    unsigned long us;

  #if defined(FERRET_HARDWARE_ARDUINO)
    inline unsigned long now() const{
      return ::micros();
    }
  #elif defined(FERRET_STD_LIB)
    inline unsigned long now() const{
      auto now = ::std::chrono::high_resolution_clock::now();
      auto epoch = now.time_since_epoch();
      return (unsigned long)::std::chrono::duration_cast<::std::chrono::microseconds>(epoch).count();
    }
  #endif
    
   public:

    elapsed_micros(void) { us = now(); }

    void reset() {
      lock_guard guard(lock);
      us = now();
    }
    
    type_t type() const { return type_id<elapsed_micros>; }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const {
      runtime::print("micros#");
      runtime::print(elapsed());
    }
  #endif

    inline real_t elapsed() const { return (real_t)(now() - us); }
    inline bool is_elapsed(real_t t) const { return (elapsed() >= t); }
  };
  #endif
#+end_src

*** benchmark

Benchmark a function. Run function =f= =n= times and print execution
statistics.

#+begin_src clojure
(benchmark #(reduce + (range 1000)) 10000)
#+end_src

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
(defn benchmark
  ([f]
   (benchmark f 100))
  ([f ^number_t n]
   "elapsed_micros timer;

    run(f);
    real_t elapsed = timer.elapsed() / real_t(1000.0);

    real_t min = elapsed;
    real_t max = elapsed;
    real_t sum = real_t(0.0);
    real_t sum_sq = real_t(0.0);

    for(number_t i =0; i < n; i++){
      timer.reset();
      run(f);
      real_t elapsed = timer.elapsed() / real_t(1000.0);

      #if defined(FERRET_BENCHMARK_VERBOSE)
         runtime::println(elapsed);
      #endif

      sum += elapsed;
      sum_sq += (elapsed * elapsed);
      if (elapsed < min)
        min = elapsed;
      if (elapsed > max)
        max = elapsed;
      }

      real_t mean = (real_t)(sum / n);
      real_t stdev = (real_t)sqrt((sum_sq / n) - (mean * mean));

      runtime::print(\"\\t mean: \");
      runtime::println(mean);

      runtime::print(\"\\tstdev: \");
      runtime::println(stdev);

      runtime::print(\"\\t  min: \");
      runtime::println(min);

      runtime::print(\"\\t  max: \");
      runtime::println(max);

      runtime::print(\"\\trange: \");
      runtime::println((max - min));"))
#+end_src

*** fn-throttler

    Returns a new function that limits the throughput of the given
    function. When called faster than ==rate== it can either block or
    return ==nil== immediately.

#+begin_src clojure
(defn ping []
  (println "Ping!"))

(def throttled-ping (fn-throttler ping 1 :second :blocking))

;; Ping console every second
(forever
 (throttled-ping))    
#+end_src

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
(defobject fn_throttler_o "ferret/obj/fn_throttler_o.h")

(defn new-fn-throttler [f ^real_t rate ^bolean block]
  "return obj<fn_throttler>(f, rate, block);")

(defmacro fn-throttler [f rate unit policy]
  (let [unit->ms {:microsecond 1 :millisecond 1000
                  :second 1000000 :minute 60000000
                  :hour 3600000000 :day 86400000000
                  :month 2678400000000}
        rate (/ (unit->ms unit) rate)]
    `(new-fn-throttler ~f ~rate ~(= policy :blocking))))
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/fn_throttler_o.h
#if !defined(FERRET_SAFE_MODE)
class fn_throttler : public lambda_i {
  var fn;
  elapsed_micros timer;
  real_t rate;
  bool blocking;

#if defined(FERRET_HARDWARE_ARDUINO)
  inline void _wait(real_t t) const{
    ::delayMicroseconds((number_t)t);
  }
#elif defined(FERRET_STD_LIB)
  inline void _wait(real_t t) const{
    auto duration = ::std::chrono::microseconds((number_t)t);
    ::std::this_thread::sleep_for(duration);
  }
#endif
  
  var exec(ref args){
    if (blocking)
      _wait(rate - timer.elapsed());

    if (timer.is_elapsed(rate)){
      timer.reset();
      return runtime::apply(fn, args);
    }
    
    return nil();
  }
  
public:

  explicit fn_throttler(var f, real_t r, bool b) : fn(f), rate(r), blocking (b) { }

  var invoke(ref args) const {
    return var((object*)this).cast<fn_throttler>()->exec(args);
  }
};
#endif
#+end_src

** String
*** ston

Parses the Ferret =string= =str=, interpreting its content as a number
and returns its value as a Ferret =number=.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn ston [str]
    "var seq = str;
     real_t factor = 1;
     real_t value = 0;

     if (number::to<byte>(runtime::first(seq)) == '-'){
       seq = runtime::rest(seq);
       factor = -1;
     }

     bool point_passed = false;
     for_each(i, seq){
       byte ch = number::to<byte>(i);

       if (ch == '.'){
         point_passed = true;
         continue;
       }

       number_t d = ch - '0';
       if (d >= 0 && d <= 9){
         if (point_passed)
           factor /= real_t(10.0);
         value = value * real_t(10.0) + real_t(d);
       }
     }
    
     return obj<number>(value * factor);")
#+end_src

*** ntos

Converts a Ferret =number= to a Ferret =string=,

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn ntos [^real_t f]
    "number_t n = (number_t)f;
     number_t sign;

     if ((sign = n) < 0){
        n = -n;
        f = -f;
     }

     var s;

     f = (f - n) + 10;
     for (int i = real_precision; i >= 1; i--){
        number_t ch = ((number_t)(f * ::pow(10, i)) % 10) + '0';
        s = runtime::cons(obj<number>(ch), s);
     }

     s = runtime::cons(obj<number>('.'), s);

     do {
       s = runtime::cons(obj<number>(n % 10 + '0'), s);
      } while ((n /= 10) > 0);

     if (sign < 0)
       s = runtime::cons(obj<number>('-'), s);

     return obj<string>(s);")
#+end_src

** Functions
*** fn

Define a =fn=,

#+begin_src clojure :tangle no
  (fn [a] a)
#+end_src

Define a =fn= and bind =name= to it,

#+name: runtime-clojure-fn-macros
#+begin_src clojure :tangle no
  (defmacro defn [name & body]
    `(def ~name (fn ~@body)))
#+end_src

Define a multi-arity function that counts the number of its arguments
and then dispatches on the number of arguments to each implementation.

#+begin_src clojure :tangle no
  (fn
    ([a] 1)
    ([a b] 2)
    ([a b & c] 3)
    ([a b [c d] & e] 4))
#+end_src

Functions may also define a variable number of arguments - this is
known as a "variadic" function. The variable arguments must occur at
the end of the argument list. They will be collected in a sequence for
use by the function.

The beginning of the variable arguments is marked with =&=

#+begin_src clojure :tangle no
  (defn hello [greeting & who]
    (println greeting who))
#+end_src

See [[Accessing C,C++ Libraries]] for information on how to use Ferret
with external libraries.

#+name: runtime-clojure-fn-macros
#+begin_src clojure :tangle no
  (defmacro fn [& sig]
    (let [name (if (symbol? (first sig)) (first sig) nil)
          body (if name (rest sig) sig)]
      (if (vector? (first body))
        (let [[args & body] body]
          (new-fir-fn :name name :args args :body body))
        ;; handle multi arity function
        (let [fns   (map (fn* [body]
                              (let [[args & body] body]
                                (new-fir-fn :args args :body body)))
                         body)
              arity (->> (map first body)
                         (map (fn* [args] (filter #(not (= % '&)) args)))
                         (map #(count %)))
              fns   (->> (interleave arity fns)
                         (partition 2)
                         (sort-by first))
              fns   (if (->> fns last second second      ;; last arity arguments
                             (take-last 2) first (= '&)) ;; check &
                      (let [switch        (drop-last 1 fns)
                            [[_ default]] (take-last 1 fns)]
                        `(fir-defn-arity ~switch ~default))
                      `(fir-defn-arity ~fns))]
          (new-fir-fn :escape false :name name :body [fns])))))
#+end_src

A simple macro for calling inline C++,

#+name: runtime-clojure-fn-macros
#+begin_src clojure :tangle no
  (defmacro cxx [& body]
    (let [body (apply str body)]
      `((fn [] ~body))))
#+end_src

*** defnative

Allows a function to be defined for multiple platforms see [[Accessing C,C++ Libraries]] for
examples.

#+name: runtime-clojure-fn-macros
#+begin_src clojure :tangle no
  (defmacro defnative [name args & form]
    (let [includes (->> (filter #(seq? (nth % 2)) form)
                        (map #(cons (nth % 1) (apply list (nth % 2))))
                        (map (fn [form]
                               (let [[guard & headers] form]
                                 (str "\n#if " guard " \n"
                                      (apply str (map #(str "#include \"" % "\"\n") headers))
                                      "#endif\n"))))
                        (map #(list 'native-declare %)))
          enabled (-> (symbol-conversion name)
                      (str "_enabled")
                      .toUpperCase)
          body (->> (map #(vector (second %) (last %)) form)
                    (map #(str "\n#if " (first %) " \n"
                               "#define " enabled "\n"
                               (second %)
                               "\n#endif\n"))
                    (apply str))
          body (str body
                    "\n#if !defined " enabled " \n"
                    "# error " (symbol-conversion name)
                    " Not Supported on This Platform \n"
                    "#endif\n")
          pre-ample (->> (map #(vector (second %) (drop-last (drop 3 %))) form)
                         (remove #(empty? (second %)))
                         (map #(str "\n#if " (first %) " \n"
                                    (apply str (map (fn [line] (str line "\n")) (second %)))
                                    "\n#endif\n"))
                         (map #(list 'native-declare %)))]
      `(def ~name (fn ~args ~@includes ~@pre-ample  ~body))))
#+end_src

*** ->

Threads the expr through the forms. Inserts x as the
second item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
second item in second form, etc.

#+name: runtime-clojure-threading-macros
#+begin_src clojure :tangle no
  (defmacro -> [x & forms]
    (loop [x x, forms forms]
      (if forms
        (let [form (first forms)
              threaded (if (seq? form)
                         `(~(first form) ~x ~@(next form))
                         (list form x))]
          (recur threaded (next forms)))
        x)))
#+end_src

*** ->>

Threads the expr through the forms. Inserts x as the
last item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
last item in second form, etc.

#+name: runtime-clojure-threading-macros
#+begin_src clojure :tangle no
  (defmacro ->> [x & forms]
    (loop [x x, forms forms]
      (if forms
        (let [form (first forms)
              threaded (if (seq? form)
                         `(~(first form) ~@(next form)  ~x)
                         (list form x))]
          (recur threaded (next forms)))
        x)))
#+end_src

*** doto

Evaluates x then calls all of the methods and functions with the
value of x supplied at the front of the given arguments.  The forms
are evaluated in order.  Returns x.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defmacro doto
    [x & forms]
    (let [gx (gensym)]
      `(let [~gx ~x]
         ~@(map (fn [f]
                  (if (seq? f)
                    `(~(first f) ~gx ~@(next f))
                    `(~f ~gx)))
                forms)
         ~gx)))
#+end_src

*** comment

Ignores body, yields nil.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
(defmacro comment
  [& body])
#+end_src

** I/O
*** print

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defnative print [& more]
    (on "!defined(FERRET_DISABLE_STD_OUT)"
        "if (more.is_nil())
           return nil();
         ref f = runtime::first(more);
         f.stream_console();
         ref r = runtime::rest(more);
         for_each(it, r){
          runtime::print(\" \");
          it.stream_console();
         }
         return nil();"))
#+end_src

*** newline

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defnative newline []
    (on "!defined(FERRET_DISABLE_STD_OUT)"
        "runtime::print(\"\\n\");"))
#+end_src

*** println

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn println [& more]
    (when more
      (apply print more))
    (newline))
#+end_src

*** get-char
*** read-line

Reads the next line from default I/O stream.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn read-line []
    "char buf[FERRET_IO_STREAM_SIZE] = {0};
     runtime::read_line(buf, FERRET_IO_STREAM_SIZE);
     return obj<string>(buf);")
#+end_src

*** slurp

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defnative slurp [^std_string f]
    (on "defined FERRET_STD_LIB"
        ("fstream")
        "std::ifstream ifs(f.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
   
         if (!ifs.good())
           return nil();
   
         std::ifstream::pos_type file_size = ifs.tellg();
         ifs.seekg(0, std::ios::beg);

         std::vector<char> bytes(file_size);
         ifs.read(bytes.data(), file_size);
         return obj<string>(std::string(bytes.data(), file_size));"))
#+end_src

*** sh

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defnative sh [^std_string cmd]
    (on "defined FERRET_STD_LIB"
        ("memory")
        "::std::shared_ptr<FILE> pipe(popen(cmd.c_str(), \"r\"), pclose);
         if (!pipe) 
           return nil();
         char buffer[128];
         ::std::string result = \"\";
         while (!feof(pipe.get()))
          if (fgets(buffer, 128, pipe.get()) != NULL)
           result += buffer;
         return obj<string>(result);"))
#+end_src

*** lock-memory

Wraps mlockall - locks the address space of process.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defnative lock-memory []
    (on "defined FERRET_STD_LIB"
        ("sys/mman.h")
        "mlockall(MCL_CURRENT | MCL_FUTURE);"))
#+end_src

*** pr-object-sizes

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn pr-object-sizes []
    (println "Machine Types")
    (println "\t*void:\t\t\t" (cxx "return obj<number>(sizeof(void*));"))
    (println "\treal_t:\t\t\t" (cxx "return obj<number>(sizeof(real_t));"))
    (println "\tnumber_t:\t\t" (cxx "return obj<number>(sizeof(number_t));"))
    (println "Object Types")
    (println "\tvar:\t\t\t" (cxx "return obj<number>(sizeof(var));"))
    (println "\tobject:\t\t\t" (cxx "return obj<number>(sizeof(object));"))
    (println "\tnumber:\t\t\t" (cxx "return obj<number>(sizeof(number));"))
    (println "\tkeyword:\t\t" (cxx "return obj<number>(sizeof(keyword));"))
    (println "\tboolean:\t\t" (cxx "return obj<number>(sizeof(boolean));"))
    (println "\tempty_sequence:\t\t" (cxx "return obj<number>(sizeof(empty_sequence));"))
    (println "\tsequence:\t\t" (cxx "return obj<number>(sizeof(sequence));"))
    (println "\tlazy_sequence:\t\t" (cxx "return obj<number>(sizeof(lazy_sequence));"))
    (println "\tatom:\t\t\t" (cxx "return obj<number>(sizeof(atomic));"))
    (println "\td_list:\t\t\t" (cxx "return obj<number>(sizeof(d_list));"))
    (println "\tpointer:\t\t" (cxx "return obj<number>(sizeof(pointer));"))
    (println "\telapsed_micros:\t\t" (cxx "return obj<number>(sizeof(elapsed_micros));"))
    (println "\tpid_controller<real_t>:\t"
             (cxx "return obj<number>(sizeof(pid_controller<real_t>));"))
    (println "\tdelayed:\t\t" (cxx "return obj<number>(sizeof(delayed));"))
    (println "\tstring:\t\t\t" (cxx "return obj<number>(sizeof(string));"))
    (println "Interface Types")
    (println "\tseekable_i:\t\t" (cxx "return obj<number>(sizeof(seekable_i));"))
    (println "\tlambda_i:\t\t" (cxx "return obj<number>(sizeof(lambda_i));"))
    (println "\tderef_i:\t\t" (cxx "return obj<number>(sizeof(deref_i));")))
#+end_src

*** memory-pool-free-space

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defnative memory-pool-free-space []
    (on "defined FERRET_MEMORY_POOL_SIZE"
        "size_t acc = 0;
         for(size_t i = 0; i < FERRET_MEMORY_POOL_PAGE_COUNT; i++)
           if(memory::allocator::program_memory.used.get(i) == false)
             acc++;
         return obj<number>((acc*sizeof(FERRET_MEMORY_POOL_PAGE_TYPE)));"))
#+end_src

*** system-exit

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn system-exit [^number_t code]
    "::exit(code);")
#+end_src

*** system-abort

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn system-abort [code]
    "::abort();")
#+end_src

*** system-halt

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
(defn system-halt [code]
  (forever (sleep 1000)))
#+end_src

*** byte-stream-encoder/decoder

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn byte-stream-encoder [write]
    (fn [bytes]
      (let [size (count bytes)
            CS   (reduce bit-xor size bytes)]
        (write 0X06)
        (write 0X85)
        (write size)
        (doseq [b bytes] 
          (write b))
        (write CS))))
#+end_src

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn byte-stream-header-ready [read in-waiting]
    (and (>= (in-waiting) 3) (= (read) 0X06) (= (read) 0X85)))

  (defn byte-stream-payload-ready [size in-waiting]
    (>= (in-waiting) (inc @size)))

  (defn byte-stream-handle-payload [read ^number_t size handler]
    "number_t cs_calculated = size;
     var payload_rev;

     for(number_t i = 0 ; i < size; i++){
       ref v = run(read);
       cs_calculated ^= number::to<number_t>(v);
       payload_rev = runtime::cons(v,payload_rev);
     }

     number_t cs_read = number::to<number_t>(run(read));

     if (cs_calculated == cs_read){
       var payload;

       for_each(i, payload_rev)
         payload = runtime::cons(i,payload);
       
       run(handler,payload);
     }")

  (defn byte-stream-decoder [read in-waiting handler]
    (let [size (atom nil)]
      (fsm 
       (states
        (sync-header)
        (read-size        (reset! size (read)))
        (wait-payload)
        (handle-payload   (byte-stream-handle-payload read @size handler)))
       (transitions
        (sync-header     #(byte-stream-header-ready read in-waiting)      read-size)
        (read-size                                                        wait-payload)
        (wait-payload    #(byte-stream-payload-ready size in-waiting)     handle-payload)
        (handle-payload                                                   sync-header)))))
#+end_src

*** multicast-socket

The multicast datagram socket class is useful for sending and
receiving IP multicast packets. A MulticastSocket is a (UDP)
datagram socket, with additional capabilities for joining "groups" of
other multicast hosts on the internet.

A multicast group is specified by a class D IP address and by a
standard UDP port number. Class D IP addresses are in the range
224.0.0.0 to 239.255.255.255, inclusive. The address 224.0.0.0 is
reserved and should not be used.

One would join a multicast group by first creating a =multicast-socket=
with the desired IP and port. When one sends a message to a multicast
group, all subscribing recipients to that host and port receive the
message. When a socket subscribes to a multicast group/port, it
receives datagrams sent by other hosts to the group/port, as do all
other members of the group and port.

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/core/net/multicast.clj
  (require '[ferret.net.multicast :as multicast])

  (def sender   (multicast/socket "224.5.23.2" 10005))
  (def receiver (multicast/socket "224.5.23.2" 10005))

  (def data-out (list 1 2 3 4 5))

  (assert (multicast/send sender data-out))
  (assert (multicast/pending? receiver))

  (def data-in (multicast/recv receiver))

  (assert (= data-in data-out))
#+end_src

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/src/ferret/net/multicast.clj
  (native-header "fcntl.h"
                 "unistd.h"
                 "arpa/inet.h"
                 "netdb.h"
                 "netinet/in.h"
                 "sys/poll.h"
                 "sys/socket.h"
                 "sys/types.h"
                 "string.h")

  (defobject multicast-socket "ferret/net/multicast_o.h")

  (defn socket [ip port]
    "return obj<multicast_socket>(ip,port);")

  (defn pending? [con]
    "if (con.cast<multicast_socket>()->have_pending_data())
       return cached::true_o;
     return cached::false_o;")

  (defn send [con data]
    "datagram_t buffer;
     number_t idx = 0; 

     for_each(b, data)
      buffer[idx++] = (byte)number::to<number_t>(b);

     if (con.cast<multicast_socket>()->send(buffer,idx))
        return cached::true_o;
      return cached::false_o;")

  (defn byte [data ^number_t curr]
    "auto buffer = value<datagram_t>::to_reference(data);
     return obj<number>(buffer[curr]);")

  (defn data-seq
    ([[size data]]
     (data-seq size data 0))
    ([size data curr]
     (if (< curr size)
       (cons (byte data curr)
             (lazy-seq (data-seq size data (inc curr)))))))

  (defn read [conn]
    "return conn.cast<multicast_socket>()->recv();")

  (defn recv [conn]
    (data-seq (read conn)))
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/net/multicast_o.h
  const size_t max_data_gram_size = 65507;
  typedef ferret::array<ferret::byte, max_data_gram_size> datagram_t;

  namespace multicast_aux {
    class address{
      sockaddr addr;
      socklen_t addr_len;
   
    public:
      address(){
        memset(&addr, 0, sizeof(addr));
        addr_len = 0;
      }
    
      address(const char *hostname, unsigned short port){
        set_host(hostname, port);
      }
    
      address(const address &src){ copy(src); }
    
      ~address() { reset(); }
   
      bool set_host(const char *hostname, unsigned short port);
      void set_any(unsigned short port = 0);
   
      bool operator==(const address &a) const{
        return addr_len == a.addr_len && memcmp(&addr, &a.addr, addr_len) == 0;
      }
    
      void copy(const address &src){
        memcpy(&addr, &src.addr, src.addr_len);
        addr_len = src.addr_len;
      }
    
      void reset(){
        memset(&addr, 0, sizeof(addr));
        addr_len = 0;
      }
    
      void clear(){
        reset();
      }
   
      in_addr_t get_in_addr() const;
   
      friend class udp;
    };

    class udp{
      int fd;
   
    public:
      unsigned sent_packets;
      size_t sent_bytes;
      unsigned recv_packets;
      size_t recv_bytes;
   
    public:
      udp() : fd(-1) { close(); }
      ~udp(){ close(); }
   
      bool open(const char *server_host, unsigned short port, bool blocking);
      bool add_multicast(const address &multiaddr, const address &interface);
      void close();
      bool is_open() const{ return fd >= 0; }
   
      bool send(const void *data, size_t length, const address &dest);
      ssize_t recv(address &src, datagram_t & recv_buf);
   
      bool wait(int timeout_ms = -1) const;
      bool have_pending_data() const;
    };
   
    bool address::set_host(const char *hostname, unsigned short port){
      addrinfo *res = nullptr;
      getaddrinfo(hostname, nullptr, nullptr, &res);
      if (res == nullptr) {
        return false;
      }
   
      memset(&addr, 0, sizeof(addr));
      addr_len = res->ai_addrlen;
      memcpy(&addr, res->ai_addr, addr_len);
      freeaddrinfo(res);
   
      // set port for internet sockets
      sockaddr_in *sockname = reinterpret_cast<sockaddr_in *>(&addr);
      if (sockname->sin_family == AF_INET) {
        sockname->sin_port = htons(port);
      }
      else {
        // TODO: any way to set port in general?
      }
   
      return true;
    }
   
    void address::set_any(unsigned short port){
      memset(&addr, 0, sizeof(addr));
      sockaddr_in *s = reinterpret_cast<sockaddr_in *>(&addr);
      s->sin_addr.s_addr = htonl(INADDR_ANY);
      s->sin_port = htons(port);
      addr_len = sizeof(sockaddr_in);
    }
   
    in_addr_t address::get_in_addr() const{
      const sockaddr_in *s = reinterpret_cast<const sockaddr_in *>(&addr);
      return s->sin_addr.s_addr;
    }
   
    bool udp::open(const char *server_host, unsigned short port, bool blocking){
      // open the socket
      if (fd >= 0) {
        ::close(fd);
      }
      fd = socket(PF_INET, SOCK_DGRAM, 0);
   
      // set socket as non-blocking
      int flags = fcntl(fd, F_GETFL, 0);
      if (flags < 0) {
        flags = 0;
      }
      fcntl(fd, F_SETFL, flags | (blocking ? 0 : O_NONBLOCK));
   
      int reuse = 1;
      if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<const char *>(&reuse), sizeof(reuse)) != 0) {
        fprintf(stderr, "ERROR WHEN SETTING SO_REUSEADDR ON udp SOCKET\n");
        fflush(stderr);
      }
   
      int yes = 1;
      // allow packets to be received on this host
      if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, reinterpret_cast<const char *>(&yes), sizeof(yes)) != 0) {
        fprintf(stderr, "ERROR WHEN SETTING IP_MULTICAST_LOOP ON udp SOCKET\n");
        fflush(stderr);
      }
   
      // bind socket to port if nonzero
      if (port != 0) {
        sockaddr_in sockname;
        sockname.sin_family = AF_INET;
        sockname.sin_addr.s_addr = htonl(INADDR_ANY);
        sockname.sin_port = htons(port);
        bind(fd, reinterpret_cast<struct sockaddr *>(&sockname), sizeof(sockname));
      }
   
      // add udp multicast groups
      address multiaddr, interface;
      multiaddr.set_host(server_host, port);
      interface.set_any();
   
      return add_multicast(multiaddr, interface);
    }
   
    bool udp::add_multicast(const address &multiaddr, const address &interface){
      struct ip_mreq imreq;
      imreq.imr_multiaddr.s_addr = multiaddr.get_in_addr();
      imreq.imr_interface.s_addr = interface.get_in_addr();
   
      int ret = setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &imreq, sizeof(imreq));
   
      return ret == 0;
    }
   
    void udp::close(){
      if (fd >= 0) {
        ::close(fd);
      }
      fd = -1;
   
      sent_packets = 0;
      sent_bytes = 0;
      recv_packets = 0;
      recv_bytes = 0;
    }
   
    bool udp::send(const void *data, size_t length, const address &dest){
      ssize_t len = sendto(fd, data, length, 0, &dest.addr, dest.addr_len);
      
      if (len > 0) {
        sent_packets++;
        sent_bytes += (size_t)len;
      }
   
      return (len >= 0 && (size_t)len == length);
    }

    ssize_t udp::recv(address &src, datagram_t & recv_buf){
      src.addr_len = sizeof(src.addr);
      ssize_t len = recvfrom(fd, recv_buf.data, max_data_gram_size, 0, &src.addr, &src.addr_len);
   
      if (len > 0) {
        recv_packets++;
        recv_bytes += (size_t)len;
      }
   
      return len;
    }
   
    bool udp::have_pending_data() const{
      return wait(0);
    }
   
    bool udp::wait(int timeout_ms) const{
      static const bool debug = false;
      static bool pendingData = false;
      pollfd pfd;
      pfd.fd = fd;
      pfd.events = POLLIN;
      pfd.revents = 0;
   
      bool success = (poll(&pfd, 1, timeout_ms) > 0);
   
      if (!success) {
        // Poll now claims that there is no pending data.
        // What did have_pending_data get from Poll most recently?
        if (debug) {
          printf("wait failed, have_pending_data=%s\n", (pendingData ? "true" : "false"));
        }
      }
      pendingData = success;
      return success;
    }
  }

  class multicast_socket final : public object {
    std::string ip;
    unsigned short port;
    multicast_aux::udp net;
    mutex lock;
    
  public:

    type_t type() const final { return type_id<multicast_socket>; }

  #if !defined(FERRET_DISABLE_STD_OUT)
    void stream_console() const final {
      runtime::print("multicast_socket<");
      runtime::print(ip);
      runtime::print(" ");
      runtime::print(port);
      runtime::print(">");
    }
  #endif

    explicit multicast_socket(ref i, ref p) :
      ip(string::to<std::string>(i)),
      port((unsigned short)number::to<number_t>(p)) {
      net.open(ip.c_str(), port,true);
    }

    bool have_pending_data() const {
      return net.have_pending_data();
    }

    bool send(datagram_t & data, number_t size) {
      lock_guard guard(lock);
      multicast_aux::address dest_addr(ip.c_str(), port);
      return net.send(data.data, (size_t)size, dest_addr);
    }

    var recv(){
      lock_guard guard(lock);
      multicast_aux::address src_addr(ip.c_str(), port);

      var buffer = obj<value<datagram_t>>();
      number_t read = (number_t)net.recv(src_addr, value<datagram_t>::to_reference(buffer));

      return runtime::list(obj<number>(read), buffer);
    }
  };
#+end_src

*** serial-port

=ferret.io.serial= includes functions for creating and manipulating
serial ports in a portable manner. For example, a serial port may be
opened in RAW mode at baud rate (assumes 8 data bits, no parity, one
stop bit) using,

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/core/io/serial.clj
  (require '[ferret.io.serial :as serial])

  (def dev (serial/open "/dev/ttyArduino"))
#+end_src

Once opened, port is ready for =read=/=write=.

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/core/io/serial.clj
  (when (not dev)
    (system-exit 0))

  (sleep 2500)

  (let [data-out (list \4 \2 \newline)]
    (doseq [byte data-out]
      (serial/write dev byte))

    (sleep 100)
    
    (let [data-in (repeatedly 3 #(serial/read dev))]
      (assert (= data-in data-out))))
#+end_src

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/src/ferret/io/serial.clj
  (native-header "termios.h"
                 "fcntl.h"
                 "unistd.h"
                 "sys/ioctl.h")

  (defn open-aux [^std_string port speed v-min v-time]
    "struct termios toptions;
     int fd;

     fd = open(port.c_str(), O_RDWR | O_NOCTTY | O_NDELAY);

     if (fd == -1){
       return nil();
      }else{

       if (tcgetattr(fd, &toptions) < 0) {
         return nil();
       }else{

       speed_t rate = B9600;
    
       switch (number::to<number_t>(speed)) {
           case 9600:
               rate = B9600;
               break;
           case 19200:
               rate = B19200;
               break;
           case 38400:
               rate = B38400;
               break;
           case 57600:
               rate = B57600;
               break;
           case 115200:
               rate = B115200;
               break;
           case 230400:
               rate = B230400;
               break;
           case 460800:
               rate = B460800;
               break;
           case 500000:
               rate = B500000;
               break;
           case 576000:
               rate = B576000;
               break;
           case 921600:
               rate = B921600;
               break;
           case 1000000:
               rate = B1000000;
               break;
           case 1152000:
               rate = B1152000;
               break;
           case 1500000:
               rate = B1500000;
               break;
           case 2000000:
               rate = B2000000;
               break;
           case 2500000:
               rate = B2500000;
               break;
           case 3000000:
               rate = B3000000;
               break;
           case 3500000:
               rate = B3500000;
               break;
           case 4000000:
               rate = B4000000;
               break;
           default: 
               return nil();
        }

        cfsetispeed(&toptions, rate);
        cfsetospeed(&toptions, rate);

        // 8N1
        toptions.c_cflag &= (tcflag_t)~PARENB;
        toptions.c_cflag &= (tcflag_t)~CSTOPB;
        toptions.c_cflag &= (tcflag_t)~CSIZE;
        toptions.c_cflag |= (tcflag_t)CS8;
        // no flow control
        toptions.c_cflag &= (tcflag_t)~CRTSCTS;

        toptions.c_cflag |= (tcflag_t)CREAD | CLOCAL;  // turn on READ & ignore ctrl lines
        toptions.c_iflag &= (tcflag_t)~(IXON | IXOFF | IXANY); // turn off s/w flow ctrl

        toptions.c_lflag &= (tcflag_t)~(ICANON | ECHO | ECHOE | ISIG); // make raw
        toptions.c_oflag &= (tcflag_t)~OPOST; // make raw

        toptions.c_cc[VMIN]  = (cc_t)number::to<number_t>(v_min);
        toptions.c_cc[VTIME] = (cc_t)number::to<number_t>(v_time);

        if( tcsetattr(fd, TCSANOW, &toptions) < 0) {
         return nil();
        }else
          return obj<number>(fd);
      }
     }")

  (defn open
    ([port]
     (open-aux port 9600 0 20))
    ([port speed]
     (open-aux port speed 0 20))
    ([port speed v-min v-time]
     (open-aux port speed v-min v-time)))


  (defn write [^number_t port ^byte data]
    "byte b[1] = {data};
     write(port, b, 1);")

  (defn available [^number_t port]
    "int bytes_ready;
     int op = ioctl(port, FIONREAD, &bytes_ready);
     if (op == -1)
       return nil();
     return obj<number>(bytes_ready);")

  (defn read [^number_t port]
    "char b[1] = {0};
     ssize_t bytes_read = read(port, b, 1);
     
     if (bytes_read == -1)
       return nil();
     else
       return obj<number>(b[0]);")
#+end_src

** Control
*** State Machines

This macro allows users to define state machines using the following
DSL,

#+begin_src clojure :tangle no
  (def two-state-machine
    (fsm 
     (states
      (off :off)
      (on  :on))
     (transitions
      (off (fn [] true) on)
      (on  (fn [] true) off))))

  (dotimes [i 10]
    (let [state (two-state-machine)]
      (if (= state :off)
        (println "Off")
        (println "On"))))
#+end_src

Each transition takes a list of =fn=, =state= pairs first function that
returns true, returns the next state.

#+begin_src c++ :mkdirp yes :tangle src/src/ferret/obj/fsm_o.h
  class fsm final : public lambda_i {
    mutex lock;
    var env;
    var state;
    var transitions;
  public:

    fsm(ref e, ref t) : env(e), state(runtime::first(e)), transitions(t){ }

    var invoke(ref) const {
      return var((object*)this).cast<fsm>()->yield();
    }

    var yield() {
      lock_guard guard(lock);
      var value = run(state);
      var next = transitions.cast<lambda_i>()->invoke(runtime::list(env, state));

      if (next.is_nil())
        next = state;

      state = next;
      return value;
    }
    
  };
#+end_src

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defobject fsm "ferret/obj/fsm_o.h")

  (defn new-fsm [env transitions]
    "return obj<fsm>(env, transitions)")

  (defmacro fsm [[_ & states] [_ & transitions]]
    (let [states (->> (reduce (fn [h v]
                                (let [[name & body] v]
                                  (conj h name `(fn [] ~@body))))
                              [] states)
                      (apply flatland.ordered.map/ordered-map))
          fsm-state (gensym)
          switch (->> (reduce
                       (fn [h v]
                         (let [[state & conds] v
                               at-state `(= ~state ~fsm-state)
                               jmp (if (= (count conds) 1)
                                     (first conds)
                                     (->> (reduce
                                           (fn [h v]
                                             (let [[check state] v]
                                               (conj h `(~check) state)))
                                           ['cond] (partition 2 conds))
                                          (apply list)))]
                           (conj h at-state jmp)))
                       ['cond] transitions)
                      (apply list))]
      `(new-fsm (list ~@(vals states))
                (fn [[~@(keys states)]
                    ~fsm-state]
                  ~switch))))
#+end_src

*** PID Control

From Wikipedia: 

#+BEGIN_QUOTE
A PID controller calculates an 'error' value as the difference between
a measured [Input] and a desired setpoint. The controller attempts to
minimize the error by adjusting [an Output].
#+END_QUOTE

From [[http://playground.arduino.cc/Code/PIDLibrary][PIDLibrary]],

#+BEGIN_QUOTE
So, you tell the PID what to measure (the "Input",) Where you want
that measurement to be (the "Setpoint",) and the variable to adjust
that can make that happen (the "Output".) The PID then adjusts the
output trying to make the input equal the setpoint.
#+END_QUOTE

#+begin_src clojure :tangle no
  (def controller (pid-controller :kp 0.5
                                  :ki 0
                                  :kd 0
                                  :set-point 5 ;; or a fn
                                  ;;in min - in max - out min - out max
                                  :bounds [0 10 0 10]
                                  :continuous false))

  (println "Control" (controller 0))
#+end_src

Ported from,

#+begin_src java
  /*
   ,* *********************************************************
   ,* Copyright (c) 2009 - 2015, DHBW Mannheim - Tigers Mannheim
   ,* Project: TIGERS - Sumatra
   ,* Date: Jun 10, 2015
   ,* Author(s): Nicolai Ommer <nicolai.ommer@gmail.com>
   ,* *********************************************************
   ,*/

  /**
   ,* @author Nicolai Ommer <nicolai.ommer@gmail.com>
   */
#+end_src

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defobject pid_controller "ferret/obj/pid_controller_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :tangle src/src/ferret/obj/pid_controller_o.h
  template <typename T>
  class pid_controller : public lambda_i {
    mutex lock;
    mutable T setpoint;
    mutable T prev_error;
    mutable T total_error;
    mutable T error;
    mutable T result;
    mutable T input;

    T p;
    T i;
    T d;
    T maximum_output;
    T minimum_output;
    T maximum_input;
    T minimum_input;
    bool continuous;
    var setpoint_fn;

    void set_setpoint(ref p) {
      lock_guard guard(lock);
      T sp = number::to<T>(p);
      if (maximum_input > minimum_input) {
        if (sp > maximum_input) {
          setpoint = maximum_input;
        } else if (sp < minimum_input) {
          setpoint = minimum_input;
        } else {
          setpoint = sp;
        }
      } else {
        setpoint = sp;
      }
    }
    
    var step(ref in) {
      lock_guard guard(lock);
      input = number::to<T>(in);

      // Calculate the error signal
      error = setpoint - input;

      // If continuous is set to true allow wrap around
      if (continuous) {
        if (runtime::abs(error) > ((maximum_input - minimum_input) / real_t(2))) {
          if (error > real_t(0)) {
            error = (error - maximum_input) + minimum_input;
          } else {
            error = (error + maximum_input) - minimum_input;
          }
        }
      }
                                
      /*
       ,* Integrate the errors as long as the upcoming integrator does
       ,* not exceed the minimum and maximum output thresholds
       ,*/
      if ((((total_error + error) * i) < maximum_output) &&
          (((total_error + error) * i) > minimum_output)) {
        total_error += error;
      }
                                
      // Perform the primary PID calculation
      result = ((p * error) + (i * total_error) + (d * (error - prev_error)));
                                
      // Set the current error to the previous error for the next cycle
      prev_error = error;
                                
      // Make sure the final result is within bounds
      if (result > maximum_output) {
        result = maximum_output;
      } else if (result < minimum_output) {
        result = minimum_output;
      }

      return obj<number>(result);
    }
    
  public:
    pid_controller(T kp, T ki, T kd,
                   T inMin, T inMax, T outMin, T outMax,
                   bool cont,
                   ref sp):
      p(kp),
      i(ki),
      d(kd),
      maximum_output(outMax),
      minimum_output(outMin),
      maximum_input(inMax),
      minimum_input(inMin),
      continuous(cont){

      if (sp.is_type(type_id<lambda_i>)){
        setpoint_fn = sp;
        set_setpoint(run(setpoint_fn));
      }else{
        set_setpoint(sp);
      }

      prev_error = 0;
      total_error = 0;
      error = 0;
      result = 0;
      input = 0;
    }

    var invoke(ref args) const {
      if (!setpoint_fn.is_nil())
        var((object*)this).cast<pid_controller<T>>()
          ->set_setpoint(run(setpoint_fn));
      
      return var((object*)this).cast<pid_controller<T>>()
        ->step(runtime::first(args));
    }
  };

#+end_src

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
(defn new-pid-controller [^real_t kp ^real_t ki ^real_t kd
                          ^real_t i-min ^real_t i-max
                          ^real_t o-min ^real_t o-max
                          ^bool_t cont
                          sp]
  "return obj<pid_controller<real_t>>(kp, ki, kd, i_min, i_max, o_min, o_max, cont, sp);")

(defmacro pid-controller [& options]
  (let [defaults {:kp 0 :ki 0 :kd 0 :set-point 0 :bounds [-1 1 -1 1] :continuous false}
        options (merge defaults (apply hash-map options))
        {:keys [container kp ki kd set-point bounds continuous]} options
        [in-min in-max out-min out-max] bounds]
    `(new-pid-controller ~kp ~ki ~kd ~in-min ~in-max ~out-min ~out-max ~continuous ~set-point)))
#+end_src

*** Moving Average Filter

A First order IIR filter (exponentially decaying moving average
filter) to approximate a K sample first order IIR filter to
approximate a K sample moving average. This filter approximates a
moving average of the last K samples by setting the value of alpha to
1/K.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defobject moving_average_filter "ferret/obj/moving_average_filter_o.h")

  (defn new-moving-average-filter [^real_t a]
    "return obj<moving_average_filter<real_t>>(a);")
#+end_src

#+begin_src c++ :mkdirp yes :tangle src/src/ferret/obj/moving_average_filter_o.h
  template <typename T>
  class moving_average_filter : public lambda_i {
    mutex lock;
    T alpha;
    mutable T avrg;

    var step(T data) {
      lock_guard guard(lock);
      avrg = ((alpha * data) + ((1. - alpha) * avrg));
      return obj<number>(avrg);
    }
    
  public:

    explicit moving_average_filter(T a) : alpha(a), avrg(0) { }

    var invoke(ref args) const {
      return var((object*)this).cast<moving_average_filter<T>>()
        ->step(number::to<T>(runtime::first(args)));
    }
  };
#+end_src

 - http://electronics.stackexchange.com/a/34426
 - http://stackoverflow.com/a/3761318

** Arduino
*** pin-mode

Configures the specified pin to behave either as an input or an
output.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
(defn pin-mode [^number_t pin mode]
  "::pinMode(pin, (mode == obj<keyword>(\":input\")) ? INPUT : OUTPUT);")
#+end_src

*** digital-write

Write a HIGH or a LOW value to a digital pin.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defnative digital-write [^number_t pin ^number_t val]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::digitalWrite(pin, val);"))
#+end_src

*** digital-read

Reads the value from a specified digital pin, either HIGH or LOW.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defnative digital-read [^number_t pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "return obj<number>(::digitalRead(pin));"))
#+end_src

*** analog-write

Writes an analog value (PWM wave) to a pin.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defnative analog-write [^number_t pin ^number_t val]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::analogWrite(pin,val);"))
#+end_src

*** analog-read

Reads the value from the specified analog pin.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defnative analog-read [^number_t pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "return obj<number>(::analogRead(pin));"))
#+end_src

*** analog-write-resolution

Sets the resolution of the *analog-write*

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defnative analog-write-resolution [^number_t bit]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::analogWriteResolution(bit);"))
#+end_src

*** analog-read-resolution

Sets the size (in bits) of the value returned by *analog-read*.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defnative analog-read-resolution [^number_t bit]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::analogReadResolution(bit);"))
#+end_src

*** bounce

Bounce object can be used to reliably read push buttons or mechanical
sensors which have contacts that "chatter" or "bounce".

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/embedded/bounce_pin/bounce_pin.clj
  (require '[ferret.arduino :as gpio])

  (def button (gpio/new-bounce 7 250))

  (while true
    (when (pos? (button))
      (println "Pressed!"))
    (sleep 250))
#+end_src

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defobject bounce "ferret/obj/arduino/bounce_o.h")

  (defn new-bounce [^number_t x ^number_t t-debounce]
    "return obj<bounce>(x, t_debounce);")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/arduino/bounce_o.h
  class bounce final : public lambda_i {
    mutex lock;
    void (bounce::* fsm_state)();
    byte state;
    byte last_state;
    unsigned long t_debounce;
    unsigned long t_last_debounce;
    byte pin;
    
    void debounce(){
      int reading = digitalRead(pin);

      // reset the debouncing timer
      if (reading != last_state){
        t_last_debounce = millis();
        last_state = reading;
      }
      
      if ((::millis() - t_last_debounce) > t_debounce){
        if (reading == LOW)
          fsm_state = &bounce::off;
        else
          fsm_state = &bounce::on;
      }
    }
    
    void init(){
      pinMode(pin, INPUT);
      fsm_state = &bounce::debounce;
    }

    void on(){
      state = 1;
      fsm_state = &bounce::debounce;
    }

    void off(){
      state = 0;
      fsm_state = &bounce::debounce;
    }

    var step(){
      lock_guard guard(lock);
      (this->*fsm_state)();
      return obj<number>(state);
    }

   public:

    explicit bounce(number_t p, number_t t_db) :
      fsm_state(&bounce::init),
      state(0),
      last_state(0),
      t_debounce(t_db),
      t_last_debounce(millis()),
      pin(p)
      {}

    var invoke(ref args) const {
      return var((object*)this).cast<bounce>()->step();
    }
  };
#+end_src

*** random

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defnative random-seed [^number_t pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "randomSeed(analogRead(pin));"))

  (defnative random [^number_t x]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "return obj<number>(random(x));"))
#+end_src

*** tone/noTone

Generates a square wave of the specified frequency (and 50% duty
cycle) on a pin.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defnative tone [^number_t pin ^number_t freq]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::tone(pin, freq);"))

  (defnative no-tone [^number_t pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::noTone(pin);"))
#+end_src

*** attach-interrupt

Registers an interrupt function for the given pin and mode. See
[[https://www.arduino.cc/en/Reference/AttachInterrupt][attachInterrupt()]] for more information.

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/embedded/interrupt/interrupt.clj
  (require '[ferret.arduino :as gpio])

  (def input-pin  3)
  (def debug-pin 13)

  (gpio/pin-mode debug-pin :output)

  (defn control-light []
    (->> (gpio/digital-read  input-pin)
         (gpio/digital-write debug-pin)))

  (gpio/attach-interrupt input-pin :change control-light)

  (forever
   (sleep 100))
#+end_src

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defmacro attach-interrupt [pin mode callback]
    (let [mode    (-> mode name .toUpperCase)
          isr-fn  (gensym)
          isr-pin (gensym)]
      `(do
         (def ~isr-fn  ~callback)
         (def ~isr-pin ~pin)
         (cxx
          ~(str "::pinMode(" isr-pin " , INPUT_PULLUP);\n"
                "auto isr_pin = digitalPinToInterrupt(" isr-pin ");\n"
                "::attachInterrupt(isr_pin, [](){ run(" isr-fn ");}, " mode ");")))))
#+end_src

*** no-interrupt

Executes critical section with interrupts disabled.

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defmacro no-interrupt [& body]
    `(no-interrupt-aux  (fn [] ~@body)))

  (defn no-interrupt-aux [f]
    "noInterrupts();
     __result = run(f);
     interrupts();")
#+end_src

*** detach-interrupt

Turns off the given interrupt.

#+BEGIN_EXAMPLE
  (detach-interrupt input-pin)
#+END_EXAMPLE

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defn detach-interrupt [^number_t p]
    "detachInterrupt(digitalPinToInterrupt(p));")
#+end_src

*** SPI

Serial Peripheral Interface (SPI) is a synchronous serial data
protocol used by microcontrollers for communicating with one or more
peripheral devices over short distances. It can also be used for
communication between two microcontrollers. This is a wrapper around
Arduino SPI library see [[https://www.arduino.cc/en/Reference/SPI][documentation]] for more details.

**** Initialization

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defnative spi-begin []
    (on "defined FERRET_HARDWARE_ARDUINO"
        ("SPI.h")
        "SPI.begin();"))

  (defn spi-end []
    "SPI.end();")
#+end_src

**** Settings

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defmacro spi-settings [max-speed data-order data-mode]
    (let [speed      (* max-speed 1000000)
          data-order (if (= data-order :msb-first)
                       "MSBFIRST"
                       "LSBFIRST")
          data-mode  (condp = data-mode
                       :mode-0 "SPI_MODE0"
                       :mode-1 "SPI_MODE1"
                       :mode-2 "SPI_MODE2"
                       :mode-3 "SPI_MODE3")]
      `(cxx ~(str "return obj<value<SPISettings>>(" speed "," data-order "," data-mode ");"))))
#+end_src

**** Transaction

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino.clj
  (defn with-spi-aux [conf f]
    "SPI.beginTransaction(value<SPISettings>::to_reference(conf));
     __result = run(f);
     SPI.endTransaction();")

  (defmacro with-spi [conf & body]
    `(with-spi-aux ~conf (fn [] ~@body)))

  (defn spi-write [^number_t val]
    "return obj<number>(SPI.transfer(val));")
#+end_src

*** Watchdog Timer

A watchdog timer is an electronic timer that is used to detect and
recover from program malfunctions. During normal operation, the
program regularly resets the watchdog timer to prevent it from
elapsing, or "timing out".

**** AVR

#+begin_src clojure
  (require '[ferret.arduino.avr :as avr])

  ;; initialize 
  (avr/wdt-enable 1000)

  (while true
    ;; do stuff
    (avr/wdt-reset))
#+end_src

#+begin_src clojure :mkdirp yes :tangle src/src/ferret/arduino/avr.clj
  (defmacro wdt-enable [timer]
    (let [timer (condp = timer
                  15   "WDTO_15MS"
                  30   "WDTO_30MS"
                  60   "WDTO_60MS"
                  120  "WDTO_120MS"
                  250  "WDTO_250MS"
                  500  "WDTO_500MS"
                  1000 "WDTO_1S"
                  2000 "WDTO_2S"
                  4000 "WDTO_4S"
                  8000 "WDTO_8S")]
      `(cxx ~(str "wdt_enable(" timer ")"))))

  (defnative wdt-reset []
    (on "defined __AVR_ARCH__"
        ("avr/wdt.h")
        "wdt_reset();"))
#+end_src

** Testing
*** assert

Evaluates expr and aborts if it does not evaluate to logical true.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn assert-aux [f msg]
    (when (not (f))
      (println "Assertion Failed =>" msg)
      (system-exit 1)))

  (defn assert-aux-callback [f callback]
    (when (not (f)) (callback)))

  (defmacro assert
    ([exp]
     `(assert-aux (fn [] ~exp) ~(-> exp pr-str (clojure.string/escape {\\ "\\\\"}))))
    ([exp callback]
     `(assert-aux-callback (fn [] ~exp) (fn [] ~callback))))
#+end_src

*** deftest

Support for Clojure style unit testing. See [[Unit Testing]] for more
information.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defn is-aux-expect [ex-fb form-fn form-str]
    (let [expect (ex-fb)
          got  (form-fn)]
      (when (not=  expect got)
        (println "fail in" form-str "\n expected" expect "\n      got" got)
        (system-exit 1))))

  (defn is-aux [f msg]
    (when (not (f))
      (println "fail" msg)
      (system-exit 1)))

  (defmacro is [form]
    (let [check-op (first form)
          form-str (-> form pr-str (clojure.string/escape {\\ "\\\\"}))]

      (cond (= check-op '=)
            (let [[_ expected form] form]
              `(is-aux-expect (fn [] ~expected) (fn [] ~form) ~form-str))
            
            :default `(is-aux (fn [] ~form) ~form-str))))

  (defmacro deftest [name & exprs]
    (defonce fir-unit-tests (atom []))
    (swap! fir-unit-tests conj name)
    `(def ~name (fn [] ~@exprs)))

  (defmacro run-all-tests []
    (if (bound? #'fir-unit-tests)
      `(do ~@(map #(list %) @fir-unit-tests) (system-exit 0))
      `(do (system-exit 0))))
#+end_src

** Compiler
*** configure-runtime!

Configure Ferret Runtime options. See table in [[Configuration]] section.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defmacro configure-runtime! [& body]
    `(native-define ~(->> (partition 2 body)
                          (map #(str "#define " (first %) " " (second %) "\n"))
                          (list))))
#+end_src

*** configure-ferret!

Embed compilations options.

#+name: runtime-clojure-core
#+begin_src clojure :tangle no
  (defmacro configure-ferret! [& body]
    `(native-define ~(str "// build-conf-begin\n"
                          "//" (str (apply hash-map body)) "\n"
                          "// build-conf-end\n")))
#+end_src

* Testing
** Unit Testing

The reliability and robustness of Ferret is achieved in part by
thorough and careful testing. Ferret lisp has built-in support for
unit testing using an API that mimics [[https://clojure.github.io/clojure/clojure.test-api.html][clojure.test]].

The core of the library is the "is" macro, which lets you make
assertions of any arbitrary expression, which will print a message if
the assertion fails.

#+begin_src clojure
  (is (= 42 (meaning-of-life)))
#+end_src

These assertions can be grouped using a [[deftest]] form which defines a
test function with no arguments. Tests can be defined separately from
the rest of the code, even in a different module.

#+begin_src clojure :tangle no
  (defn meaning-of-life [] 42)

  (deftest life-test
    (is (= 42 (meaning-of-life))))

  (run-all-tests)
#+end_src

This will create a function named =life-test=, which can be called
like any other function.  Therefore, tests can be grouped and
composed, in a style similar to the test framework in Peter Seibel's
"Practical Common Lisp" Finally all tests in the current program can
be run using the [[deftest][run-all-tests]].

** Continuous Integration

Each new commit is tested against a set of assertions.  Tests are run
by the CI system for the following compilers/frameworks, 

 - GCC 5
 - Clang 7.0
 - Arduino 1.8.7

Most tests are done using the built in unit testing framework, but certain
tests, those that target the workings of the compiler are easier to do
using =clojure.test= framework by compiling forms using Ferret then
comparing the their runtime output to their expected output. All
generated code is statically checked using =cppcheck= and tested
against memory leaks and undefined behavior.

Build options,

 - -std=c++11
 - -pedantic
 - -Werror
 - -Wall
 - -Wextra
 - -Wconversion
 - -Wpointer-arith
 - -Wmissing-braces
 - -Woverloaded-virtual
 - -Wuninitialized
 - -Winit-self
 - -Wsign-conversion
 - -fno-rtti
 - -fsanitize=undefined,address,leak
 - -fno-omit-frame-pointer

Static code analysis (cppcheck) options,

 - --std=c++11
 - --template=gcc
 - --enable=all
 - --error-exitcode=1

** Compiler
*** Three Shaking

#+name: clojure-unit-tests
#+begin_src clojure :tangle no
  (deftest three-shaking
    (is (= '((defn c [] 1)
             (defn b [] (c))
             (defn a [] (b))
             (a))
           (shake-concat '((defn no-call-a [])
                           (defnative no-call-b [] (on "" ""))
                           (defn c [] 1)
                           (defn b [] (c))
                           (defn a [] (b)))
                         '((a)))))
    
    (is (= '((defn y [])
             (let [a 1]
               (defn b []))
             (println (b) (y)))
           (shake-concat '((defn x [] )
                           (defn y [] )
                           (let [a 1]
                             (defn b [] )
                             (defn c [] a)))
                         '((println (b) (y))))))
    
    (is (= '((defn p-create []) (defn p-update []))
           (take 2 (shake-concat '((defn p-create [])
                                   (defn p-update [])
                                   (defmacro pc [& options]
                                     `(let [controller# (p-create)]
                                       (fn [input#] (p-update)))))
                                 '((pc))))))
    
    (is (= '(defn new-lazy-seq [f] )
           (first (shake-concat '((defn new-lazy-seq [f] )
                                  (defmacro lazy-seq [& body]
                                    `(new-lazy-seq (fn [] ~@body)))
                                  (defn range
                                    ([high]
                                     (range 0 high))
                                    ([low high]
                                     (if (< low high)
                                       (cons low (lazy-seq
                                                  (range (inc low) high)))))))
                                '((range 10)))))))
#+end_src

*** Function Transforms

#+name: clojure-unit-tests
#+begin_src clojure :tangle no
  (deftest test-fn->lift
    (let [prg-a (compile '((defn one-plus-one []
                             (+ 1 1))

                           (while true
                             (+ 1 1))) {})
          prg-b (fn->lift
                 '(fn* outer [a]
                       (fn* inner-a [b]
                            (+ a b))
                       (fn* inner-b [c] c)))

          prg-c (fn->lift
                 '((fn* inner-a [a]
                        ((fn* inner-b [b]
                              ((fn* inner-c [c] (+ b c))
                               3))
                         2))
                   1))
          prg-d (fn->lift
                 '((fn* inner-a [a]
                        ((fn* inner-b [b]
                              ((fn* inner-c [c] (+ b))
                               3))
                         2))
                   1))]
      ;;while shoud use one-plus-one in its body
      ;;check fn-defined?
      (is (= 2 (count (parser/peek prg-a (fn [f] (= 'one_plus_one f))))))

      (is (= 1 (->> (fn [f] (= '(fir-defn-heap inner-a (a) [b] (+ a b)) f))
                    (parser/peek prg-b)
                    count)))
      (is (= 1 (->> (fn [f] (= '(fir-defn-heap inner-b () [c] c) f))
                    (parser/peek prg-b)
                    count)))
      (is (= 1 (->> (fn [f] (= '(fir-defn-heap inner-c (b) [c] (+ b c)) f))
                    (parser/peek prg-c)
                    count)))
      (is (= 1 (->> (fn [f] (= '(fir-defn-heap inner-c (b) [_] (+ b)) f))
                    (parser/peek prg-d)
                    count)))))
#+end_src

#+name: clojure-unit-tests
#+begin_src clojure :tangle no
  (deftest test-fn->inline
    (let [prg-a (compile '((defn  fn-inline [x] x)
                           (defn ^{:volatile true} fn-no-inline [y] y)
                           (fn-inline 42)
                           (fn-no-inline 42)) {})]
      (is (= 1 (->> (fn [f] (= '(fn_no_inline 42) f))
                    (parser/peek prg-a)
                    count)))
      (is (= 1 (->> (fn [f] (= '((fir_fn_stack fn_inline) 42) f))
                    (parser/peek prg-a)
                    count)))))
#+end_src

*** Escape Analysis

#+name: clojure-unit-tests
#+begin_src clojure :tangle no
  (deftest test-escape-analysis
    (let [prg-a (compile '((defn self [x] x)
                           (self 42)) {})
          prg-b (compile '((defn self [x] x)
                           (self self)) {})

          prg-c (compile '((defn multi ([x] x))) {})]

      (is (not (empty? (parser/peek prg-a (parser/form? 'fir_defn_stack)))))
      (is (not (empty? (parser/peek
                        prg-a (fn [f] (= '(fir_fn_stack self) f))))))
      
      (is (not (empty? (parser/peek prg-b (parser/form? 'fir_defn_heap)))))
      (is (not (empty? (parser/peek
                        prg-b (fn [f] (= '((fir_fn_stack self) (fir_fn_heap self)) f))))))

      (is (= (->> (parser/peek prg-c (parser/form? 'fir_defn_arity))
                  first second first second second)
             (->> (parser/peek prg-c (parser/form? 'fir_defn_stack)) first second)))))
#+end_src

*** Unit Testing

#+name: clojure-unit-tests
#+begin_src clojure :tangle no
  (deftest testing-unit-test
    (is (= 1 (check-form '((assert (= 2 1))))))
    (is (= 0 (check-form '((assert (= 2 1))) {:release true})))
    (is (= 0 (check-form '((run-all-tests)))))

    (is (= 1 (check-form '((deftest some-test
                             (is (= 2 3)))
                           (run-all-tests)))))


    (is (= 0 (check-form '((deftest some-test
                             (is (= 2 2)))
                           (run-all-tests)))))

    (is (= 1 (check-form '((deftest some-test
                             (is (= 5 (apply + (list 1 2 3)))))
                           (run-all-tests)))))

    (is (= 0 (check-form '((deftest some-test
                             (is (= 6 (apply + (list 1 2 3)))))
                           (run-all-tests))))))
#+end_src

** Native
*** Fixed Point

#+begin_src c++ :noweb yes :mkdirp yes :tangle src/test/native/fixed_real.cpp
  #include <cassert>
  #include <runtime.h>

  int main() {
    typedef ferret::fixed_real<32,8> fix_32;
    typedef ferret::fixed_real<64,8> fix_64;
    
    // Test Casting
    assert((char)          fix_32(char(25))  == char(25));
    assert((int)           fix_32(int(1024)) == int(1024));
    assert((long)          fix_64(long(25))  == long(25));
    assert((unsigned long) fix_64(2500UL)    == 2500UL);

    long max_int = std::numeric_limits<int>::max() + 1024L;
    assert((long)fix_64(max_int) == ((long)std::numeric_limits<int>::max() + 1024L));

    // Test Arithmetic
    fix_32 x;
    fix_32 y;
    x = 10;
    y = 0.250;
    assert(10.25 == (double)(x + y));

    x = fix_32(0);
    for(int i = 0; i < 100; i++)
      x += fix_32(0.0625);
    assert((double)x == 6.25);

    x = fix_32(22.75);
    y = fix_32(12.5);
    assert((double)(x + y) == 35.25);

    x = fix_32(22.75);
    y = fix_32(22.5);
    assert((double)(x - y) ==  0.25);
    assert((double)(y - x) == -0.25);

    x = fix_32(-0.25);
    y = fix_32(4);
    assert((double)(x / y) ==  -0.0625);

    x = fix_32(-0.0625);
    y = fix_32(-10);
    assert((double)(x - y) ==  9.9375);

    x = fix_32(9.9375);
    y = fix_32(-3);
    assert((double)(x * y) ==  -29.8125);

    x = fix_32(-29.8125);
    y = fix_32(0.1875);
    assert((double)(x - y) ==  -30);

    return 0;
  }
#+end_src

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/test/core/fixed_num.clj
  (configure-runtime! FERRET_REAL_TYPE    "ferret::fixed_real<24,16>"
                      FERRET_REAL_EPSILON 0.0001)

  (cxx "static_assert(sizeof(int24_t) == 3 * sizeof(byte), \"\");")
  (cxx "static_assert(sizeof(int24_t) ==     sizeof(real_t), \"\");")

  (deftest math
    (is (=  3    (+  1.25   1.75)))
    (is (=  0.5  (- -1.25  -1.75)))
    (is (=  255  (+  254    1)))
    (is (=  255  (+  253.4  1.6)))
    (is (= -255  (- -254    1))))

  (run-all-tests)
#+end_src

*** Matrices

#+begin_src c++ :noweb yes :mkdirp yes :tangle src/test/native/matrix.cpp
  #include <cassert>
  #include <runtime.h>

  int main() {
    using namespace ferret;
    <<runtime-native-matrix-test>>
    return 0;
  }
#+end_src

*** Array

#+begin_src c++ :noweb yes :mkdirp yes :tangle src/test/native/container_array.cpp
  #include <cassert>
  #include <runtime.h>

  int main() {
    using namespace ferret;

    array<int, 5> numbers{{1, 2, 3, 4, 5}};
   
    assert((numbers[0] == 1));
    assert((numbers[1] == 2));
    assert((numbers[2] == 3));
    assert((numbers[3] == 4));
    assert((numbers[4] == 5));
    
    for (int& x : numbers) { x++; }
   
    assert((numbers[0] == 2));
    assert((numbers[1] == 3));
    assert((numbers[2] == 4));
    assert((numbers[3] == 5));
    assert((numbers[4] == 6));
    
    return 0;
  }
#+end_src

*** Bitset

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/test/native/bitset.cpp
#include <cassert>
#include <runtime.h>

int main() {
  using namespace ferret;

  assert(FERRET_BITSET_USE_COMPILER_INTRINSICS == true);
  
  bitset<32> bs_a;
  assert(32 == bs_a.ffs(0));
  for(size_t i = 0; i < 2; i++)  bs_a.set(i);
  assert(0  == bs_a.ffs(0));
  assert(1  == bs_a.ffs(1));
  for(size_t i = 7; i < 16; i++) bs_a.set(i);
  assert(2  == bs_a.ffr(0));
  assert(5  == bs_a.ffr(5));
  assert(16 == bs_a.ffr(10));
  assert(32 == bs_a.ffs(31));

  bitset<64> bs_b;
  assert(0  == bs_b.ffr(0));
  assert(64 == bs_b.ffs(0));
  for(size_t i = 0; i < 8; i++)   bs_b.set(i);
  assert(0  == bs_b.ffs(0));
  assert(5  == bs_b.ffs(5));
  assert(8  == bs_b.ffr(5));
  for(size_t i = 16; i < 48; i++) bs_b.set(i);
  assert(16 == bs_b.ffs(8));
  assert(48 == bs_b.ffr(16));

  bitset<1024> bs_c;
  assert(0     == bs_c.ffr(0));
  assert(1024  == bs_c.ffs(0));
  for(size_t i = 0; i < 32; i++)  bs_c.set(i);
  assert(0     == bs_c.ffs(0));
  assert(32    == bs_c.ffr(0));
  for(size_t i = 256; i < 512; i++) bs_c.set(i);
  assert(256   == bs_c.ffs(256));
  assert(512   == bs_c.ffr(256));
  for(size_t i = 768; i < 1024; i++) bs_c.set(i);
  assert(1024  == bs_c.ffr(768));

  bitset<1024> bs_d;
  assert(0    == bs_d.ffr(0));
  bs_d.flip(0);
  assert(1    == bs_d.ffr(0));
  bs_d.flip(0);
  assert(0    == bs_d.ffr(0));

  assert(1024 == bs_d.ffs(0));
  bs_d.set(0, 1024);
  assert(0 == bs_d.ffs(0));
  bs_d.reset(0, 1024);
  assert(1024 == bs_d.ffs(0));
  bs_d.flip(0, 1024);
  assert(0 == bs_d.ffs(0));
  bs_d.flip(0, 1024);
  assert(1024 == bs_d.ffs(0));

  bs_d.set(256,512);
  bs_d.set(768,1024);

  assert(512  == bs_d.ffr(256));
  assert(256  == bs_d.ffs(256));
  assert(1024 == bs_d.ffr(768));
  assert(768  == bs_d.ffs(768));

  bs_d.reset(0,1024);
  for(size_t i = 0; i < 87; i++)  bs_d.set(i);
  for(size_t i = 90; i < 94; i++)  bs_d.set(i);
  for(size_t i = 106; i < 111; i++)  bs_d.set(i);
  for(size_t i = 136; i < 149; i++)  bs_d.set(i);

  assert(106 == bs_d.ffs(94,100));

  assert((15    == bitset<8,unsigned char>::bit_block(0,4)));
  assert((15    == bitset<32,unsigned int>::bit_block(0,4)));
  assert((60    == bitset<32,unsigned int>::bit_block(2,4)));
  assert((1024  == bitset<32,unsigned int>::bit_block(10,1)));
  assert((3072  == bitset<32,unsigned int>::bit_block(10,2)));
  assert((98304 == bitset<32,unsigned int>::bit_block(15,2)));
  assert((-1U   == bitset<32,unsigned int>::bit_block(0,60)));
  assert((-1U   == bitset<32,unsigned int>::bit_block(0,32)));

  return 0;
}
#+end_src

*** Memory Pool

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/test/native/memory_pool.cpp
#define FERRET_MEMORY_POOL_SIZE 4_MB
#define FERRET_BITSET_WORD_TYPE unsigned int

#include <cassert>
#include <runtime.h>

int main() {
  using namespace ferret::memory;
  using namespace allocator;

  assert(0  == align_req(0,8));
  assert(7  == align_req(1,8));
  assert(0  == align_req(8,8));

  assert(0  == align_of(0,8));
  assert(8  == align_of(1,8));
  assert(8  == align_of(8,8));

  alignas(16) int buff [4];
  assert(0  == align_req<int16_t>(buff));
  assert(reinterpret_cast<std::uintptr_t>(buff) == align_of<int16_t>(buff));

  size_t byte_s = sizeof(ferret::byte);

  memory_pool<ferret::byte, 8, unsigned char> nano_pool;

  void* a = nano_pool.allocate(byte_s);
  assert(nullptr  != a);
  assert(2        == nano_pool.used.ffr(0));
  assert(nullptr  != nano_pool.allocate(byte_s));
  assert(4        == nano_pool.used.ffr(0));

  void* c = nano_pool.allocate(byte_s);

  assert(nullptr  != c);
  assert(6        == nano_pool.used.ffr(0));
  assert(nullptr  != nano_pool.allocate(byte_s));

  nano_pool.free(c);

  assert(4        == nano_pool.used.ffr(0));
  assert(6        == nano_pool.used.ffs(4));
  assert(nullptr  != nano_pool.allocate(byte_s));

  memory_pool<ferret::byte, 16, unsigned char> tiny_pool;

  assert(0        == tiny_pool.used.ffr(0));
  assert(nullptr  != tiny_pool.allocate(byte_s * 2));
  assert(3        == tiny_pool.used.ffr(0));

  void* p = tiny_pool.allocate(byte_s * 4);

  assert(nullptr  != p);
  assert(8        == tiny_pool.used.ffr(0));

  tiny_pool.free(p);

  assert(3        == tiny_pool.used.ffr(0));
  assert(nullptr  == tiny_pool.allocate(byte_s * 40));
  assert(nullptr  != tiny_pool.allocate(byte_s * 6));
  assert(nullptr  != tiny_pool.allocate(byte_s * 1));
  assert(nullptr  != tiny_pool.allocate(byte_s * 1));
  assert(nullptr  == tiny_pool.allocate(byte_s * 10));

  memory_pool<uint64_t, 256> big_pool;

  assert(0        == big_pool.used.ffr(0));

  p = big_pool.allocate(1);

  assert(nullptr  != p);

  assert(2        == big_pool.used.ffr(0));

  big_pool.free(p);

  assert(0        == big_pool.used.ffr(0));
  assert(nullptr  == big_pool.allocate(2048));
  assert(0        == big_pool.used.ffr(0));

  return 0;
}
#+end_src

** Core
*** Functions

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (def make-adder
    (fn [n]
      (fn [x] (+ x n))))

  (def adder
    (make-adder 1))

  (def fibo
    (fn [n]
      (if (< n 2)
        1
        (+ (fibo (- n 1))
           (fibo (- n 2))))))

  (deftest fn-test
    (let [f1 (fn [])
          f2 (fn [])
          m-func (fn
                   ([a] 1)
                   ([a b] 2)
                   ([a b c] 3))
          n-func (do (fn
                       ([]    0)
                       ([x]   1)
                       ([x y] 2)))]
      
      (is (= true  (= f1 f1)))
      (is (= false (= f1 f2)))
      (is (= true  (= f1 (do f1))))
      (is (= false (= f2 (do f1))))
      (is (= 1 (m-func 1)))
      (is (= 2 (m-func 1 2)))
      (is (= 3 (m-func 1 2 3)))
      (is (= 0 (n-func)))
      (is (= 1 (n-func 1)))
      (is (= 2 (n-func 1 2)))

      (is (= 3      (#(+ 1 2))))
      (is (= 11     ((fn [n] (+ n 1)) 10)))
      (is (= 3      (((fn [n] (fn [n] n)) 3) 3)))))

  (deftest special-forms-test
    (let [args (list "1" "2")]
      (is (= args (rest *command-line-args*))))

    (let [a 1]
      (is (= 1 a)))

    (let [a 1
          a 3]
      (is (= 3 a)))
    
    (let [a 1
          b 2]
      (is (= 3 (+ a b))))

    (let [a 1
          b 2
          c 3]
      (is (= 6 (+ a b c))))

    (let [a 1
          b 2]
      (let []
        (is (= 3 (+ a b)))))
    
    (is (= 10 (adder 9)))
    (is (= 89 (fibo 10))))

  (let [x 42]
    (defn let-over-lambda [] x))

  (is (= 42 (let-over-lambda)))

  (is (= (list 5 6 7 8 9)
         ((fn recursive-range [x y]
            (if (< x y)
              (cons x (recursive-range (inc x) y))))
          5 10)))
#+end_src

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (defn destructure-test-1 [[a b c]]
    (list a b c))

  (defn destructure-test-2 [[a [b] c]]
    b)

  (defn destructure-test-3 [[a [_ b] c]]
    b)

  (defn destructure-test-4 [& a]
    a)

  (defn destructure-test-5 []
    (let [[a b c] (list 1 2 3)]
      (list a b c)))

  (defn destructure-test-6 []
    (let [[_ _ a] (list 1 2 3)]
      a))

  (defn destructure-test-7 [a b & [c d]]
    (list c d))

  (defn destructure-test-8 [{a :a} b {c :c}]
    (list a b c))

  (deftest destructuring-test
    (is (= 3                   (count (destructure-test-1 (list 1 2 3)))))
    (is (= 2                   (destructure-test-2 (list 1 (list 2) 3))))
    (is (= 3                   (destructure-test-3 (list 1 (list 2 3) 3))))
    (is (= (list (list 1 2 3)) (destructure-test-4 (list 1 2 3))))
    (is (= (list 1 2 3)        (destructure-test-8 {:a 1} 2 {:c 3})))

    (let [a (list 1 2 3 4)
          [b c & r] a]

      (is (= 1          b))
      (is (= 2          c))
      (is (= (list 3 4) r)))

    (let [a 1 b 2
          [c & r] (list 4 5)]
      
      (is (= 1 a))
      (is (= 2 b))
      (is (= 4 c))
      (is (= (list 5) r)))

    (let [[a & r] (list 1 2 3)
          rr (rest r)]
      (is (= (list 3) rr)))
    
    (is (= (list 1 2 3) (destructure-test-5)))
    (is (= 3            (destructure-test-6)))
    (is (= (list 3 4)   (destructure-test-7 1 2 3 4)))

    (let [[a & b :as all-list]   (list 1 2 3)
          [c     :as other-list] all-list]
      (is (= 1            a))
      (is (= (list 2 3)   b))
      (is (= (list 1 2 3) all-list))
      (is (= 1            c))
      (is (= (list 1 2 3) other-list)))
    
    (let [[_ _ a] (list 1 2 3)
          [_ b] (list 4 5 6)]
      (is (= 3 a))
      (is (= 5 b)))

    (let [a (list 1 2 3)
          [b c d e f g] a]
      (is (= 1   b))
      (is (= 2   c))
      (is (= 3   d))
      (is (= nil e))
      (is (= nil f))
      (is (= nil g))))
#+end_src

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (native-declare "ferret::number_t i = 0;")

  (defn inc-int []
    "__result =  obj<number>(i++);")

  (deftest ffi-test
    (is (= true  ((fn [a b] "return obj<boolean>((a == b))") (list 1 2) (list 1 2))))
    (is (= false ((fn [a b] "return obj<boolean>((a != b))") (list 1 2) (list 1 2))))
    (is (= true  ((fn [a b] "return obj<boolean>((a != b))") (list 1 2) 1)))
    (is (= false ((fn [a b] "return obj<boolean>((a == b))") 1          (list 1 2))))

    (is (= 0 (inc-int)))
    (is (= 1 (inc-int)))

    (is (=  nil   (my-find (list 5 5) (list (list 1 2)
                                            (list 2 3)
                                            (list 4 5)))))
    (is (=  true  (my-find (list 1 2) (list (list 1 2)
                                            (list 2 3)
                                            (list 4 5)))))
    (is (=  true  (my-find (list 4 5) (list (list 1 2)
                                            (list 2 3)
                                            (list 4 5)))))
    
    (is (= (list 3 2 1) (my-sort > (list 1 3 2))))
    (is (= (list 1 2 3) (my-sort < (list 1 3 2)))))
#+end_src

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (deftest doto-test
    (let [st (atom )
          add (fn [s v]
                (swap! s conj v))]
      (doto st
        (add 1)
        (add 2)
        (add 3))
      (is (= (list 3 2 1) @st))))
#+end_src

*** Logic

#+name: ferret-unit-tests
#+begin_src clojure
  (defn pos-neg-or-zero [n]
    (cond
      (< n 0) -1
      (> n 0)  1
      :else    0))

  (deftest logical-operators-test
    (is (= true  (< 2)))
    (is (= true  (< 2 3 4 5)))
    (is (= true  (> 2)))
    (is (= false (> 2 3 4 5)))
    (is (= true  (> 6 5 4 3)))
    (is (= true  (>= 2)))
    (is (= true  (>= 5 4 3 2 2 2)))
    (is (= false (>= 5 1 3 2 2 2)))
    (is (= true  (<= 2)))
    (is (= true  (<= 2 2 3 4 5)))
    (is (= false (<= 2 2 1 3 4)))
    (is (= true  (= 2)))
    (is (= false (= 2 3)))
    (is (= true  (= 2 2 2 2)))
    (is (= true  (= 2 2.0 2)))
    (is (= false (= 2 2 2 2 3 5)))
    (is (= true  (= (list 1 2) (list 1 2))))
    (is (= false (= (list 1 2) (list 1 3))))
    (is (= true  (= true true)))
    (is (= false (not (= true true))))
    (is (= false (not 1)))

    (let [a (fn [x] (+ 1 x))
          b (fn [x] (inc x))]
      (is (= true  (= a a)))
      (is (= false (= a b)))
      (is (= true  (= nil ((fn [] )))))
      (is (= true  (= nil ((fn [x y] ) 1 2)))))

    (is (= -1  (pos-neg-or-zero -5)))
    (is (=  1  (pos-neg-or-zero  5)))
    (is (=  0  (pos-neg-or-zero  0)))

    (is (= true  (true? true)))
    (is (= false (true? false)))
    (is (= false (false? true)))
    (is (= true  (false? false)))
    (is (= false (= nil 1)))
    (is (= false (= 1 nil)))
    (is (= true  (= nil nil)))

    (is (= true  (pos? 1)))
    (is (= true  (pos? 0.2)))
    (is (= false (pos? 0)))
    (is (= false (neg? 1)))
    (is (= true  (neg? -1)))
    (is (= true  (zero? 0)))
    (is (= false (zero? 10)))
    (is (= true  (zero? (- 1 1))))
    (is (= true  (zero? (- 1.2 1.2))))
    (is (= true  (zero? (+ 1.2 -1.2)))))
#+end_src

*** Flow

#+name: ferret-unit-tests
#+begin_src clojure
  (deftest conditionals-test
    (is (= 2     (if 1 2)))
    (is (= 1     (if (zero? 0) 1 -1)))
    (is (= -1    (if (zero? 1) 1 -1)))
    (is (= 2     (when true 2)))
    (is (= 2     (if nil 1 2)))
    (is (= nil   (if-let [a nil] a)))
    (is (= 5     (if-let [a 5] a)))
    (is (= 2     (if-let [[_ a] (list 1 2)] a)))
    (is (= nil   (when-let [a nil] a)))
    (is (= 5     (when-let [a 5] a)))
    (is (= 2     (when-let [[_ a] (list 1 2)] a)))

    (is (= 1     (when (< 2 3) 1)))
    (is (= true  (let [a 1] (and (> a 0) (< a 10)))))
    (is (= false (let [a 11] (and (> a 0) (< a 10)))))
    (is (= true  (and true  (identity true))))
    (is (= false (and true  (identity false))))
    (is (= true  (or  true  (identity false))))
    (is (= false (or  false (identity false))))


    (let [lst (atom (list 1 2 3 4 5))
          acc (atom )]
      
      (while-let [item (first @lst)]
        (swap! lst rest)
        (swap! acc conj item))

      (is (empty? @lst))
      (is (not (empty? @acc)))
      (is (= (list 5 4 3 2 1) @acc))))
#+end_src

*** Sequential

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (deftest sequence-test
    (is (= true  (= (list ) (list ))))
    (is (= 0     (count (list ))))
    (is (nil?    (first (rest (rest (list))))))
    (is (= false (= (list )       (list 1 2 3))))
    (is (= false (= (list )       (list nil))))
    (is (= false (= (list 1 2 3)  (list 1 2))))
    (is (= false (= (list 1 2)    (list 1 2 3))))
    (is (= true  (= (list 1 2 3)  (list 1 2 3))))
    (is (= false (= (list 1 2 3)  (list 1 2 4))))
    (is (= false (= (list 1 1 3)  (list 1 2 3))))
    (is (empty? (list )))

    (is (= (list 1)           (cons 1 nil)))
    (is (= (list nil)         (cons nil nil)))
    (is (= 1                  (first (list 1 2 3 4))))
    (is (= 2                  (second (list 1 2 3 4))))
    (is (= (list 2 3 4)       (rest (list 1 2 3 4))))
    (is (= (list 3 4)         (rest (rest (list 1 2 3 4)))))
    (is (= (list 3 3 4)       (cons 3 (rest (rest (list 1 2 3 4))))))
    (is (= 3                  (first (cons 3 (rest (rest (list 1 2 3 4)))))))
    (is (= 4                  (count (list 1 2 3 4))))
    (is (= (list 4 3 2 1 1 2) (conj (list 1 2) 1 2 3 4)))
    (is (= (list 4 3 2 1)     (conj nil 1 2 3 4)))
    (is (= 21                 (reduce + (list 1 2 3 4 5 6))))
    (is (= 21                 (apply + (list 1 2 3 4 5 6))))
    (is (= 9                 (apply + 1 2 (list 1 2 3))))
    (is (= 12                (apply + 1 2 3 (list 1 2 3))))
    
    (is (= 1   (nth (list 1 2 3) 0)))
    (is (= 2   (nth (list 1 2 3) 1)))
    (is (= 3   (nth (list 1 2 3) 2)))
    (is (= nil (nth (list 1 2 3) 10)))
    (is (= nil (nth (list 1 2 3) -10)))

    (is (= (list 0 1 2 3 4 5 6 7 8 9)  (nthrest (range 10) 0)))
    (is (= (list )                     (nthrest (range 10) 20)))
    (is (= (list 5 6 7 8 9)            (nthrest (range 10) 5)))
    
    (is (= (list 1 2 3 4) (drop 0 (list 1 2 3 4))))
    (is (= (list 2 3 4)   (drop 1 (list 1 2 3 4))))
    (is (= (list 3 4)     (drop 2 (list 1 2 3 4))))
    (is (= (list )        (drop 4 (list 1 2 3 4))))
    (is (= (list )        (drop 5 (list 1 2 3 4))))

    (let [my-list (list 1 2 3 4 5 6)]
      (is (= (list 3 4 5 6) (drop-while #(> 3 %) my-list)))
      (is (= (list 4 5 6)   (drop-while #(>= 3 %) my-list))))

    (is (= (list 6 5 4 3 2 1) (reverse (list 1 2 3 4 5 6))))
    (is (= (list 6 5 4 3 2)   (reduce (fn [h v] (conj h (inc v))) (list) (list 1 2 3 4 5))))
    (is (= (list 4 3 2 1 0)   (reduce (fn [h v] (conj h (dec v))) (list) (list 1 2 3 4 5))))

    
    (is (= 1 (first (repeatedly 3 (fn [] 1)))))
    (is (= 3 (count (repeatedly 3 (fn [] 1)))))
    (is (= 3 (count (doall (repeatedly 3 (fn [] 1))))))
    (is (= 2 (->> (repeatedly 3 (fn [] 1)) (map inc) first)))
    (is (= 2 (->> (repeatedly (fn [] 1)) (take 3) (map inc) reverse first)))

    (is (= 1 (count (filter true? (list false false true)))))
    (is (= 2 (count (filter true? (list true false true false false)))))
    (is (= 2 (count (filter true? (list true false true false)))))
    (is (= 2 (count (filter false? (list true false true false)))))
    (is (= 3 (count (filter false? (list true false true false false)))))
    (is (= 2 (count (filter (fn [x] (not (false? x))) (list true false true false false)))))
    (is (empty? (filter true? (list false false))))

    (let [sum (cxx "var alist = runtime::list(obj<number>(1),obj<number>(2),obj<number>(3));
                    number_t sum = 0;
                    for_each(it, alist){
                      sum += number::to<number_t>(it);
                    }
                    __result = obj<number>(sum);")]
      (is (= 6 sum))))
#+end_src

#+name: ferret-unit-tests
#+begin_src clojure
  (defn lazy-countdown [n]
    (if (>= n 0)
      (cons n (lazy-seq (lazy-countdown (- n 1))))))

  (defn ints-from [n]
    (cons n (lazy-seq (ints-from (inc n)))))

  (defn fib-seq
    ([]
     (fib-seq 0 1))
    ([a b]
     (lazy-seq
      (cons b (fib-seq b (+ a b))))))

  (deftest lazy-seq-test
    (is (empty? (lazy-seq )))
    (is (= false (= (range 10) (range 15))))
    (is (= false (= (range 15) (range 10))))
    (is (= true  (= (range 10) (range 10))))
    (is (= 10    (first (ints-from 10))))
    (is (= 11    (first (rest (ints-from 10)))))
    (is (= 12    (first (rest (rest (ints-from 10))))))
    (is (= 10    (first (lazy-countdown 10))))
    (is (= 9     (first (rest (lazy-countdown 10)))))
    (is (= 8     (first (rest (rest (lazy-countdown 10))))))
    (is (= 11    (count (lazy-countdown 10))))

    (is (= 2   (first (map inc (list 1 2 3)))))
    (is (= 0   (first (map dec (list 1 2 3)))))
    (is (= 4   (first (map (fn [x] (+ 3 x)) (list 1 2 3)))))
    (is (= 3   (count (map inc (list 1 2 3)))))
    (is (= (list (list 1 4) (list 2 5))   (map (fn [a b] (list a b)) (list 1 2) (list 4 5))))
    (is (= 10  (apply + (range 5))))
    (is (= 5   (count (range 5))))
    (is (= 2   (first (take 2 (map inc (list 1 2 3))))))
    (is (= 3   (first (rest (take 2 (map inc (list 1 2 3)))))))
    (is (= 3   (count (take 20 (map inc (list 1 2 3))))))
    (is (= 1   (first (concat (list 1 2 3) (list 4 5 6)))))
    (is (= 4   (first (drop 3 (concat (list 1 2 3) (list 4 5 6))))))
    (is (= 21  (reduce + (concat (list 1 2 3) (list 4 5 6)))))

    (is (= (list 1 2)            (cons 1 (cons 2 (lazy-seq )))))
    (is (= (list -2 -1)          (take-while neg? (list -2 -1 0 1 2 3))))
    (is (= (list -2 -1 0 1 2)    (take-while #(< % 3) (list -2 -1 0 1 2 3))))
    (is (= (list -2 -1 0 1 2 3)  (take-while #(<= % 3) (list -2 -1 0 1 2 3))))
    (is (= (list -2 -1 0 1 2 3)  (take-while #(<= % 4) (list -2 -1 0 1 2 3))))
    
    (is (empty? (concat)))
    
    (= (list 1 1 2 3 5) (take 5 (fib-seq)))
    (= 12 (apply + (take 5 (fib-seq))))

    (is (= false (every? false? (list true false))))
    (is (= true  (every? false? (list false false))))
    
    (is (= (list 1 3 2 4) (interleave (list 1 2) (list 3 4))))
    (is (= (list 1 3)     (interleave (list 1 2) (list 3))))
    
    (is (= (list (list 0 1 2 3) (list 4 5 6 7))                              (partition 4 (range 10))))
    (is (= (list (list 0 1 2 3) (list 4 5 6 7))                              (partition 4 (range 8))))
    (is (= (list (list 0 1 2 3) (list 6 7 8 9) (list 12 13 14 15))           (partition 4 6 (range 20))))
    (is (= (list (list 0 1 2) (list 6 7 8) (list 12 13 14) (list 18 19 42))  (partition 3 6 (list 42) (range 20))))
    (is (= (list (list 0 1 2 3) (list 6 7 8 9) (list 12 13 14 15) (list 18 19 42 43)) (partition 4 6 (list 42 43 44 45) (range 20)))))

  (let [xs (doall (repeatedly #(rand)))]
    (is (= (take 5 xs) (take 5 xs))))
#+end_src

*** Associative

#+name: ferret-unit-tests
#+begin_src clojure
  (deftest d-list-test
    (let [m (new-d-list 0 (list 0 1)
                        1 (list 1 2))
          mr {:a 1 :b 2}
          mn {1 2 3 4}]

      (is (= {1 2}                         {1 2}))
      (is (not= mn                         {1 2}))
      (is (= (list 0 1)                    (keys m)))
      (is (= (list (list 0 1) (list 1 2))  (vals m)))
      (is (= (list 1 2)                    (m 1)))
      (is (= m                             m))
      (is (= (list 0)                      (keys (dissoc m 1))))
      (is (= mr                            mr))
      (is (= (list :a :b)                  (keys mr)))
      (is (= (list 1  2)                   (vals mr)))
      (is (= 1                             (:a mr)))
      (is (= 1                             (get mr :a 10)))
      (is (= 10                            (get mr :c 10)))
      (is (= 1                             (mr :a)))
      (is (= 1                             (mr :a 10)))
      (is (= 10                            (mr :c 10)))
      (is (= 1                             (:a mr)))
      (is (= 1                             (:a mr 10)))
      (is (= 10                            (:c mr 10)))
      (is (= 6                             (->> mn
                                                (map second)
                                                (apply +))))))
#+end_src

*** Concurrency

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/core/concurrency.clj
  (deftest atom-test
    (let [a (atom nil)
          b (atom nil)]
      (is (= nil          (deref a)))
      (is (= 1            @(atom 1)))
      (is (= 1            (do (reset! a 1) (deref a))))
      (is (= 2            (do (swap! a inc) (deref a))))
      (is (= (list 1 2 3) (do (reset! a (list 1 2 3)) (deref a))))
      (is (= 6            (do (swap! a (fn [l] (reduce + l))) (deref a))))
      (is (= true         (= a a)))
      (is (= false        (= a b)))
      (is (= false        (= a 3.14)))))

  (deftest future-test
    (is (= 42    @(future (+ 41 1))))
    (is (= 42    @(future (sleep 100) (+ 40 2))))
    (is (= false  (future-done? (future (sleep 100) :false))))
    (is (= true   (let [f (future :true)]
                    (deref f)
                    (future-done? f))))
    (is (= 42    @(thread #(+ 41 1)))))

  (deftest delay-test
    (let [d (delay   (+ 1 1))]
      (is (= true    (delay? d)))
      (is (= 2       @d))
      (is (= 2       @d))
      (is (= 42      (force (delay 42))))))    
#+end_src

*** Math

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (deftest number-test
    (is (= 0.5       1/2))
    (is (= 0.33333   1/3))
    (is (= 3501      0xDAD))
    (is (= 2748      0xABC)))

  (deftest math-test
    (is (= 0.6        (+ 0.3 0.3)))
    (is (= 0          (+ )))
    (is (= 1          (+ 1)))
    (is (= 10         (+ 1 2 3 4)))
    (is (= 10         (+ 1 2.0 3 4)))
    (is (= -1         (- 1)))
    (is (= 0          (- 4 2 2)))
    (is (= 0          (- 4 2 2.0)))
    (is (= 1          (* )))
    (is (= 8          (* 2 2 2)))
    (is (= 8          (* 2.0 2 2)))
    (is (= 1          (/ 1)))
    (is (= 0.5        (/ 2)))
    (is (= 1          (/ 4 2 2)))
    (is (= 1          (/ 4 2 2.0)))
    
    (is (= 1          (floor 1.1)))
    (is (= 1          (floor 1.5)))
    (is (= 1          (floor 1.9)))
    (is (= 0          (mod 2 2)))
    (is (= 0          (mod 4 2)))
    (is (= 1          (mod 5 2)))
    (is (= 1          (mod 8 7)))
    (is (= 1          (min 1)))
    (is (= 1          (min 2 1)))
    (is (= 1          (min 3 5 7 1)))
    (is (= 1          (max 1)))
    (is (= 2          (max 2 1)))
    (is (= 7          (max 3 5 7 1)))
    
    (is (= 100        (scale 10 0 10 0 100)))
    (is (= 50         (scale 5 0 10 0 100)))
    (is (= 0          (scale 0 0 10 0 100)))
    (is (= 5          (clamp 10 0 5)))
    (is (= 10         (clamp 10 0 20)))
    (is (= 0          (clamp 10 -10 0)))
    (is (= -10        (clamp -100 -10 0)))

    (is (= 0          (decode-int16 (encode-int16 0))))
    (is (= 512        (decode-int16 (encode-int16 512))))
    (is (= 1024       (decode-int16 (encode-int16 1024))))
    (is (= 2048       (decode-int16 (encode-int16 2048))))
    (is (= 32000      (decode-int16 (encode-int16 32000))))

    (is (= 0          (decode-float (encode-float 0))))
    (is (= 512        (decode-float (encode-float 512))))
    (is (= 1024       (decode-float (encode-float 1024))))
    (is (= 2048       (decode-float (encode-float 2048))))
    (is (= 32000      (decode-float (encode-float 32000))))
    (is (= 512        (decode-float (list 0 0 0 68 42))))
    

    (is (= true       (not (nil? (rand)))))
    (is (= true       (not (nil? (rand 15)))))

    (is (= -5         (bit-not  4)))
    (is (= -1         (bit-not  0)))
    (is (= 7          (bit-or   4 3)))
    (is (= 1          (bit-or   0 1)))
    (is (= 0          (bit-and  4 3)))
    (is (= 0          (bit-and  0 1)))
    (is (= 0          (bit-xor  4 4)))
    (is (= 1          (bit-xor  1 0)))
    (is (= 8          (bit-shift-left 4 1)))
    (is (= 16         (bit-shift-left 4 2)))
    (is (= 2          (bit-shift-right 4 1)))
    (is (= 1          (bit-shift-right 4 2)))

    (is (= 1          (bit-extract 1781 0 2)))
    (is (= 2          (bit-extract 1781 1 2)))
    (is (= 245        (bit-extract 1781 0 8)))
    (is (= 15         (bit-extract 1781 4 4)))
    (is (= 111        (bit-extract 1781 4 8)))
    (is (= 20         (bit-extract 500  0 5)))
    (is (= 15         (bit-extract 500  5 6)))

    (is (= 0xAC3A     (bit-override 0xAAAA 0x0C30 4 8)))
    (is (= 0xBBCC     (bit-override 0xBBBB 0xAACC 0 8)))
    (is (= 0xBACB     (bit-override 0xBBBB 0xAACC 4 8)))
    (is (= 0xBBBB     (bit-override 0xAAAA 0xBBBB 0 16)))
    
    
    (is (= 32         (sqrt 1024)))
    (is (= 2          (sqrt 4)))
    (is (= 8          (pow 2 3)))
    (is (= 16         (pow 2 4)))
    (is (= 1          (cos 0)))
    (is (= -0.99999   (cos 3.145)))
    (is (= 0          (sin 0)))
    (is (= -0.00340   (sin 3.145)))
    (is (= 0.98279    (atan2 45 30)))
    (is (= 180.19522  (to-degrees 3.145)))
    (is (= 3.14159    (to-radians 180)))

    (is (= 2.30258    (log 10)))
    (is (= 2          (log10 100)))

    (let [a 1
          b 2]
      (+ 1 a)
      (+ b a)
      (is (= 1 a))
      (is (= 2 b))
      (* 2 a)
      (* b a)
      (is (= 1 a))
      (is (= 2 b))
      (/ 2 a)
      (/ b a)
      (is (= 1 a))
      (is (= 2 b))
      (- 2 a)
      (- b a)
      (is (= 1 a))
      (is (= 2 b))))
#+end_src

*** Timing

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (deftest timing-test
    (let [now (millis)]
      (sleep 150)
      (is (>= (- (millis) now) 100))))

  (defn ping [] true)

  (deftest fn-throttler-test
    (let [throttled-ping (fn-throttler ping 1 :second :blocking)
          begin (millis)]
      (throttled-ping)
      (throttled-ping)
      (throttled-ping)
      (is (> (- (millis) begin) 2000))
      (is (throttled-ping)))


    (let [throttled-ping (fn-throttler ping 1 :second :non-blocking)
          begin (millis)]
      (throttled-ping)
      (throttled-ping)
      (throttled-ping)
      (is (nil? (throttled-ping)))
      (is (< (- (millis) begin) 1000))))
#+end_src

*** I/O

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (def byte-stream-state (atom nil))

  (defn byte-sample-read-stream [buf]
    (let [buffer (atom buf)]
      (list
       (fn []
         (let [f (first (deref buffer))]
           (swap! buffer rest)
           f))
       (fn []
         (count (deref buffer)))
       (fn [vals]
         (reset! byte-stream-state vals)))))

  (defn byte-sample-write-stream []
    (let [buffer (atom (list))]
      (list
       (fn [v]
         (swap! buffer conj v))
       (fn []
         (reverse (deref buffer))))))

  (deftest byte-stream-test
    (let [[writer get-buffer] (byte-sample-write-stream)
          encoder (byte-stream-encoder writer)
          data (list (list 1 2 3 4)
                     (list 5 6 7 8))]
      (doseq [d data] 
        (encoder d))

      (let [[read in-waiting handler] (byte-sample-read-stream (get-buffer))
            decoder (byte-stream-decoder read in-waiting handler)]
        (dotimes [i 4]
          (decoder))
        (is (= (list 1 2 3 4) @byte-stream-state))
        (dotimes [i 4]
          (decoder))
        (is (= (list 5 6 7 8) @byte-stream-state)))))
 #+end_src
 
*** Control

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (deftest moving-average-filter-test
    (let [f (new-moving-average-filter 0.1)]

      (is (= 1.00 (f 10)))
      (is (= 1.90 (f 10)))
      (is (= 2.71 (f 10)))))

  (deftest pid-controller-test
    (let [controller (pid-controller :kp 1
                                     :ki 0
                                     :kd 0
                                     :set-point 5
                                     :bounds [0 10 0 10]
                                     :continuous false)]

      (is (= 5 (controller 0)))
      (is (= 5 (controller 0))))

    (let [controller (pid-controller :kp 1
                                     :ki 1
                                     :kd 0
                                     :set-point 5
                                     :bounds [0 10 0 20]
                                     :continuous false)]

      (is (= 10 (controller 0)))
      (is (= 15 (controller 0)))
      (is (= 20 (controller 0)))
      (is (= 20 (controller 0))))

    (let [controller (pid-controller :kp 1
                                     :ki 0
                                     :kd 1
                                     :set-point 5
                                     :bounds [0 10 0 20]
                                     :continuous false)]

      (is (= 10 (controller 0)))
      (is (= 5 (controller 0))))

    (let [sp-fn (fn [] 5)
          controller (pid-controller :kp 1
                                     :ki 0
                                     :kd 1
                                     :set-point sp-fn
                                     :bounds [0 10 0 20]
                                     :continuous false)]

      (is (= 10 (controller 0)))
      (is (= 5 (controller 0)))))

  (deftest state-machine-test
    (let [state (atom 0)
          machine (fsm
                   (states
                    (off (swap! state inc) :off)
                    (on  (swap! state inc) :on))
                   (transitions
                    (off             on)
                    (on  (fn [] true) off)))]
      
      (is (= :off (machine)))
      (is (= :on  (machine)))
      
      (dotimes [_ 8]
        (machine))
      
      (is (= 10 (deref state))))

    (let [state (atom 0)
          machine (fsm
                   (states
                    (a (swap! state inc))
                    (b (swap! state inc))
                    (c (swap! state inc))
                    (no-op (swap! state inc)))
                   (transitions
                    (a
                     (fn [] false) no-op
                     (fn [] true)  b)
                    (b c)
                    (c
                     (fn [] false) no-op
                     (fn [] false) no-op
                     (fn [] true)  a
                     (fn [] false) no-op)))]
      (dotimes [_ 10]
        (machine))
      (is (= 10 (deref state))))

    (let [state (atom nil)
          machine (fsm
                   (states
                    (a (swap! state conj 1))
                    (b (swap! state conj 2))
                    (c (swap! state conj 3))
                    (no-op ))
                   (transitions
                    (a
                     (fn [] true) b
                     (fn [] true) c
                     (fn [] true) no-op)
                    (b (fn [] true) no-op)
                    (c (fn [] true) no-op)
                    (no-op (fn [] true) no-op)))]
      (dotimes [_ 50]
        (machine))
      (is (= (list 2 1) (deref state))))

    (let [value (atom 0)
          machine (fsm 
                   (states
                    (increment (swap! value inc))
                    (no-op ))
                   (transitions
                    (increment
                     (fn [] true) increment
                     (fn [] true) no-op)
                    (no-op
                     (fn [] true) no-op)))]
      (machine)
      (machine)
      (is (= 2 (deref value))))

    (let [machine (fsm
                   (states
                    (setup :setup)
                    (done  :done))
                   
                   (transitions
                    (setup (fn [] true) done)))]
      
      (is (= :setup (machine)))
      (is (= :done  (machine)))
      (is (= :done  (machine)))
      
      (dotimes [_ 8]
        (machine))))
#+end_src

*** Pointer

#+name: ferret-unit-tests
#+begin_src clojure
  (deftest pointer-test
    (let [a-ptr (cxx "return obj<pointer>(nullptr);")
          b-ptr (cxx "return obj<pointer>(new int);")
          gc    (fn [p] "delete pointer::to_pointer<int>(p);")]
      (is (= true  (= a-ptr a-ptr)))
      (is (= false (= a-ptr b-ptr)))
      (is (= true  (= b-ptr b-ptr)))
      (gc b-ptr)))

  (deftest value-test
    (let [obj-42 (make-data 42)
          obj-24 (make-data 24)
          val-42 (get-data obj-42)
          val-24 (get-data obj-24)]
      (is (=    obj-42 obj-42))
      (is (not= obj-42 obj-24))
      (is (=    val-42 42))
      (is (=    val-24 24))
      (is (=    25     (do (inc-data obj-24) 
                           (get-data obj-24))))))
#+end_src

*** Keyword

#+name: ferret-unit-tests
#+begin_src clojure
  (deftest keyword-test
    (is (= true  (= :test  :test)))
    (is (= false (= :test  :other_test)))
    (is (= true  (= :space (cxx "return obj<keyword>(\":space\")")))))
#+end_src

*** String

#+name: ferret-unit-tests
#+begin_src clojure
  (deftest string-test
    (let [s1       "Some String"
          s1-added "ASome String"
          s2       "Other String"
          s1-ret   (fn [] "return obj<string>(\"Some String\");")
          s1-eq    (fn [s] "return obj<boolean>((string::to<std::string>(s) == \"Some String\"))")
          s2       "Ali Topu At"
          s3       (fn [] "std::string s = \"Some String\";
                          return obj<string>(s);")]
      (is (= s2 (new-string "Ali Topu At")))
      (is (= false (= s1 s2)))
      (is (= true  (= s1 s1)))
      (is (= true  (= s1 (s3))))
      (is (= false (= s1 3.14)))
      (is (= true  (= s1 (s1-ret))))
      (is (= true  (s1-eq s1)))
      (is (= 99 \c))
      (is (= \S (first s1)))
      (is (= s1-added (cons 65 s1)))
      (is (= s1 (rest (cons 65 s1))))
      (is (= 11 (count s1)))))
#+end_src

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (deftest ston-test
    (is (=  1234.1234 (ston  "1234.1234")))
    (is (= -1234.1234 (ston "-1234.1234")))
    (is (=  1234.1234 (ston  "1 2 3 4. 1 2 3 4 "))))
 #+end_src

#+name: ferret-unit-tests
#+begin_src clojure :tangle no
  (deftest ntos-test
    (is (=  (ntos -12.34) (new-string "-12.3400")))
    (is (=  (ntos  12.001) (new-string "12.0010")))
    (is (=  (ntos  154.132341) (new-string "154.1323"))))
 #+end_src

*** Modules

Run import tests. 

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/core/module.clj
  (require '[modules.module-a :as mod-a]
           '[modules.module-b :as mod-b])

  (deftest module-test-load-as
    (is (= 10  (mod-a/helper-a)))
    (is (= 1   (mod-a/helper-b)))
    (is (= 10  ((mod-a/ten-fn))))
    (is (= 11  ((mod-b/eleven-fn))))
    (is (= 1   (mod-a/helper-c)))
    (is (= 42  (mod-b/macro-call)))
    (is (= :b  (:a (mod-a/some-d-list))))
    (is (= 42  (mod-b/native-single-argument 42))))

  (require 'modules.module-a
           'modules.module-b)

  (require '[modules.module-c :as mod-c]
           'modules.module-d)

  (deftest module-test-load
    (is (= 10  (modules.module-a/helper-a)))
    (is (= 1   (modules.module-a/helper-b)))
    (is (= 10  ((modules.module-a/ten-fn))))
    (is (= 11  ((modules.module-b/eleven-fn))))
    (is (= 1   (modules.module-a/helper-c)))
    (is (= 42  (modules.module-b/macro-call)))
    (is (= 25  (cxx " return obj<number>(dummy_native_fn());")))
    (is (= 2   (cxx "return obj<number>((number_t)std::sqrt(4));"))))

  (run-all-tests)
#+end_src

**** Dummy Modules

Create some dummy programs under /test/,

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/core/module_unit_test.clj
  (require 'modules.module-e)

  (deftest simple-module-test
    (is (= 1  (modules.module-e/foo))))

  (run-all-tests)
#+end_src

#+begin_src clojure :mkdirp yes :tangle src/test/core/module_import_empty_aux_a.clj
  (require '[modules.module-a :as mod-a])
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/core/module_import_empty_aux_b.clj
  (require '[modules.module-a :as mod-a])
  (require '[modules.module-b :as mod-b])

  (native-declare "const int XYZ_SIZE = 123;")
  (native-declare "int xyz_arr[XYZ_SIZE];")
#+end_src 

Create some dummy libs under /test/modules/,

#+begin_src clojure :mkdirp yes :tangle src/test/core/modules/module-a.clj
  (configure-runtime! FERRET_PROGRAM_MAIN "ferret::program_no_exec()")

  (defn helper-a [] 10)

  (defmacro ten-fn [] `(fn [] 10))

  (defmacro helper-b []
    (reduce (fn [a b] (+ a b)) (list 1 2 3))
    1)

  (defn helper-c []
    (helper-b))

  (defn update-aux []
    )

  (def update-data
    (fn-throttler update-aux 1000 :second :blocking))

  (defn some-d-list [] {:a :b :c :d})
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/core/modules/module-b.clj
  (require '[modules.module-c :as mod-c])

  (defn helper-b []
    (mod-c/helper-c))

  (defn eleven-fn []
    (mod-c/eleven-fn))

  (defnative native-single-argument [x]
    (on "defined FERRET_STD_LIB"
        ("utility") ;; dummy include
        "return obj<number>(number::to<number_t>(x));"))

  (defnative macro-aux []
    (on "defined FERRET_STD_LIB"
        "__result = obj<number>(42);"))

  (defmacro macro-call []
    `(do (~'macro-aux)))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/core/modules/module-c.clj
  (native-header "cmath")

  (defn helper-c []
    (print "Module C"))

  (defmacro eleven-fn []
    `(fn [] 11))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/core/modules/module-d.clj
  (native-declare "int dummy_native_fn(){ return 25; }")
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/core/modules/module-e.clj
  (defn foo [] 1)
#+end_src 

* Roadmap
** Compiler

  - *fn*
    - Pre/Post conditions for functions.
      - By default print error and abort. 
      - Let user define a callback function.
    - Documentation String
  - *deps.clj*
    - Support private git repositories. (HTTPS / SSH)
    - Recursively resolve dependencies of dependencies.
  - *Escape Analysis* 
    - Tag if an object escapes via metadata
    - Emit stack object types for escaped variables.
    - Certain forms generate functions that never escape. These can be
      generated on the stack.
    - Extend escape analysis for other types. Currently escape
      analysis is only used for functions.    
    - Since Ferret does whole-program compilation. Implement
      optimizations from Stalin Scheme compiler.
      - https://github.com/barak/stalin
      - https://news.ycombinator.com/item?id=8214343
      - https://justindomke.wordpress.com/2009/02/23/the-stalin-compiler/
  - *Multimethods*
  - *Hardware Support* - On an unknown arch Ferret will run in safe
    mode. See [[Hardware / Operating System Support]].
     - Support for user supplied machine architectures.
     - =defnative= calls in =ferret.core= are arch dependent.
       - Aggregate =on= sections from multiple modules.
       - Autogenerate combined =defnative=.
     - Runtime contains arch specific =ifdefs=
     - =arch.clj= similar to =deps.clj= where platform specific calls
       can be loaded from a file.
     - Or user tags functions via metadata that provides overrides for
       arch specific core functions.

** Data Structures

  - *atomic* 
    - Implement add-watch
      - https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/ARef.java
      - https://clojuredocs.org/clojure.core/add-watch
      - https://stackoverflow.com/questions/13371123/how-do-refs-notify-its-watches-in-clojure
      - https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Atom.java
    - Current implementation uses =std::mutex= for
      synchronization. Clojure uses =AtomicReference=, =std::atomic= 
      provides same behaviour.
      - https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Atom.java
      - http://www.cplusplus.com/reference/atomic/
  - *Tagged Pointers*
     - https://www.snellman.net/blog/archive/2017-09-04-lisp-numbers/
     - https://drmeister.wordpress.com/2015/05/16/tagged-pointers-and-immediate-fixnums-characters-and-single-floats-in-clasp/
     - https://nikic.github.io/2012/02/02/Pointer-magic-for-efficient-dynamic-value-representations.html
     - https://foonathan.net/blog/2016/12/28/variant.html
     - http://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations
     - https://blogs.oracle.com/jrose/fixnums-in-the-vm
  - *Memory Pool* 
    - Allow chainable allocators. i.e Use system
      allocator until OOM then switch to pool allocator or vice versa.
      - [[https://www.youtube.com/watch?v=LIb3L4vKZ7U&t=2457s][CppCon 2015: Andrei Alexandrescu std::allocator]]
      - [[https://github.com/FelixPetriconi/AllocatorBuilder][Allocator Builder]]
      - https://github.com/mtrebi/memory-allocators
      - [[https://www.gamedev.net/articles/programming/general-and-gameplay-programming/c-custom-memory-allocation-r3010/][C++: Custom memory allocation]]
      - [[http://brnz.org/hbr/?p=1735][A little bit of floating point in a memory allocator — Part 1: Background]]
      - https://www.sqlite.org/malloc.html
    - Ability to run functions on different Memory Pools.
      - Improved data locality and safety.
      - Optionally disable reference counting to improve performance since
        whole pool can be garbage collected when done.
      - Stalin also does very good lifetime analysis to reduce the
        amount of garbage needing collection. i.e. it will compute good
        places in the stack to create a heap, then objects that are
        determined to be born and die within that sub-stack are
        allocated from that heap. When the stack unwinds past that
        point, the entire local heap can be released in one fell swoop.
  - C++ implementations of Clojure's persistent data structures. 
    - https://github.com/mninja/persistent-data-structures
    - [[https://news.ycombinator.com/item?id=13049843][Immer: immutable and persistent data structures for C++]]
    - [[https://www.reddit.com/r/cpp/comments/8utg8u/postmodern_immutable_vector_now_boost_licensed/][Postmodern Immutable Vector]]
  - *Finger Trees* - As basis for other functional data structures
    i.e. Set, Vector
    - http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
    - https://github.com/clojure/data.finger-tree/tree/4262f5899a6932b5ab48705c523a15328f902ff6
    - https://www.youtube.com/watch?v=UXdr_K0Lwg4
  - *Channels*
    - https://www.reddit.com/r/cpp/comments/6p3zch/diy_channels/
  - *Co-Operative Multitasking* - For Embedded Systems.
    - http://soda.swedish-ict.se/2372/1/SICS-T--2005-05--SE.pdf
    - https://forum.pjrc.com/threads/25628-Lightweight-Teensy3-x-Fibers-Library-%28C-%29-Available
    - https://github.com/ve3wwg/teensy3_fibers/blob/1ba0c1e79a423f097e12e6c4176b40cf9d4f44e4/fibers.cpp
    - [[https://news.ycombinator.com/item?id=11323660][Simple coroutines for games in C++]]
    - [[https://hackage.haskell.org/package/Workflow-0.8.3/docs/Control-Workflow.html][Control.Workflow]]
    - [[https://news.ycombinator.com/item?id=9402314][Coroutines in C with Arbitrary Arguments]]
    - https://github.com/akouz/a_coos/tree/1a56f686a24c2085fe82986d568f4577b068c0da
    - https://github.com/mikaelpatel/Arduino-Scheduler/tree/d09521f7dc1447ddaea09e32413cf6e96e9e6816
    - http://dotat.at/cgi/git/picoro.git/tree
  - *Unbounded Precision Integers*
    - [[https://rushter.com/blog/python-integer-implementation/][Python internals: Arbitrary-precision integer implementation]]
    - https://github.com/kokke/tiny-bignum-c
    - https://gist.github.com/nvurgaft/0344b2aa4704219d07005e4d8b1d88a2
    - [[http://www.more-magic.net/posts/numeric-tower-part-2.html][CHICKEN's numeric tower: part 2]]
    - [[https://web.archive.org/web/20101208222557/http://www.mactech.com/articles/mactech/Vol.08/08.03/BigNums/index.html][Arbitrarily Large Bignums]]
    - From p.11: PICOBIT: A Compact Scheme System for Microcontrollers
     - Larger values are needed in some embedded applications.
       - 48 bit integers to store MAC addresses.
       - SHA family of cryptographic hashing functions, which need
         values up to 512 bits wide.
       - If an application keeps track of time at the microsecond level
         using a 32-bit value, a wraparound will occur every hour or
         so.
     - Unbounded precision integers are encoded in PICOBIT as linked
       lists of 16 bit values. At the end of each list is either the
       integer 0 or -1, to represent the sign. 0, -1 and other small
       integers have dedicated encodings and do not need to be
       represented as linked lists. The use of this “little-endian”
       representation simplifies the bignum algorithms in particular
       for numbers of different lengths.
     - On versions of PICOBIT which do not support unbounded precision
       integers (including PICOBIT Light), integers are limited to 24
       bits, and encoded directly in the object.

** Libraries

  - [[https://github.com/nakkaya/ferret-teensy-flight-sim][ferret-teensy-flight-sim]] - Use `obj::value`.
  - [[https://github.com/whoshuu/cpr][cpr]] - C++ Requests: Curl for People
  - [[https://github.com/cesanta/mongoose/blob/master/examples/mqtt_client/mqtt_client.c][mongoose mqtt]] - Mongoose MQTT Client/Server
  - [[https://github.com/roboterclubaachen/xpcc][xpcc]] - C++ microcontroller framework

** Issues

  - *Atmega328* - Memory pool page type other than =unsigned char=
    causes corruption. Currently when Arduino Uno is detected
    =unsigned char= page type is forced.
  - *Variadic Templates* - GCC evaluates arguments in reverse order.
    - [[http://stackoverflow.com/questions/14060264/order-of-evaluation-of-elements-in-list-initialization][Order of evaluation of elements in list-initialization]]
    - [[https://blogs.msdn.microsoft.com/vcblog/2016/02/11/compiler-improvements-in-vs-2015-update-2/][Compiler improvements in VS 2015 Update 2]]

** Hardware

  - RPi GPIO
    - http://elinux.org/RPi_Low-level_peripherals
    - http://elinux.org/RPi_GPIO_Code_Samples

** The Rearview

  - *apply* - Behaves differently. =(apply + 1 2 '(3 4))=   equivalent
    to =(apply + '(1 2 3 4))= in Clojure, =(apply + '(1 2 (3 4)))=  in
    Ferret.
  - *Improved Library Support*
    - Something along the lines of [[https://clojure.org/news/2018/01/05/git-deps][Git Deps for Clojure]].
    - automatically pull other ferret projects
    - https://www.reddit.com/r/cpp/comments/3d1vjq/is_there_a_c_package_manager_if_not_how_do_you/ct2s6oy/
    - https://stackoverflow.com/questions/38657064/package-management-for-c
  - *Maps* - Implement destructuring.
  - *fn* - Named anonymous functions.
  - *Metadata* - Nodes in program tree should retain metadata during
    transformations.
  - *defn-* - Private Functions.
    - Support Clojure's =(def ^{:private true} some-var :value)= form.
  - *Maps* - Implement default =get= values.
  - *Fixed-point Arithmetic*
    Implement fixed point real number type for embedded systems
    without a FPU.
    - [[https://www.reddit.com/r/lisp/comments/51kkym/fixedpoint_arithmetic_in_picolisp/][Fixed-point Arithmetic in Picolisp]]
    - [[https://accu.org/index.php/journals/1717][Why Fixed Point Won't Cure Your Floating Point Blues]]
    - http://jet.ro/files/The_neglected_art_of_Fixed_Point_arithmetic_20060913.pdf
    - [[https://alikhuram.wordpress.com/2013/05/20/implementing-fixed-point-numbers-in-c/][Implementing Fixed-Point Numbers in C++]]
    - https://github.com/johnmcfarlane/fixed_point
    - [[https://www.youtube.com/watch?v=cdaN51rRzSE][CppCon 2016: John McFarlane “fixed_point"]]
  - *Association Lists* as an alternative to maps. More suited to
    embedded systems. Quoted from Wikipedia, for quite small values of
    n it is more efficient in terms of time and space than more
    sophisticated strategies such as hash tables.
    - D-Lists - https://news.ycombinator.com/item?id=11575540
    - https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentHashMap.java
    - https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/APersistentMap.java
  - *Numberic Tower* - Numeric tower is now based on Lua number type.
  - *Pluggable Numbers* - Ability to change the default number type at
    compile time.
  - *Memory* - Option to disable [[Reference Counting]]. Combined with
    =FERRET_ALLOCATE= any third party GC can be supported.
    - http://www.ravenbrook.com/project/mps
    - http://www.hboehm.info/gc/
    Implemented =FERRET_DISABLE_RC= option.
  - *pointer* - A pointer type to handle shared pointers.
    Implemented value object.
  - *Unit Testing*
    - https://www.cs.northwestern.edu/academics/courses/325/readings/lisp-unit.html
    - https://github.com/fukamachi/prove
    - http://tgutu.github.io/clunit/#clunit_2
    - [[https://github.com/aw/picolisp-unit][Unit Testing framework for PicoLisp]]
    - http://aperiodic.net/phil/archives/Geekery/notes-on-lisp-testing-frameworks.html
    - [[http://www.jera.com/techinfo/jtns/jtn002.html][JTN002 - MinUnit -- a minimal unit testing framework for C]]
  - *throttled-fn* - Blocking and non blocking versions.
  - *require* - Import native declarations and headers.
  - *Native Headers* - Make =native-headers= a special form.
  - *Memory Pool* - Allow Multiple Implementations.
    Allow user definable =FERRET_ALLOCATE= - =FERRET_FREE=
  - *string* - string constructor from std::string.
  - *require* - require module without alias.
  - *require* - Only having *require* forms and nothing else causes
    null pointer exception.
  - *require* - Should support requiring multiple libraries. Currently
    each library import requires a require form.
  - *assert* - Strip during release build.
    - *--release* - CLI option added.
  - *pointer* - Ability to call cleanup function before *GC*
  - *Debugging* - Add some debugging macros, native side.
  - =pid_controller= - Implement Unit Tests.
  - *Continuous Integration* - Setup Travis CI, automate testing and
    deployment.
  - Implement *Range-based for loop* for seekable containers.
  - *Benchmarking* - Add a benchmarking function.
  - *Memory Pool* - Functions report in bytes.
  - *sequence* - Remove size from object.
  - =memory_pool= - Enable Locking, make it thread safe.
    - Removed - Wasted to much memory.
  - *Lazy Sequence* - Should cache the result of *rest* and return it
    on subsequent calls.
  - *assert* - https://clojuredocs.org/clojure.core/assert

* Files                                                            :noexport:

#+name: ferret-version
#+begin_src sh :exports results noweb: yes
  echo "`git describe --abbrev=0 --tags`-`git rev-parse --short HEAD`"
#+end_src 

** project.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/project.clj
  (defproject ferret "<<ferret-version()>>"
    :description "Ferret is a lisp implementation designed to be used in real time embedded control systems."
    :url "https://ferret-lang.org/"
    :license {:name "BSD 2-Clause"
              :url "https://github.com/nakkaya/ferret/blob/master/LICENSE"}
    
    :dependencies [[org.clojure/clojure "1.10.0"]
                   [org.clojure/tools.cli "0.4.2"]
                   [org.clojure/tools.logging "0.4.1"]
                   [org.slf4j/slf4j-simple "1.7.25"]
                   [fast-zip "0.7.0"]
                   [clj-jgit "0.8.10"]
                   [org.bituf/clj-stringtemplate "0.2"]
                   [org.clojars.amit/commons-io "1.4.0"]
                   [commons-lang "2.5"]
                   [org.flatland/ordered "1.5.7"]
                   [watchtower "0.1.1"]]

    :deploy-repositories [["releases"  {:sign-releases false :url "https://clojars.org/repo"
                                        :username :env
                                        :password :env}]]

    :repl-options {:host "0.0.0.0"
                   :port 7888
                   :init-ns ferret.core}

    :test-paths ["test/compiler/"]
    :filespecs [{:type :bytes :path "build.info"
                 :bytes ~(.getBytes "<<ferret-version()>>")}]
    
    :main ferret.core
    :aot [ferret.core]
    :jar-name "interim.jar"
    :uberjar-name "ferret.jar")
#+end_src 

** src/
*** ferret/core.clj

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/core.clj
  (ns ferret.core
    (:refer-clojure :exclude [compile])
    (:gen-class)
    (:use [clojure.java.io])
    (:require [ferret.io :as io]
              [ferret.parser :as parser]
              [clojure.set :as set]
              [flatland.ordered.map :as ordered-map]
              [fast-zip.core :as zip]
              [clojure.walk :as walk]
              [clojure.stacktrace :as stacktrace]
              [clojure.pprint :as pprint]
              [clj-jgit.util :as jgit-util]
              [clj-jgit.porcelain :as jgit]
              [clojure.tools.cli :refer [parse-opts]]
              [watchtower.core :as watcher])
    (:use [ferret [template :only [render-template]]]
          [clojure.java.shell]
          [clojure.tools [logging :only [warn info]]]))

  (System/setProperty "org.slf4j.simpleLogger.showLogName" "false")
  (System/setProperty "org.slf4j.simpleLogger.showDateTime" "true")
  (System/setProperty "org.slf4j.simpleLogger.dateTimeFormat" "HH:mm:ss")
  (System/setProperty "org.slf4j.simpleLogger.showThreadName" "false")

  <<core-compiler-helpers>>
  <<core-file-io>>
  <<core-compiler-macro-expansion>>
  <<core-compiler-tree-shaking>>
  <<core-compiler-escape-analysis>>
  <<core-compiler-transformations>>
  <<core-compiler-emitter>>
  <<core-compiler-checkout-deps>>
  <<core-compiler-main>>
#+end_src 

*** ferret/parser.clj

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/parser.clj
  (ns ferret.parser
    (:refer-clojure :exclude [drop peek])
    (:gen-class)
    (:require [ferret.io :as io]
              [fast-zip.core :as zip]
              [clojure.walk :as walk]))

  <<core-compiler-parser>>
#+end_src 

*** ferret/io.clj

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/io.clj
  (ns ferret.io
    (:gen-class)
    (:use [clojure.java.io]
          [clojure.tools [logging :only [warn info]]])
    (:import (org.apache.commons.io FileUtils)
             (java.io BufferedReader InputStreamReader)))

  <<core-main-io>>
#+end_src 

*** ferret/template.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/src/ferret/template.clj
  (ns ferret.template
    (:import (org.antlr.stringtemplate StringTemplateGroup StringTemplate)))

  (defn indexed
    "Returns a lazy sequence of [index, item] pairs, where items come
    from 's' and indexes count up from zero.

    (indexed '(a b c d))  =>  ([0 a] [1 b] [2 c] [3 d])"
    [s]
    (map vector (iterate inc 0) s))

  (defn create-view "Return new view template - useful as mentioned here:
      http://hardlikesoftware.com/weblog/2006/12/12/using-json-with-stringtemplate/"
    ([]
     (StringTemplate.))
    ([^String template]
     (StringTemplate. template)))


  (defn stringify [any]
    (if (keyword? any)
      (name any)
      (str any)))


  (declare kv-to-sv)
  (declare scan-kv-to-sv)


  (defn each-kv-to-sv "If element is a collection type, do deep transformation"
    [each]
    (if (map? each)
      (kv-to-sv each)
      (if (or (vector? each) (list? each) (seq? each) (set? each))
        (scan-kv-to-sv each)
        each)))


  (defn scan-kv-to-sv
    "Scans a collection and turns any contained map within from kv to sv"
    [coll]
    (map each-kv-to-sv coll))


  (defn kv-to-sv
    "Transforms keyword-value map {:a 10 :b 20 :c 30}
       to string-value map {\"a\" 10 \"b\" 20 \"c\" 30}"
    [mp]
    (let [m (into {} mp)
          k (keys m)
          v (vals m)]
      (zipmap
       (map stringify k)
       (scan-kv-to-sv v))))

  (defn get-view-from-classpath "Return the view template from classpath"
    [^String view-name]
    (let [st-group (StringTemplateGroup. "default")]
      (.getInstanceOf st-group view-name)))


  (defn get-view-from-dir "Return the view template from specified directory"
    [^String view-name ^String root-dir]
    (let [st-group (StringTemplateGroup. "default" root-dir)]
      (.getInstanceOf st-group view-name)))


  (defn reset-view! "Reset view template with supplied content"
    [^StringTemplate view ^String template]
    (.setTemplate view template))


  (defn fill-view! "Fill view template with key/value pairs"
      ;;;
    ;; Fill template with key and value
    ([^StringTemplate template k v]
     (.setAttribute template (stringify k) (each-kv-to-sv v))
     template)
      ;;;
    ;; Fill template with key/value from map
    ([^StringTemplate template kv-map]
     (.setAttributes template (kv-to-sv kv-map))
     template))


  (defn render-view "Return rendered view for the template"
    [^StringTemplate template]
    (.toString template))

  (defmacro render-template [template & vars]
    `(let [vars# (hash-map ~@vars)
           view# (create-view ~template)]
       (doseq [[k# v#] vars#]
         (fill-view! view# (name k#) v#))
       (render-view view#)))
#+end_src 

*** ferret/runtime.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/src/ferret/runtime.clj
  <<runtime-clojure-threading-macros>>
  <<runtime-clojure-fn-macros>>
  <<runtime-clojure-interfaces>>
  <<runtime-clojure-objects>>
  <<runtime-clojure-sequence>>
  <<runtime-clojure-logical-operators>>
  <<runtime-clojure-conditional-operators>>
  <<runtime-clojure-math>>
  <<runtime-clojure-core>>
#+end_src

*** ferret/runtime.h

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/runtime.h
  // Detect Hardware
  <<runtime-native-hardware-setup>>

  namespace ferret{
    // Types
    <<runtime-native-type>>
    // Concurrency
    <<runtime-native-hardware-concurrency>>
    // Containers
    <<runtime-native-containers>>
  }

  // Math
  namespace ferret{
    <<runtime-native-number-literals>>
    <<runtime-native-fixed-point-real>>
    <<runtime-native-number-config-macros>>
    <<runtime-native-math>>
  }

  // Initialize Hardware
  namespace ferret{
    <<runtime-native-hardware-initialize>>
  }

  // Object System Base
  namespace ferret{
    <<runtime-native-pointers>>
    <<runtime-native-allocator-helpers>>
    <<runtime-native-allocator-pool-implementation>>
    <<runtime-native-allocator-pool>>
    <<runtime-native-allocators>>
    <<runtime-native-reference-counting>>
    <<runtime-native-object>>
    <<runtime-native-allocator-alloca>>
  }

  namespace ferret{
    <<runtime-native-matrix>>
  }

  // Runtime Prototypes
  namespace ferret{
    <<runtime-native-prototypes>>
  }
#+end_src 

*** ferret/runtime.cpp

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/runtime.cpp
  namespace ferret{
    <<runtime-native-implementations>>
  }
#+end_src 

*** ferret/main.cpp

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/main.cpp
  <<runtime-native-program-run-std-main>>
  <<runtime-native-program-arduino>>
#+end_src 

** test/
*** compiler/ferret.clj

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/test/compiler/ferret.clj
  (ns ferret
    (:refer-clojure :exclude [compile])
    (:use [ferret.core] :reload)
    (:require [ferret.parser :as parser])
    (:use [clojure.test]
          [clojure.java.shell]
          [clojure.tools [logging :only [warn info]]]))

  (defn check-form [form & [opts]]
    (let [options (merge (compile-options) opts)]
      (compile->cpp form options)
      (compile->binary options)
      (with-sh-dir "./"
        (let [exit (->> (sh "./solution") :exit)]
          (sh "rm" "-rf" "solution")
          (sh "rm" "-rf" "solution.cpp")
          exit))))

  <<clojure-unit-tests>>
#+end_src 

*** core/core.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/core/core.clj
  <<value-test-helpers>>
  <<ffi-test-helper>>
  <<ferret-unit-tests>>

  (run-all-tests)
#+end_src

** resources/
*** tangle-docs

#+begin_src emacs-lisp :mkdirp yes :tangle src/resources/tangle-docs :padline no
  (progn 
   (require 'package)
   (package-initialize)

   (add-to-list 'load-path "./")

   (setq package-list '(htmlize clojure-mode))

   (setq package-archives '(("elpa" . "http://tromey.com/elpa/")
                            ("gnu" . "http://elpa.gnu.org/packages/")
                            ("marmalade" . "https://marmalade-repo.org/packages/")))
   (package-initialize)

   (unless package-archive-contents
     (package-refresh-contents))

   (dolist (package package-list)
     (unless (package-installed-p package)
       (package-install package)))

   (require 'htmlize)
   (require 'org)
   (require 'org-macs)
   (require 'ox-html)
   (require 'ob)
   (global-font-lock-mode 1)
   (require 'clojure-mode)
   (require 'clojure-mode-extra-font-locking)
   (setq org-export-with-section-numbers nil)
   (setq org-babel-use-quick-and-dirty-noweb-expansion t)
   (setq org-confirm-babel-evaluate nil)

   ;; for org-mode 8.x
   (when (locate-library "ob-sh")
     (org-babel-do-load-languages
      'org-babel-load-languages '((sh . t))))
   ;; for org-mode 9.x
   (when (locate-library "ob-shell")
     (org-babel-do-load-languages
      'org-babel-load-languages '((shell . t))))
   
   (set-face-foreground 'font-lock-string-face "#990000")
   (set-face-foreground 'font-lock-keyword-face "#ff5f00")
   (set-face-foreground 'font-lock-function-name-face "#d7af00")
   (set-face-foreground 'font-lock-builtin-face "#66cc00")
   (set-face-foreground 'font-lock-comment-face "#008787")

   (find-file "ferret.org")
   (progn 
     (org-html-export-as-html nil)
     (with-current-buffer "*Org HTML Export*"
       (write-region (org-no-properties (buffer-string)) nil "ferret-manual.html"))))
#+end_src

*** jar-sh-header

#+begin_src sh :mkdirp yes :tangle src/resources/jar-sh-header :padline no
  #!/usr/bin/env sh
  MYSELF=`which "$0" 2>/dev/null`
  [ $? -gt 0 -a -f "$0" ] && MYSELF="./$0"
  java=java
  if test -n "$JAVA_HOME"; then
      java="$JAVA_HOME/bin/java"
  fi
  exec "$java" $java_args -jar $MYSELF "$@"
  exit 1 
#+end_src

*** ferret-build/Dockerfile

#+begin_src fundamental :mkdirp yes :tangle src/resources/ferret-build/Dockerfile :padline no
  FROM    ubuntu:16.04
  MAINTAINER Nurullah Akkaya <nurullah@nakkaya.com>

  RUN apt-get update && \
      apt-get upgrade -y

  RUN apt-get install apt-utils software-properties-common -y
  RUN add-apt-repository ppa:openjdk-r/ppa
  RUN apt-get update

  # Setup Tangle Requirements

  RUN apt-get install wget make git emacs24-nox openjdk-8-jre-headless -y

  RUN wget https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein
  RUN chmod +x lein
  RUN mv lein /usr/bin/
  RUN lein

  ENV LEIN_ROOT true

  # Setup Test Requirements

  # arduino
  RUN wget http://downloads.arduino.cc/arduino-1.8.7-linux64.tar.xz
  RUN tar xf arduino-1.8.7-linux64.tar.xz
  RUN mv arduino-1.8.7 /usr/local/share/arduino
  RUN ln -s /usr/local/share/arduino/arduino /usr/local/bin/arduino

  # x86
  RUN apt-get install gcc-5 g++-5 cppcheck -y
  RUN update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 50
  RUN wget http://apt.llvm.org/llvm-snapshot.gpg.key
  RUN apt-key add llvm-snapshot.gpg.key
  RUN apt-add-repository "deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial main"
  RUN apt-get update
  RUN apt-get install clang-6.0 llvm-6.0 -y
  RUN update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-6.0 50

  # Setup Platform Build Requirements
  RUN apt-get install zip reprepro -y
#+end_src

*** deb-package-conf

#+begin_src fundamental :mkdirp yes :tangle src/resources/deb-package-conf :padline no
  Package: ferret-lisp
  Priority: extra
  Section: devel
  Maintainer: Nurullah Akkaya <nurullah@nakkaya.com>
  Architecture: all
  Depends: bash, java-runtime-headless
  Description: Ferret lisp compiler
  Homepage: https://ferret-lang.org/
  Change: ownership: sudo chown -R root:root ./deb
#+end_src

*** deb-repo-conf

#+begin_src fundamental :mkdirp yes :tangle src/resources/deb-repo-conf :padline no
  Codename: ferret-lisp
  Components: main
  Architectures: i386 amd64
#+end_src
*** ferret-mode.el

#+begin_src emacs-lisp :mkdirp yes :tangle src/resources/ferret-mode.el :padline no :results none
  (define-derived-mode ferret-mode
    clojure-mode "Ferret"
    "Major mode for Ferret.
  \\{ferret-mode-map}"

    (define-key ferret-mode-map (kbd "C-c '") 'ferret-indent-cpp)
    (define-key ferret-mode-map (kbd "C-c c") 'compile)

    (require 'compile)
    (require 'ansi-color)

    (defun ferret-colorize-compilation-buffer ()
      (toggle-read-only)
      (ansi-color-apply-on-region compilation-filter-start (point))
      (toggle-read-only))
    
    (add-hook 'compilation-filter-hook 'ferret-colorize-compilation-buffer)
    
    (add-hook 'ferret-mode-hook
              (lambda ()
                (set (make-local-variable 'compile-command)
                     (let ((file (file-name-nondirectory buffer-file-name)))
                       (format "ferret -i %s" buffer-file-name)))))
    
    (defun ferret-indent-cpp ()
      (interactive)
      (let ((cursor-point (point)))
        (ignore-errors
         (let ((pps (parse-partial-sexp (point-min) (point))))
           (when (nth 3 pps)
             (let ((str-begin (nth 8 pps)))
               (goto-char str-begin)
               (forward-sexp)
               (backward-char)
               (let ((str-end (point)))
                 (goto-char str-begin)
                 (forward-char)
                 (set-mark str-end)))
             (let ((col (save-excursion (goto-char (region-beginning))
                                        (current-column))))
               (kill-region (region-beginning) (region-end))
               (insert
                (with-temp-buffer
                  (c++-mode)
                  (yank)
                  ;;un escape "
                  (goto-char (point-min))
                  (replace-string "\\\"" "\"")
                  (indent-region (point-min) (point-max) nil)
                  ;;escape "
                  (goto-char (point-min))
                  (replace-string "\"" "\\\"")
                  ;;select all but first line
                  (goto-char (point-min))
                  (forward-line)
                  (push-mark (point))
                  (push-mark (point-max) nil t)
                  ;;shift all text to col
                  (indent-rigidly (region-beginning) (region-end) col)
                  (buffer-string)))))))
        (goto-char cursor-point))))
#+end_src
